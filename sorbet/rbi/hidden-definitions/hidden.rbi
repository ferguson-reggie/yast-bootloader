# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module AbstractMethod
  VERSION = ::T.let(nil, ::T.untyped)
end

module AbstractMethod
  extend ::T::Sig
end

class Addrinfo
  extend ::T::Sig
end

class ArgumentError
  extend ::T::Sig
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def append(*_); end

  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(*_); end

  def prepend(*_); end

  def replace(_); end

  def shelljoin(); end

  def to_h(); end
end

class Array
  extend ::T::Sig
  def self.try_convert(_); end
end

class Augeas
  ECMDRUN = ::T.let(nil, ::T.untyped)
  EINTERNAL = ::T.let(nil, ::T.untyped)
  EMMATCH = ::T.let(nil, ::T.untyped)
  EMXFM = ::T.let(nil, ::T.untyped)
  ENABLE_SPAN = ::T.let(nil, ::T.untyped)
  ENOLENS = ::T.let(nil, ::T.untyped)
  ENOMATCH = ::T.let(nil, ::T.untyped)
  ENOMEM = ::T.let(nil, ::T.untyped)
  ENOSPAN = ::T.let(nil, ::T.untyped)
  EPATHX = ::T.let(nil, ::T.untyped)
  ESYNTAX = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
  NO_LOAD = ::T.let(nil, ::T.untyped)
  NO_MODL_AUTOLOAD = ::T.let(nil, ::T.untyped)
  NO_STDINC = ::T.let(nil, ::T.untyped)
  SAVE_BACKUP = ::T.let(nil, ::T.untyped)
  SAVE_NEWFILE = ::T.let(nil, ::T.untyped)
  SAVE_NOOP = ::T.let(nil, ::T.untyped)
  TYPE_CHECK = ::T.let(nil, ::T.untyped)
end

BasicObject::BasicObject = BasicObject

class BasicObject
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ClassOverride
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class BasicSocket
  def read_nonblock(len, str=T.unsafe(nil), exception: T.unsafe(nil)); end
end

class BasicSocket
  extend ::T::Sig
end

class BigDecimal
  def clone(); end

  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  extend ::T::Sig
  def self._load(_); end

  def self.double_fig(); end

  def self.limit(*_); end

  def self.mode(*_); end

  def self.save_exception_mode(); end

  def self.save_limit(); end

  def self.save_rounding_mode(); end

  def self.ver(); end
end

module BigMath
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class Binding
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def clone(); end

  def irb(); end

  def local_variable_defined?(_); end

  def local_variable_get(_); end

  def local_variable_set(_, _1); end

  def receiver(); end
end

class Binding
  extend ::T::Sig
end

class Bootloader::BootRecordBackup
  extend ::Yast::Logger
end

class Bootloader::ConfigDialog
  extend ::Yast::Logger
end

class Bootloader::CpuMitigations
  extend ::Yast::Logger
end

class Bootloader::DeviceMap
  def add_mapping(*args, &block); end

  def grub_device_for(*args, &block); end

  def grub_devices(*args, &block); end

  def remove_mapping(*args, &block); end

  def system_device_for(*args, &block); end
end

class Bootloader::DeviceMap
  extend ::Yast::Logger
end

class Bootloader::Grub2Base
  extend ::Yast::Logger
end

module Bootloader::Grub2Widget
  extend ::T::Sig
end

class Bootloader::GrubInstall
  extend ::Yast::Logger
end

class Bootloader::Kexec
  extend ::Yast::Logger
end

class Bootloader::MBRUpdate
  extend ::Yast::Logger
end

class Bootloader::Sections
  extend ::Yast::Logger
end

class Bootloader::Stage1
  def activate=(*args, &block); end

  def activate?(*args, &block); end

  def add_device(*args, &block); end

  def devices(*args, &block); end

  def generic_mbr=(*args, &block); end

  def generic_mbr?(*args, &block); end
end

class Bootloader::Stage1
  extend ::Yast::Logger
end

class Bootloader::Stage1Proposal
  extend ::Yast::Logger
end

class Bootloader::Sysconfig
  extend ::Yast::Logger
end

class Bootloader::UdevMapping
  extend ::Yast::Logger
  def self.instance(); end

  def self.to_kernel_device(*args, &block); end

  def self.to_mountby_device(*args, &block); end
end

module Bootloader
  extend ::T::Sig
end

module Bundler::BuildMetadata
  extend ::T::Sig
end

class Bundler::Definition
  def create_gem_version_promoter(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::AuthenticationRequiredError
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CertificateFailureError
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, options=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, options); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::SSLError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils::DryRun
  extend ::T::Sig
end

module Bundler::FileUtils::LowMethods
  extend ::T::Sig
end

module Bundler::FileUtils::NoWrite
  extend ::T::Sig
end

module Bundler::FileUtils::StreamUtils_
  extend ::T::Sig
end

module Bundler::FileUtils::Verbose
  extend ::T::Sig
end

module Bundler::FileUtils
  extend ::T::Sig
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

module Bundler::GemHelpers
  extend ::T::Sig
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Injector
  def initialize(new_deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

module Bundler::MatchPlatform
  extend ::T::Sig
end

module Bundler::Molinillo::Compatibility
  extend ::T::Sig
end

module Bundler::Molinillo::Delegates::ResolutionState
  extend ::T::Sig
end

module Bundler::Molinillo::Delegates::SpecificationProvider
  extend ::T::Sig
end

module Bundler::Molinillo::Delegates
  extend ::T::Sig
end

module Bundler::Molinillo::SpecificationProvider
  extend ::T::Sig
end

module Bundler::Molinillo::UI
  extend ::T::Sig
end

module Bundler::Molinillo
  extend ::T::Sig
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
  extend ::T::Sig
end

class Bundler::Plugin::DSL
  def _gem(name, *args); end

  def inferred_plugins(); end

  def plugin(name, *args); end
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL
end

class Bundler::Plugin::Index
  def command_plugin(command); end

  def commands(); end

  def global_index_file(); end

  def hook_plugins(event); end

  def index_file(); end

  def installed?(name); end

  def load_paths(name); end

  def local_index_file(); end

  def plugin_path(name); end

  def register_plugin(name, path, load_paths, commands, sources, hooks); end

  def source?(source); end

  def source_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Index
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  extend ::T::Sig
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Resolver::SpecGroup
  def platforms_for_dependency_named(dependency); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

module Bundler::RubyDsl
  extend ::T::Sig
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

module Bundler::SharedHelpers
  extend ::T::Sig
end

class Bundler::UI::RGProxy
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::UI
  extend ::T::Sig
end

module Bundler::URICredentialsFilter
  extend ::T::Sig
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  extend ::T::Sig
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler::YAMLSerializer
  extend ::T::Sig
end

module Bundler
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class CFA::Grub2::Default
  PATH = ::T.let(nil, ::T.untyped)
  VALID_TERMINAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

class CFA::Grub2::DeviceMap
  PATH = ::T.let(nil, ::T.untyped)
end

class CFA::Grub2::GrubCfg
  PATH = ::T.let(nil, ::T.untyped)
end

class CFA::Grub2::InstallDevice
  PATH = ::T.let(nil, ::T.untyped)
end

module CFA::Grub2::InstallDeviceParser
  extend ::T::Sig
end

module CFA::Grub2
  extend ::T::Sig
end

module CFA
  extend ::T::Sig
end

class CGI
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class CGI::Cookie
  extend ::T::Sig
end

module CGI::Escape
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
  extend ::T::Sig
end

class CGI::InvalidEncoding
  extend ::T::Sig
end

module CGI::QueryExtension
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

module CGI::Util
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class CGI
  extend ::T::Sig
end

class CWM::AbstractWidget
  include ::Yast::UIShortcuts
  include ::Yast::I18n
  include ::Yast::Logger
  def cwm_definition(); end

  def disable(); end

  def enable(); end

  def enabled?(); end

  def fun_ref(*args); end

  def handle_all_events(); end

  def handle_all_events=(handle_all_events); end

  def my_event?(event); end

  def refresh_help(); end

  def widget_id(); end

  def widget_id=(widget_id); end
end

class CWM::AbstractWidget
  extend ::Yast::Logger
  def self.widget_type=(type); end
end

class CWM::CheckBox
  include ::CWM::ValueBasedWidget
  def check(); end

  def checked?(); end

  def label(*args); end

  def uncheck(); end

  def unchecked?(); end

  def widget_type(); end
end

class CWM::CheckBox
end

class CWM::ComboBox
  include ::CWM::ValueBasedWidget
  include ::CWM::ItemsSelection
  def label(*args); end

  def widget_type(); end
end

class CWM::ComboBox
end

class CWM::CustomWidget
  def contents(*args); end

  def cwm_contents(); end

  def find_ids(term); end

  def ids_in_contents(); end

  def widget_type(); end
end

class CWM::CustomWidget
end

class CWM::DumbTabPager
  def contents(); end

  def mark_page(page); end
end

class CWM::DumbTabPager
end

class CWM::Empty
  def initialize(id); end

  def widget_type(); end
end

class CWM::Empty
end

class CWM::InputField
  include ::CWM::ValueBasedWidget
  def label(*args); end

  def widget_type(); end
end

class CWM::InputField
end

class CWM::IntField
  include ::CWM::ValueBasedWidget
  def label(*args); end

  def widget_type(); end
end

class CWM::IntField
end

module CWM::ItemsSelection
  def change_items(items_list); end

  def cwm_definition(); end

  def items(); end
end

module CWM::ItemsSelection
  extend ::T::Sig
end

class CWM::MenuButton
  include ::CWM::ItemsSelection
  def label(*args); end

  def widget_type(); end
end

class CWM::MenuButton
end

class CWM::MultiLineEdit
  include ::CWM::ValueBasedWidget
  def label(*args); end

  def widget_type(); end
end

class CWM::MultiLineEdit
end

class CWM::MultiSelectionBox
  include ::CWM::ItemsSelection
  def label(*args); end

  def value(); end

  def value=(val); end

  def widget_type(); end
end

class CWM::MultiSelectionBox
end

class CWM::Page
  def initial(); end

  def initial=(initial); end

  def label(*args); end
end

class CWM::Page
end

class CWM::Pager
  def current_page(); end

  def handle(event); end

  def init(); end

  def initial_page(); end

  def initialize(*pages); end

  def mark_page(*args); end

  def page_for_id(id); end

  def page_order(); end

  def replace_point(); end

  def store_page(); end

  def switch_page(page); end
end

class CWM::Pager
end

class CWM::Password
  include ::CWM::ValueBasedWidget
  def label(*args); end

  def widget_type(); end
end

class CWM::Password
end

class CWM::PushButton
  def label(*args); end

  def widget_type(); end
end

class CWM::PushButtonTabPager
  def contents(); end

  def mark_page(page); end
end

class CWM::PushButtonTabPager
end

class CWM::RadioButtons
  include ::CWM::ItemsSelection
  def label(*args); end

  def value(); end

  def value=(val); end

  def widget_type(); end
end

class CWM::RadioButtons
end

class CWM::ReplacePoint
  def cleanup(); end

  def contents(); end

  def handle(event); end

  def help(); end

  def init(); end

  def initialize(widget:, id: T.unsafe(nil)); end

  def replace(widget); end

  def store(); end

  def validate(); end
end

class CWM::ReplacePoint
end

class CWM::RichText
  include ::CWM::ValueBasedWidget
  def widget_type(); end
end

class CWM::RichText
end

class CWM::SelectionBox
  include ::CWM::ItemsSelection
  def label(*args); end

  def value(); end

  def value=(val); end

  def widget_type(); end
end

class CWM::SelectionBox
end

class CWM::StringTerm
end

class CWM::StringTerm
end

CWM::Tab = CWM::Page

class CWM::Table
  def cell(*args); end

  def change_cell(id, column_number, cell_content); end

  def change_items(items_list); end

  def contents(); end

  def header(*args); end

  def icon(path); end

  def items(); end

  def multiselection?(); end

  def value(); end

  def value=(id); end
end

class CWM::Table
end

class CWM::Tabs
end

class CWM::Tabs
  def self.new(*args); end
end

class CWM::Tree
  def change_items(items); end

  def contents(); end

  def items(); end

  def new_item(*args, **kwargs); end

  def value(); end

  def value=(val); end
end

class CWM::Tree
end

class CWM::TreeItem
  def children(); end

  def icon(); end

  def id(); end

  def initialize(id, label, icon: T.unsafe(nil), open: T.unsafe(nil), children: T.unsafe(nil)); end

  def label(); end

  def open(); end

  def ui_term(); end
end

class CWM::TreeItem
end

class CWM::UITerm
end

class CWM::UITerm
end

module CWM::ValueBasedWidget
  def value(); end

  def value=(val); end
end

module CWM::ValueBasedWidget
  extend ::T::Sig
end

class CWM::WidgetHash
end

class CWM::WidgetHash
end

class CWM::WidgetTerm
end

class CWM::WidgetTerm
end

class CWM::WrapperWidget
  def handle_all_events=(_arg); end

  def initialize(content, id: T.unsafe(nil)); end
end

class CWM::WrapperWidget
  def self.widget_type=(_arg); end
end

module CWM
  extend ::T::Sig
end

module Cheetah
  BUILTIN_DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  READ = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WRITE = ::T.let(nil, ::T.untyped)
end

class Cheetah::DefaultRecorder
  STREAM_INFO = ::T.let(nil, ::T.untyped)
end

module Cheetah
  extend ::T::Sig
end

class Class
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ClassOverride
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def json_creatable?(); end
end

class Class
  extend ::T::Sig
end

class ClosedQueueError
  extend ::T::Sig
end

module Comparable
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class Complex
  extend ::T::Sig
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

ConditionVariable = Thread::ConditionVariable

module Coverage
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.peek_result(); end

  def self.running?(); end

end

class Data
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class Data
  extend ::T::Sig
end

class Date
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Date::Infinity
  extend ::T::Sig
end

class Date
  extend ::T::Sig
end

class DateTime
  extend ::T::Sig
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Delegator
  extend ::T::Sig
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class DidYouMean::ClassNameChecker
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

class DidYouMean::ClassNameChecker
  extend ::T::Sig
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Correctable
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class DidYouMean::DeprecatedIgnoredCallers
  def +(*_); end

  def <<(*_); end
end

class DidYouMean::DeprecatedIgnoredCallers
end

module DidYouMean::Jaro
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def receiver(); end
end

class DidYouMean::MethodNameChecker
  extend ::T::Sig
end

class DidYouMean::NullChecker
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::NullChecker
  extend ::T::Sig
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::SpellChecker
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def correct(input); end

  def initialize(dictionary:); end
end

class DidYouMean::SpellChecker
  extend ::T::Sig
end

class DidYouMean::VariableNameChecker
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_PREDEFINED_OBJECTS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::VariableNameChecker
  extend ::T::Sig
end

module DidYouMean
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.formatter(); end

  def self.formatter=(formatter); end
end

class Digest::Base
  extend ::T::Sig
end

class Digest::Class
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class Digest::Class
  extend ::T::Sig
end

module Digest::Instance
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class Digest::SHA1
  extend ::T::Sig
end

module Digest
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class Dir
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

module Dir::Tmpname
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class Dir
  extend ::T::Sig
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

module Docile
  VERSION = ::T.let(nil, ::T.untyped)
end

module Docile::Execution
  extend ::T::Sig
end

class Docile::FallbackContextProxy
  NON_PROXIED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
  NON_PROXIED_METHODS = ::T.let(nil, ::T.untyped)
end

module Docile
  extend ::T::Sig
end

class EOFError
  extend ::T::Sig
end

class ERB
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

  def result_with_hash(hash); end
end

class ERB::Compiler
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class ERB::Compiler::Buffer
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class ERB::Compiler::Buffer
  extend ::T::Sig
end

class ERB::Compiler::ExplicitScanner
  extend ::T::Sig
end

class ERB::Compiler::PercentLine
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class ERB::Compiler::PercentLine
  extend ::T::Sig
end

class ERB::Compiler::Scanner
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class ERB::Compiler::Scanner
  extend ::T::Sig
end

class ERB::Compiler::SimpleScanner
  extend ::T::Sig
end

class ERB::Compiler::TrimScanner
  extend ::T::Sig
end

class ERB::Compiler
  extend ::T::Sig
end

module ERB::DefMethod
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

module ERB::Util
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class ERB
  extend ::T::Sig
end

class Encoding
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def _dump(*_); end
end

class Encoding::CompatibilityError
  extend ::T::Sig
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  extend ::T::Sig
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::ConverterNotFoundError
  extend ::T::Sig
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::InvalidByteSequenceError
  extend ::T::Sig
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  extend ::T::Sig
end

class Encoding
  extend ::T::Sig
  def self._load(_); end

  def self.locale_charmap(); end
end

class EncodingError
  extend ::T::Sig
end

module Enumerable
  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def each_with_object(_); end

  def grep_v(_); end

  def lazy(); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(*_); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end

  def zip(*_); end
end

module Enumerable
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class Enumerator
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class Enumerator::Generator
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def each(*_); end

  def initialize(*_); end
end

class Enumerator::Generator
  extend ::T::Sig
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

class Enumerator::Lazy
  extend ::T::Sig
end

class Enumerator::Yielder
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def <<(*_); end

  def yield(*_); end
end

class Enumerator::Yielder
  extend ::T::Sig
end

class Enumerator
  extend ::T::Sig
end

class Errno::E2BIG
  extend ::T::Sig
end

class Errno::EACCES
  extend ::T::Sig
end

class Errno::EADDRINUSE
  extend ::T::Sig
end

class Errno::EADDRNOTAVAIL
  extend ::T::Sig
end

class Errno::EADV
  extend ::T::Sig
end

class Errno::EAFNOSUPPORT
  extend ::T::Sig
end

class Errno::EAGAIN
  extend ::T::Sig
end

class Errno::EALREADY
  extend ::T::Sig
end

Errno::EAUTH = Errno::NOERROR

class Errno::EBADE
  extend ::T::Sig
end

class Errno::EBADF
  extend ::T::Sig
end

class Errno::EBADFD
  extend ::T::Sig
end

class Errno::EBADMSG
  extend ::T::Sig
end

class Errno::EBADR
  extend ::T::Sig
end

Errno::EBADRPC = Errno::NOERROR

class Errno::EBADRQC
  extend ::T::Sig
end

class Errno::EBADSLT
  extend ::T::Sig
end

class Errno::EBFONT
  extend ::T::Sig
end

class Errno::EBUSY
  extend ::T::Sig
end

class Errno::ECANCELED
  extend ::T::Sig
end

Errno::ECAPMODE = Errno::NOERROR

class Errno::ECHILD
  extend ::T::Sig
end

class Errno::ECHRNG
  extend ::T::Sig
end

class Errno::ECOMM
  extend ::T::Sig
end

class Errno::ECONNABORTED
  extend ::T::Sig
end

class Errno::ECONNREFUSED
  extend ::T::Sig
end

class Errno::ECONNRESET
  extend ::T::Sig
end

class Errno::EDEADLK
  extend ::T::Sig
end

Errno::EDEADLOCK = Errno::EDEADLK

class Errno::EDESTADDRREQ
  extend ::T::Sig
end

class Errno::EDOM
  extend ::T::Sig
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EDOTDOT
  extend ::T::Sig
end

class Errno::EDQUOT
  extend ::T::Sig
end

class Errno::EEXIST
  extend ::T::Sig
end

class Errno::EFAULT
  extend ::T::Sig
end

class Errno::EFBIG
  extend ::T::Sig
end

Errno::EFTYPE = Errno::NOERROR

class Errno::EHOSTDOWN
  extend ::T::Sig
end

class Errno::EHOSTUNREACH
  extend ::T::Sig
end

class Errno::EHWPOISON
  extend ::T::Sig
end

class Errno::EIDRM
  extend ::T::Sig
end

class Errno::EILSEQ
  extend ::T::Sig
end

class Errno::EINPROGRESS
  extend ::T::Sig
end

class Errno::EINTR
  extend ::T::Sig
end

class Errno::EINVAL
  extend ::T::Sig
end

class Errno::EIO
  extend ::T::Sig
end

Errno::EIPSEC = Errno::NOERROR

class Errno::EISCONN
  extend ::T::Sig
end

class Errno::EISDIR
  extend ::T::Sig
end

class Errno::EISNAM
  extend ::T::Sig
end

class Errno::EKEYEXPIRED
  extend ::T::Sig
end

class Errno::EKEYREJECTED
  extend ::T::Sig
end

class Errno::EKEYREVOKED
  extend ::T::Sig
end

class Errno::EL2HLT
  extend ::T::Sig
end

class Errno::EL2NSYNC
  extend ::T::Sig
end

class Errno::EL3HLT
  extend ::T::Sig
end

class Errno::EL3RST
  extend ::T::Sig
end

class Errno::ELIBACC
  extend ::T::Sig
end

class Errno::ELIBBAD
  extend ::T::Sig
end

class Errno::ELIBEXEC
  extend ::T::Sig
end

class Errno::ELIBMAX
  extend ::T::Sig
end

class Errno::ELIBSCN
  extend ::T::Sig
end

class Errno::ELNRNG
  extend ::T::Sig
end

class Errno::ELOOP
  extend ::T::Sig
end

class Errno::EMEDIUMTYPE
  extend ::T::Sig
end

class Errno::EMFILE
  extend ::T::Sig
end

class Errno::EMLINK
  extend ::T::Sig
end

class Errno::EMSGSIZE
  extend ::T::Sig
end

class Errno::EMULTIHOP
  extend ::T::Sig
end

class Errno::ENAMETOOLONG
  extend ::T::Sig
end

class Errno::ENAVAIL
  extend ::T::Sig
end

Errno::ENEEDAUTH = Errno::NOERROR

class Errno::ENETDOWN
  extend ::T::Sig
end

class Errno::ENETRESET
  extend ::T::Sig
end

class Errno::ENETUNREACH
  extend ::T::Sig
end

class Errno::ENFILE
  extend ::T::Sig
end

class Errno::ENOANO
  extend ::T::Sig
end

Errno::ENOATTR = Errno::NOERROR

class Errno::ENOBUFS
  extend ::T::Sig
end

class Errno::ENOCSI
  extend ::T::Sig
end

class Errno::ENODATA
  extend ::T::Sig
end

class Errno::ENODEV
  extend ::T::Sig
end

class Errno::ENOENT
  extend ::T::Sig
end

class Errno::ENOEXEC
  extend ::T::Sig
end

class Errno::ENOKEY
  extend ::T::Sig
end

class Errno::ENOLCK
  extend ::T::Sig
end

class Errno::ENOLINK
  extend ::T::Sig
end

class Errno::ENOMEDIUM
  extend ::T::Sig
end

class Errno::ENOMEM
  extend ::T::Sig
end

class Errno::ENOMSG
  extend ::T::Sig
end

class Errno::ENONET
  extend ::T::Sig
end

class Errno::ENOPKG
  extend ::T::Sig
end

class Errno::ENOPROTOOPT
  extend ::T::Sig
end

class Errno::ENOSPC
  extend ::T::Sig
end

class Errno::ENOSR
  extend ::T::Sig
end

class Errno::ENOSTR
  extend ::T::Sig
end

class Errno::ENOSYS
  extend ::T::Sig
end

class Errno::ENOTBLK
  extend ::T::Sig
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTCONN
  extend ::T::Sig
end

class Errno::ENOTDIR
  extend ::T::Sig
end

class Errno::ENOTEMPTY
  extend ::T::Sig
end

class Errno::ENOTNAM
  extend ::T::Sig
end

class Errno::ENOTRECOVERABLE
  extend ::T::Sig
end

class Errno::ENOTSOCK
  extend ::T::Sig
end

Errno::ENOTSUP = Errno::EOPNOTSUPP

class Errno::ENOTTY
  extend ::T::Sig
end

class Errno::ENOTUNIQ
  extend ::T::Sig
end

class Errno::ENXIO
  extend ::T::Sig
end

class Errno::EOPNOTSUPP
  extend ::T::Sig
end

class Errno::EOVERFLOW
  extend ::T::Sig
end

class Errno::EOWNERDEAD
  extend ::T::Sig
end

class Errno::EPERM
  extend ::T::Sig
end

class Errno::EPFNOSUPPORT
  extend ::T::Sig
end

class Errno::EPIPE
  extend ::T::Sig
end

Errno::EPROCLIM = Errno::NOERROR

Errno::EPROCUNAVAIL = Errno::NOERROR

Errno::EPROGMISMATCH = Errno::NOERROR

Errno::EPROGUNAVAIL = Errno::NOERROR

class Errno::EPROTO
  extend ::T::Sig
end

class Errno::EPROTONOSUPPORT
  extend ::T::Sig
end

class Errno::EPROTOTYPE
  extend ::T::Sig
end

class Errno::ERANGE
  extend ::T::Sig
end

class Errno::EREMCHG
  extend ::T::Sig
end

class Errno::EREMOTE
  extend ::T::Sig
end

class Errno::EREMOTEIO
  extend ::T::Sig
end

class Errno::ERESTART
  extend ::T::Sig
end

class Errno::ERFKILL
  extend ::T::Sig
end

class Errno::EROFS
  extend ::T::Sig
end

Errno::ERPCMISMATCH = Errno::NOERROR

class Errno::ESHUTDOWN
  extend ::T::Sig
end

class Errno::ESOCKTNOSUPPORT
  extend ::T::Sig
end

class Errno::ESPIPE
  extend ::T::Sig
end

class Errno::ESRCH
  extend ::T::Sig
end

class Errno::ESRMNT
  extend ::T::Sig
end

class Errno::ESTALE
  extend ::T::Sig
end

class Errno::ESTRPIPE
  extend ::T::Sig
end

class Errno::ETIME
  extend ::T::Sig
end

class Errno::ETIMEDOUT
  extend ::T::Sig
end

class Errno::ETOOMANYREFS
  extend ::T::Sig
end

class Errno::ETXTBSY
  extend ::T::Sig
end

class Errno::EUCLEAN
  extend ::T::Sig
end

class Errno::EUNATCH
  extend ::T::Sig
end

class Errno::EUSERS
  extend ::T::Sig
end

class Errno::EXDEV
  extend ::T::Sig
end

class Errno::EXFULL
  extend ::T::Sig
end

class Errno::NOERROR
  extend ::T::Sig
end

module Errno
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::T::Sig
  extend ::Enumerable
  def self.[](*_); end

  def self.each(); end

  def self.members(); end
end

class Etc::Passwd
  def dir(); end

  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid(); end

  def gid=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end

  def shell(); end

  def shell=(_); end

  def uid(); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::T::Sig
  extend ::Enumerable
  def self.[](*_); end

  def self.each(); end

  def self.members(); end
end

module Etc
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.confstr(_); end

  def self.endgrent(); end

  def self.endpwent(); end

  def self.getgrent(); end

  def self.getgrgid(*_); end

  def self.getgrnam(_); end

  def self.getlogin(); end

  def self.getpwent(); end

  def self.getpwnam(_); end

  def self.getpwuid(*_); end

  def self.group(); end

  def self.nprocessors(); end

  def self.passwd(); end

  def self.setgrent(); end

  def self.setpwent(); end

  def self.sysconf(_); end

  def self.sysconfdir(); end

  def self.systmpdir(); end

  def self.uname(); end
end

class Exception
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def full_message(); end

end

class Exception
  extend ::T::Sig
  def self.exception(*_); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class FalseClass
  extend ::T::Sig
end

module FastGettext
  LOCALE_REX = ::T.let(nil, ::T.untyped)
  NAMESPACE_SEPARATOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class FastGettext::GetText::MOFile
  HASHWORDBITS = ::T.let(nil, ::T.untyped)
  MAGIC_BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  MAGIC_LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
end

module FastGettext::GetText
  extend ::T::Sig
end

class FastGettext::MoFile
  PLURAL_SEPERATOR = ::T.let(nil, ::T.untyped)
end

module FastGettext::Storage
  extend ::T::Sig
end

module FastGettext::Translation
  extend ::T::Sig
end

module FastGettext::TranslationMultidomain
  extend ::T::Sig
end

module FastGettext::TranslationRepository
  extend ::T::Sig
end

module FastGettext
  extend ::T::Sig
end

class Fiber
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def resume(*_); end
end

class Fiber
  extend ::T::Sig
  def self.yield(*_); end
end

class FiberError
  extend ::T::Sig
end

class File
  Separator = ::T.let(nil, ::T.untyped)
end

module File::Constants
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class File::Stat
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def size?(); end
end

class File::Stat
  extend ::T::Sig
end

class File
  extend ::T::Sig
  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end

end

FileList = Rake::FileList

module FileTest
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.blockdev?(_); end

  def self.chardev?(_); end

  def self.directory?(_); end

  def self.empty?(_); end

  def self.executable?(_); end

  def self.executable_real?(_); end

  def self.exist?(_); end

  def self.exists?(_); end

  def self.file?(_); end

  def self.grpowned?(_); end

  def self.identical?(_, _1); end

  def self.owned?(_); end

  def self.pipe?(_); end

  def self.readable?(_); end

  def self.readable_real?(_); end

  def self.setgid?(_); end

  def self.setuid?(_); end

  def self.size(_); end

  def self.size?(_); end

  def self.socket?(_); end

  def self.sticky?(_); end

  def self.symlink?(_); end

  def self.world_readable?(_); end

  def self.world_writable?(_); end

  def self.writable?(_); end

  def self.writable_real?(_); end

  def self.zero?(_); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils::LowMethods
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  extend ::T::Sig
  extend ::FileUtils::DryRun
  extend ::FileUtils::LowMethods
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class FileUtils::Entry_
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def blockdev?(); end

  def chardev?(); end

  def chmod(mode); end

  def chown(uid, gid); end

  def copy(dest); end

  def copy_file(dest); end

  def copy_metadata(path); end

  def dereference?(); end

  def directory?(); end

  def door?(); end

  def entries(); end

  def exist?(); end

  def file?(); end

  def initialize(a, b=T.unsafe(nil), deref=T.unsafe(nil)); end

  def lstat(); end

  def lstat!(); end

  def path(); end

  def pipe?(); end

  def platform_support(); end

  def postorder_traverse(); end

  def prefix(); end

  def preorder_traverse(); end

  def rel(); end

  def remove(); end

  def remove_dir1(); end

  def remove_file(); end

  def socket?(); end

  def stat(); end

  def stat!(); end

  def symlink?(); end

  def traverse(); end

  def wrap_traverse(pre, post); end
end

class FileUtils::Entry_
  extend ::T::Sig
end

module FileUtils::LowMethods
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

module FileUtils::NoWrite
  include ::FileUtils::LowMethods
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::NoWrite
  extend ::T::Sig
  extend ::FileUtils::NoWrite
  extend ::FileUtils::LowMethods
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

module FileUtils::StreamUtils_
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::T::Sig
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

module FileUtils
  extend ::T::Sig
  extend ::FileUtils::StreamUtils_
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.cd(dir, verbose: T.unsafe(nil), &block); end

  def self.chdir(dir, verbose: T.unsafe(nil), &block); end

  def self.chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end

  def self.chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end

  def self.cmp(a, b); end

  def self.collect_method(opt); end

  def self.commands(); end

  def self.compare_file(a, b); end

  def self.compare_stream(a, b); end

  def self.copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.copy_entry(src, dest, preserve=T.unsafe(nil), dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.copy_file(src, dest, preserve=T.unsafe(nil), dereference=T.unsafe(nil)); end

  def self.copy_stream(src, dest); end

  def self.cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.getwd(); end

  def self.have_option?(mid, opt); end

  def self.identical?(a, b); end

  def self.install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.options(); end

  def self.options_of(mid); end

  def self.private_module_function(name); end

  def self.pwd(); end

  def self.remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.remove_dir(path, force=T.unsafe(nil)); end

  def self.remove_entry(path, force=T.unsafe(nil)); end

  def self.remove_entry_secure(path, force=T.unsafe(nil)); end

  def self.remove_file(path, force=T.unsafe(nil)); end

  def self.rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.uptodate?(new, old_list); end
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

class Float
  extend ::T::Sig
end

class FloatDomainError
  extend ::T::Sig
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
end

module Forwardable
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

class FrozenError
end

class FrozenError
end

module GC
  def garbage_collect(*_); end
end

module GC::Profiler
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

module GC
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsPackageVersion = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  USE_BUNDLER_FOR_GEMDEPS = ::T.let(nil, ::T.untyped)
end

class Gem::AvailableSet
  include ::Enumerable
  def <<(o); end

  def add(spec, source); end

  def all_specs(); end

  def each(); end

  def each_spec(); end

  def empty?(); end

  def find_all(req); end

  def inject_into_list(dep_list); end

  def match_platform!(); end

  def pick_best!(); end

  def prefetch(reqs); end

  def remote(); end

  def remote=(remote); end

  def remove_installed!(dep); end

  def set(); end

  def size(); end

  def sorted(); end

  def source_for(spec); end

  def to_request_set(development=T.unsafe(nil)); end
end

class Gem::AvailableSet::Tuple
  def source(); end

  def source=(_); end

  def spec(); end

  def spec=(_); end
end

class Gem::AvailableSet::Tuple
  def self.[](*_); end

  def self.members(); end
end

class Gem::AvailableSet
end

class Gem::BasicSpecification
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def activated?(); end

  def base_dir(); end

  def base_dir=(base_dir); end

  def contains_requirable_file?(file); end

  def datadir(); end

  def default_gem?(); end

  def extension_dir(); end

  def extension_dir=(extension_dir); end

  def extensions_dir(); end

  def full_gem_path(); end

  def full_gem_path=(full_gem_path); end

  def full_name(); end

  def full_require_paths(); end

  def gem_build_complete_path(); end

  def gem_dir(); end

  def gems_dir(); end

  def ignored=(ignored); end

  def internal_init(); end

  def lib_dirs_glob(); end

  def loaded_from(); end

  def loaded_from=(loaded_from); end

  def matches_for_glob(glob); end

  def name(); end

  def platform(); end

  def raw_require_paths(); end

  def require_paths(); end

  def source_paths(); end

  def stubbed?(); end

  def this(); end

  def to_fullpath(path); end

  def to_spec(); end
end

class Gem::BasicSpecification
  extend ::T::Sig
  def self.default_specifications_dir(); end
end

module Gem::BundlerVersionFinder
end

module Gem::BundlerVersionFinder
  extend ::T::Sig
  def self.bundler_version(); end

  def self.bundler_version_with_reason(); end

  def self.compatible?(spec); end

  def self.filter!(specs); end

  def self.missing_version_message(); end

  def self.without_filtering(); end
end

class Gem::Command
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def add_extra_args(args); end

  def add_option(*opts, &handler); end

  def arguments(); end

  def begins?(long, short); end

  def command(); end

  def defaults(); end

  def defaults=(defaults); end

  def defaults_str(); end

  def description(); end

  def execute(); end

  def get_all_gem_names(); end

  def get_all_gem_names_and_versions(); end

  def get_one_gem_name(); end

  def get_one_optional_argument(); end

  def handle_options(args); end

  def handles?(args); end

  def initialize(command, summary=T.unsafe(nil), defaults=T.unsafe(nil)); end

  def invoke(*args); end

  def invoke_with_build_args(args, build_args); end

  def merge_options(new_options); end

  def options(); end

  def program_name(); end

  def program_name=(program_name); end

  def remove_option(name); end

  def show_help(); end

  def show_lookup_failure(gem_name, version, errors, domain); end

  def summary(); end

  def summary=(summary); end

  def usage(); end

  def when_invoked(&block); end
  HELP = ::T.let(nil, ::T.untyped)
end

class Gem::Command
  def self.add_common_option(*args, &handler); end

  def self.add_specific_extra_args(cmd, args); end

  def self.build_args(); end

  def self.build_args=(value); end

  def self.common_options(); end

  def self.extra_args(); end

  def self.extra_args=(value); end

  def self.specific_extra_args(cmd); end

  def self.specific_extra_args_hash(); end
end

class Gem::CommandLineError
  extend ::T::Sig
end

module Gem::Commands
end

module Gem::Commands
  extend ::T::Sig
end

class Gem::ConfigFile
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def api_keys(); end

  def args(); end

  def backtrace(); end

  def backtrace=(backtrace); end

  def bulk_threshold(); end

  def bulk_threshold=(bulk_threshold); end

  def check_credentials_permissions(); end

  def config_file_name(); end

  def credentials_path(); end

  def disable_default_gem_server(); end

  def disable_default_gem_server=(disable_default_gem_server); end

  def each(&block); end

  def handle_arguments(arg_list); end

  def home(); end

  def home=(home); end

  def initialize(args); end

  def load_api_keys(); end

  def load_file(filename); end

  def path(); end

  def path=(path); end

  def really_verbose(); end

  def rubygems_api_key(); end

  def rubygems_api_key=(api_key); end

  def set_api_key(host, api_key); end

  def sources(); end

  def sources=(sources); end

  def ssl_ca_cert(); end

  def ssl_ca_cert=(ssl_ca_cert); end

  def ssl_client_cert(); end

  def ssl_verify_mode(); end

  def to_yaml(); end

  def unset_api_key!(); end

  def update_sources(); end

  def update_sources=(update_sources); end

  def verbose(); end

  def verbose=(verbose); end

  def write(); end
  DEFAULT_BACKTRACE = ::T.let(nil, ::T.untyped)
  DEFAULT_BULK_THRESHOLD = ::T.let(nil, ::T.untyped)
  DEFAULT_UPDATE_SOURCES = ::T.let(nil, ::T.untyped)
  DEFAULT_VERBOSITY = ::T.let(nil, ::T.untyped)
  OPERATING_SYSTEM_DEFAULTS = ::T.let(nil, ::T.untyped)
  PLATFORM_DEFAULTS = ::T.let(nil, ::T.untyped)
  SYSTEM_CONFIG_PATH = ::T.let(nil, ::T.untyped)
  SYSTEM_WIDE_CONFIG_FILE = ::T.let(nil, ::T.untyped)
end

class Gem::ConfigFile
end

class Gem::ConflictError
  def conflicts(); end

  def initialize(target, conflicts); end

  def target(); end
end

class Gem::ConflictError
  extend ::T::Sig
end

class Gem::ConsoleUI
  def initialize(); end
end

class Gem::ConsoleUI
end

module Gem::DefaultUserInteraction
  def ui(); end

  def ui=(new_ui); end

  def use_ui(new_ui, &block); end
end

module Gem::DefaultUserInteraction
  extend ::T::Sig
  def self.ui(); end

  def self.ui=(new_ui); end

  def self.use_ui(new_ui); end
end

class Gem::Dependency
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def ==(other); end

  def ===(other); end

  def =~(other); end

  def all_sources(); end

  def all_sources=(all_sources); end

  def encode_with(coder); end

  def eql?(other); end

  def groups(); end

  def groups=(groups); end

  def initialize(name, *requirements); end

  def latest_version?(); end

  def match?(obj, version=T.unsafe(nil), allow_prerelease=T.unsafe(nil)); end

  def matches_spec?(spec); end

  def matching_specs(platform_only=T.unsafe(nil)); end

  def merge(other); end

  def name(); end

  def name=(name); end

  def prerelease=(prerelease); end

  def prerelease?(); end

  def requirement(); end

  def requirements_list(); end

  def runtime?(); end

  def source(); end

  def source=(source); end

  def specific?(); end

  def to_lock(); end

  def to_spec(); end

  def to_specs(); end

  def to_yaml_properties(); end

  def type(); end
end

class Gem::Dependency
  extend ::T::Sig
end

class Gem::DependencyError
  extend ::T::Sig
end

class Gem::DependencyInstaller
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def _deprecated_gems_to_install(); end

  def add_found_dependencies(to_do, dependency_list); end

  def available_set_for(dep_or_name, version); end

  def consider_local?(); end

  def consider_remote?(); end

  def document(); end

  def errors(); end

  def find_gems_with_sources(dep, best_only=T.unsafe(nil)); end

  def find_spec_by_name_and_version(gem_name, version=T.unsafe(nil), prerelease=T.unsafe(nil)); end

  def gather_dependencies(); end

  def gems_to_install(*args, &block); end

  def in_background(what); end

  def initialize(options=T.unsafe(nil)); end

  def install(dep_or_name, version=T.unsafe(nil)); end

  def install_development_deps(); end

  def installed_gems(); end

  def resolve_dependencies(dep_or_name, version); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Gem::DependencyInstaller
  extend ::Gem::Deprecate
end

class Gem::DependencyList
  include ::Enumerable
  include ::TSort
  def add(*gemspecs); end

  def clear(); end

  def dependency_order(); end

  def development(); end

  def development=(development); end

  def each(&block); end

  def find_name(full_name); end

  def initialize(development=T.unsafe(nil)); end

  def ok?(); end

  def ok_to_remove?(full_name, check_dev=T.unsafe(nil)); end

  def remove_by_name(full_name); end

  def remove_specs_unsatisfied_by(dependencies); end

  def spec_predecessors(); end

  def specs(); end

  def tsort_each_node(&block); end

  def why_not_ok?(quick=T.unsafe(nil)); end
end

class Gem::DependencyList
  def self.from_specs(); end
end

class Gem::DependencyRemovalException
  extend ::T::Sig
end

class Gem::DependencyResolutionError
  def conflict(); end

  def conflicting_dependencies(); end

  def initialize(conflict); end
end

class Gem::DependencyResolutionError
  extend ::T::Sig
end

class Gem::Resolver
end

Gem::DependencyResolver::Conflict = Gem::Resolver::Conflict

Gem::DependencyResolver::DependencyConflict = Gem::Resolver::Conflict

module Gem::Resolver::Molinillo
end

Gem::DependencyResolver::Molinillo::SpecificationProvider = Gem::Resolver::Molinillo::SpecificationProvider

Gem::DependencyResolver::Molinillo::UI = Gem::Resolver::Molinillo::UI

module Gem::Resolver::Molinillo
end

class Gem::Resolver
end

module Gem::Deprecate
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.deprecate(name, repl, year, month); end

  def self.skip(); end

  def self.skip=(v); end

  def self.skip_during(); end
end

class Gem::DocumentError
  extend ::T::Sig
end

class Gem::EndOfYAMLException
  extend ::T::Sig
end

class Gem::ErrorReason
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class Gem::ErrorReason
  extend ::T::Sig
end

class Gem::Exception
  def source_exception(); end

  def source_exception=(source_exception); end
end

class Gem::Exception
  extend ::T::Sig
end

module Gem::Ext
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::Builder
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def build_args(); end

  def build_args=(build_args); end

  def build_error(build_dir, output, backtrace=T.unsafe(nil)); end

  def build_extension(extension, dest_path); end

  def build_extensions(); end

  def builder_for(extension); end

  def initialize(spec, build_args=T.unsafe(nil)); end

  def write_gem_make_out(output); end
  CHDIR_MONITOR = ::T.let(nil, ::T.untyped)
  CHDIR_MUTEX = ::T.let(nil, ::T.untyped)
end

class Gem::Ext::Builder
  def self.class_name(); end

  def self.make(dest_path, results); end

  def self.redirector(); end

  def self.run(command, results, command_name=T.unsafe(nil)); end
end

class Gem::Ext::CmakeBuilder
end

class Gem::Ext::CmakeBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

class Gem::Ext::ConfigureBuilder
end

class Gem::Ext::ConfigureBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

class Gem::Ext::RakeBuilder
end

class Gem::Ext::RakeBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

module Gem::Ext
  extend ::T::Sig
end

class Gem::FilePermissionError
  def directory(); end

  def initialize(directory); end
end

class Gem::FilePermissionError
  extend ::T::Sig
end

class Gem::FormatException
  def file_path(); end

  def file_path=(file_path); end
end

class Gem::FormatException
  extend ::T::Sig
end

class Gem::GemNotFoundException
  extend ::T::Sig
end

class Gem::GemNotInHomeException
  def spec(); end

  def spec=(spec); end
end

class Gem::GemNotInHomeException
  extend ::T::Sig
end

class Gem::ImpossibleDependenciesError
  def build_message(); end

  def conflicts(); end

  def dependency(); end

  def initialize(request, conflicts); end

  def request(); end
end

class Gem::ImpossibleDependenciesError
  extend ::T::Sig
end

class Gem::InstallError
  extend ::T::Sig
end

class Gem::Installer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def app_script_text(bin_file_name); end

  def bin_dir(); end

  def build_extensions(); end

  def build_root(); end

  def check_executable_overwrite(filename); end

  def check_that_user_bin_dir_is_in_path(); end

  def default_spec_file(); end

  def dir(); end

  def ensure_dependencies_met(); end

  def ensure_dependency(spec, dependency); end

  def ensure_loadable_spec(); end

  def ensure_required_ruby_version_met(); end

  def ensure_required_rubygems_version_met(); end

  def extension_build_error(build_dir, output, backtrace=T.unsafe(nil)); end

  def extract_bin(); end

  def extract_files(); end

  def formatted_program_filename(filename); end

  def gem(); end

  def gem_dir(); end

  def gem_home(); end

  def generate_bin(); end

  def generate_bin_script(filename, bindir); end

  def generate_bin_symlink(filename, bindir); end

  def generate_windows_script(filename, bindir); end

  def initialize(package, options=T.unsafe(nil)); end

  def install(); end

  def installation_satisfies_dependency?(dependency); end

  def installed_specs(); end

  def options(); end

  def pre_install_checks(); end

  def process_options(); end

  def run_post_build_hooks(); end

  def run_post_install_hooks(); end

  def run_pre_install_hooks(); end

  def shebang(bin_file_name); end

  def spec(); end

  def spec_file(); end

  def unpack(directory); end

  def verify_gem_home(unpack=T.unsafe(nil)); end

  def verify_spec_name(); end

  def windows_stub_script(bindir, bin_file_name); end

  def write_build_info_file(); end

  def write_cache_file(); end

  def write_default_spec(); end

  def write_spec(); end
  ENV_PATHS = ::T.let(nil, ::T.untyped)
end

class Gem::Installer
  def self.at(path, options=T.unsafe(nil)); end

  def self.exec_format(); end

  def self.exec_format=(exec_format); end

  def self.for_spec(spec, options=T.unsafe(nil)); end

  def self.install_lock(); end

  def self.path_warning(); end

  def self.path_warning=(path_warning); end
end

class Gem::InvalidSpecificationException
  extend ::T::Sig
end

class Gem::Licenses
  IDENTIFIERS = ::T.let(nil, ::T.untyped)
  NONSTANDARD = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::Licenses
  extend ::Gem::Text
  def self.match?(license); end

  def self.suggestions(license); end
end

class Gem::List
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def each(); end

  def initialize(value=T.unsafe(nil), tail=T.unsafe(nil)); end

  def prepend(value); end

  def tail(); end

  def tail=(tail); end

  def to_a(); end

  def value(); end

  def value=(value); end
end

class Gem::List
  extend ::T::Sig
  def self.prepend(list, value); end
end

class Gem::LoadError
  def name(); end

  def name=(name); end

  def requirement(); end

  def requirement=(requirement); end
end

class Gem::LoadError
  extend ::T::Sig
end

class Gem::MissingSpecError
  def initialize(name, requirement); end
end

class Gem::MissingSpecError
  extend ::T::Sig
end

class Gem::MissingSpecVersionError
  def initialize(name, requirement, specs); end

  def specs(); end
end

class Gem::MissingSpecVersionError
  extend ::T::Sig
end

class Gem::NameTuple
  include ::Comparable
  def ==(other); end

  def eql?(other); end

  def full_name(); end

  def initialize(name, version, platform=T.unsafe(nil)); end

  def match_platform?(); end

  def name(); end

  def platform(); end

  def prerelease?(); end

  def spec_name(); end

  def to_a(); end
end

class Gem::NameTuple
  def self.from_list(list); end

  def self.null(); end

  def self.to_basic(list); end
end

class Gem::OperationNotSupportedError
  extend ::T::Sig
end

class Gem::Package
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def add_checksums(tar); end

  def add_contents(tar); end

  def add_files(tar); end

  def add_metadata(tar); end

  def build(skip_validation=T.unsafe(nil)); end

  def build_time(); end

  def build_time=(build_time); end

  def checksums(); end

  def contents(); end

  def copy_to(path); end

  def digest(entry); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def extract_tar_gz(io, destination_dir, pattern=T.unsafe(nil)); end

  def files(); end

  def gzip_to(io); end

  def initialize(gem, security_policy); end

  def install_location(filename, destination_dir); end

  def load_spec(entry); end

  def open_tar_gz(io); end

  def read_checksums(gem); end

  def security_policy(); end

  def security_policy=(security_policy); end

  def setup_signer(); end

  def spec(); end

  def spec=(spec); end

  def verify(); end

  def verify_checksums(digests, checksums); end

  def verify_entry(entry); end

  def verify_files(gem); end

  def verify_gz(entry); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::Error
end

class Gem::Package::Error
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::FormatError
  def initialize(message, source=T.unsafe(nil)); end

  def path(); end
end

class Gem::Package::FormatError
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::NonSeekableIO
end

class Gem::Package::NonSeekableIO
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::PathError
  def initialize(destination, destination_dir); end
end

class Gem::Package::PathError
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end
end

class Gem::Package::TarInvalidError
end

class Gem::Package::TarInvalidError
end

class Gem::Package::TarReader
  include ::Enumerable
  def close(); end

  def each(); end

  def each_entry(); end

  def initialize(io); end

  def rewind(); end

  def seek(name); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(len=T.unsafe(nil)); end

  def rewind(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader::UnexpectedEOF
end

class Gem::Package::TarReader::UnexpectedEOF
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def add_file(name, mode); end

  def add_file_digest(name, mode, digest_algorithms); end

  def add_file_signed(name, mode, signer); end

  def add_file_simple(name, mode, size); end

  def add_symlink(name, target, mode); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def flush(); end

  def initialize(io); end

  def mkdir(name, mode); end

  def mtime(); end

  def mtime=(mtime); end

  def split_name(name); end
end

class Gem::Package::TarWriter::BoundedStream
  def initialize(io, limit); end

  def limit(); end

  def write(data); end

  def written(); end
end

class Gem::Package::TarWriter::BoundedStream
end

class Gem::Package::TarWriter::FileOverflow
end

class Gem::Package::TarWriter::FileOverflow
end

class Gem::Package::TarWriter::RestrictedStream
  def initialize(io); end

  def write(data); end
end

class Gem::Package::TarWriter::RestrictedStream
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package::TooLongFileName
end

class Gem::Package::TooLongFileName
end

class Gem::Package
  def self.build(spec, skip_validation=T.unsafe(nil)); end

  def self.new(gem, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::PathSupport
  extend ::T::Sig
end

class Gem::Platform
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def ==(other); end

  def ===(other); end

  def =~(other); end

  def cpu(); end

  def cpu=(cpu); end

  def eql?(other); end

  def initialize(arch); end

  def os(); end

  def os=(os); end

  def to_a(); end

  def version=(version); end
  JAVA = ::T.let(nil, ::T.untyped)
  MINGW = ::T.let(nil, ::T.untyped)
  MSWIN = ::T.let(nil, ::T.untyped)
  MSWIN64 = ::T.let(nil, ::T.untyped)
  X64_MINGW = ::T.let(nil, ::T.untyped)
end

class Gem::Platform
  extend ::T::Sig
  def self.installable?(spec); end

  def self.local(); end

  def self.match(platform); end

  def self.new(arch); end
end

class Gem::PlatformMismatch
  def add_platform(platform); end

  def initialize(name, version); end

  def name(); end

  def platforms(); end

  def wordy(); end
end

class Gem::PlatformMismatch
  extend ::T::Sig
end

class Gem::RemoteError
  extend ::T::Sig
end

class Gem::RemoteFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def api_endpoint(uri); end

  def cache_update_path(uri, path=T.unsafe(nil), update=T.unsafe(nil)); end

  def close_all(); end

  def correct_for_windows_path(path); end

  def download(spec, source_uri, install_dir=T.unsafe(nil)); end

  def download_to_cache(dependency); end

  def fetch_file(uri, *_); end

  def fetch_http(uri, last_modified=T.unsafe(nil), head=T.unsafe(nil), depth=T.unsafe(nil)); end

  def fetch_https(uri, last_modified=T.unsafe(nil), head=T.unsafe(nil), depth=T.unsafe(nil)); end

  def fetch_path(uri, mtime=T.unsafe(nil), head=T.unsafe(nil)); end

  def fetch_s3(uri, mtime=T.unsafe(nil), head=T.unsafe(nil)); end

  def fetch_size(uri); end

  def headers(); end

  def headers=(headers); end

  def https?(uri); end

  def initialize(proxy=T.unsafe(nil), dns=T.unsafe(nil), headers=T.unsafe(nil)); end

  def request(uri, request_class, last_modified=T.unsafe(nil)); end

  def s3_expiration(); end

  def sign_s3_url(uri, expiration=T.unsafe(nil)); end
  BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
end

class Gem::RemoteFetcher
  def self.fetcher(); end
end

class Gem::RemoteInstallationCancelled
  extend ::T::Sig
end

class Gem::RemoteInstallationSkipped
  extend ::T::Sig
end

class Gem::RemoteSourceException
  extend ::T::Sig
end

class Gem::Request
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def cert_files(); end

  def connection_for(uri); end

  def fetch(); end

  def initialize(uri, request_class, last_modified, pool); end

  def perform_request(request); end

  def proxy_uri(); end

  def reset(connection); end

  def user_agent(); end
end

class Gem::Request::ConnectionPools
  def close_all(); end

  def initialize(proxy_uri, cert_files); end

  def pool_for(uri); end
end

class Gem::Request::ConnectionPools
  def self.client(); end

  def self.client=(client); end
end

class Gem::Request::HTTPPool
  def cert_files(); end

  def checkin(connection); end

  def close_all(); end

  def initialize(http_args, cert_files, proxy_uri); end

  def proxy_uri(); end
end

class Gem::Request::HTTPPool
end

class Gem::Request::HTTPSPool
end

class Gem::Request::HTTPSPool
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  def self.configure_connection_for_https(connection, cert_files); end

  def self.create_with_proxy(uri, request_class, last_modified, proxy); end

  def self.get_cert_files(); end

  def self.get_proxy_from_env(scheme=T.unsafe(nil)); end

  def self.proxy_uri(proxy); end

  def self.verify_certificate(store_context); end

  def self.verify_certificate_message(error_number, cert); end
end

class Gem::RequestSet
  include ::TSort
  def always_install(); end

  def always_install=(always_install); end

  def dependencies(); end

  def development(); end

  def development=(development); end

  def development_shallow(); end

  def development_shallow=(development_shallow); end

  def errors(); end

  def gem(name, *reqs); end

  def git_set(); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def import(deps); end

  def initialize(*deps); end

  def install(options, &block); end

  def install_dir(); end

  def install_from_gemdeps(options, &block); end

  def install_into(dir, force=T.unsafe(nil), options=T.unsafe(nil)); end

  def load_gemdeps(path, without_groups=T.unsafe(nil), installing=T.unsafe(nil)); end

  def prerelease(); end

  def prerelease=(prerelease); end

  def remote(); end

  def remote=(remote); end

  def resolve(set=T.unsafe(nil)); end

  def resolve_current(); end

  def resolver(); end

  def sets(); end

  def soft_missing(); end

  def soft_missing=(soft_missing); end

  def sorted_requests(); end

  def source_set(); end

  def specs(); end

  def specs_in(dir); end

  def tsort_each_node(&block); end

  def vendor_set(); end
end

Gem::RequestSet::GemDepedencyAPI = Gem::RequestSet::GemDependencyAPI

class Gem::RequestSet::GemDependencyAPI
  def dependencies(); end

  def find_gemspec(name, path); end

  def gem(name, *requirements); end

  def gem_deps_file(); end

  def gem_git_reference(options); end

  def gemspec(options=T.unsafe(nil)); end

  def git(repository); end

  def git_set(); end

  def git_source(name, &callback); end

  def group(*groups); end

  def initialize(set, path); end

  def installing=(installing); end

  def load(); end

  def platform(*platforms); end

  def platforms(*platforms); end

  def requires(); end

  def ruby(version, options=T.unsafe(nil)); end

  def source(url); end

  def vendor_set(); end

  def without_groups(); end

  def without_groups=(without_groups); end
  ENGINE_MAP = ::T.let(nil, ::T.untyped)
  PLATFORM_MAP = ::T.let(nil, ::T.untyped)
  VERSION_MAP = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Gem::RequestSet::GemDependencyAPI
end

class Gem::RequestSet::Lockfile
  def add_DEPENDENCIES(out); end

  def add_GEM(out, spec_groups); end

  def add_GIT(out, git_requests); end

  def add_PATH(out, path_requests); end

  def add_PLATFORMS(out); end

  def initialize(request_set, gem_deps_file, dependencies); end

  def platforms(); end

  def relative_path_from(dest, base); end

  def spec_groups(); end

  def write(); end
end

class Gem::RequestSet::Lockfile::ParseError
  def column(); end

  def initialize(message, column, line, path); end

  def line(); end

  def path(); end
end

class Gem::RequestSet::Lockfile::ParseError
end

class Gem::RequestSet::Lockfile::Parser
  def get(expected_types=T.unsafe(nil), expected_value=T.unsafe(nil)); end

  def initialize(tokenizer, set, platforms, filename=T.unsafe(nil)); end

  def parse(); end

  def parse_DEPENDENCIES(); end

  def parse_GEM(); end

  def parse_GIT(); end

  def parse_PATH(); end

  def parse_PLATFORMS(); end

  def parse_dependency(name, op); end
end

class Gem::RequestSet::Lockfile::Parser
end

class Gem::RequestSet::Lockfile::Tokenizer
  def empty?(); end

  def initialize(input, filename=T.unsafe(nil), line=T.unsafe(nil), pos=T.unsafe(nil)); end

  def make_parser(set, platforms); end

  def next_token(); end

  def peek(); end

  def shift(); end

  def skip(type); end

  def to_a(); end

  def token_pos(byte_offset); end

  def unshift(token); end
  EOF = ::T.let(nil, ::T.untyped)
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def column(); end

  def column=(_); end

  def line(); end

  def line=(_); end

  def type(); end

  def type=(_); end

  def value(); end

  def value=(_); end
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def self.[](*_); end

  def self.members(); end
end

class Gem::RequestSet::Lockfile::Tokenizer
  def self.from_file(file); end
end

class Gem::RequestSet::Lockfile
  def self.build(request_set, gem_deps_file, dependencies=T.unsafe(nil)); end

  def self.requests_to_deps(requests); end
end

class Gem::RequestSet
end

class Gem::Requirement
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def ==(other); end

  def ===(version); end

  def =~(version); end

  def as_list(); end

  def concat(new); end

  def encode_with(coder); end

  def exact?(); end

  def for_lockfile(); end

  def init_with(coder); end

  def initialize(*requirements); end

  def marshal_dump(); end

  def marshal_load(array); end

  def none?(); end

  def prerelease?(); end

  def requirements(); end

  def satisfied_by?(version); end

  def specific?(); end

  def to_yaml_properties(); end

  def yaml_initialize(tag, vals); end
  DefaultRequirement = ::T.let(nil, ::T.untyped)
end

class Gem::Requirement::BadRequirementError
  extend ::T::Sig
end

class Gem::Requirement
  extend ::T::Sig
  def self.create(*inputs); end

  def self.default(); end

  def self.parse(obj); end

  def self.source_set(); end
end

class Gem::Resolver
  include ::Gem::Resolver::Molinillo::UI
  include ::Gem::Resolver::Molinillo::SpecificationProvider
  def activation_request(dep, possible); end

  def development(); end

  def development=(development); end

  def development_shallow(); end

  def development_shallow=(development_shallow); end

  def explain(stage, *data); end

  def explain_list(stage); end

  def find_possible(dependency); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def initialize(needed, set=T.unsafe(nil)); end

  def missing(); end

  def requests(s, act, reqs=T.unsafe(nil)); end

  def resolve(); end

  def select_local_platforms(specs); end

  def skip_gems(); end

  def skip_gems=(skip_gems); end

  def soft_missing(); end

  def soft_missing=(soft_missing); end

  def stats(); end
  DEBUG_RESOLVER = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::APISet
  def dep_uri(); end

  def initialize(dep_uri=T.unsafe(nil)); end

  def prefetch_now(); end

  def source(); end

  def uri(); end

  def versions(name); end
end

class Gem::Resolver::APISet
end

class Gem::Resolver::APISpecification
  def ==(other); end

  def initialize(set, api_data); end
end

class Gem::Resolver::APISpecification
end

class Gem::Resolver::ActivationRequest
  def ==(other); end

  def development?(); end

  def download(path); end

  def full_name(); end

  def full_spec(); end

  def initialize(spec, request, others_possible=T.unsafe(nil)); end

  def installed?(); end

  def name(); end

  def others_possible?(); end

  def parent(); end

  def request(); end

  def spec(); end
end

class Gem::Resolver::ActivationRequest
end

class Gem::Resolver::BestSet
  def initialize(sources=T.unsafe(nil)); end

  def pick_sets(); end

  def replace_failed_api_set(error); end
end

class Gem::Resolver::BestSet
end

class Gem::Resolver::ComposedSet
  def initialize(*sets); end

  def prerelease=(allow_prerelease); end

  def remote=(remote); end

  def sets(); end
end

class Gem::Resolver::ComposedSet
end

class Gem::Resolver::Conflict
  def ==(other); end

  def activated(); end

  def conflicting_dependencies(); end

  def dependency(); end

  def explain(); end

  def explanation(); end

  def failed_dep(); end

  def for_spec?(spec); end

  def initialize(dependency, activated, failed_dep=T.unsafe(nil)); end

  def request_path(current); end

  def requester(); end
end

class Gem::Resolver::Conflict
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::DependencyRequest
  def ==(other); end

  def dependency(); end

  def development?(); end

  def explicit?(); end

  def implicit?(); end

  def initialize(dependency, requester); end

  def match?(spec, allow_prerelease=T.unsafe(nil)); end

  def matches_spec?(spec); end

  def name(); end

  def request_context(); end

  def requester(); end

  def requirement(); end

  def type(); end
end

class Gem::Resolver::DependencyRequest
end

class Gem::Resolver::GitSet
  def add_git_gem(name, repository, reference, submodules); end

  def add_git_spec(name, version, repository, reference, submodules); end

  def need_submodules(); end

  def repositories(); end

  def root_dir(); end

  def root_dir=(root_dir); end

  def specs(); end
end

class Gem::Resolver::GitSet
end

class Gem::Resolver::GitSpecification
  def ==(other); end

  def add_dependency(dependency); end
end

class Gem::Resolver::GitSpecification
end

class Gem::Resolver::IndexSet
  def initialize(source=T.unsafe(nil)); end
end

class Gem::Resolver::IndexSet
end

class Gem::Resolver::IndexSpecification
  def initialize(set, name, version, source, platform); end
end

class Gem::Resolver::IndexSpecification
end

class Gem::Resolver::InstalledSpecification
  def ==(other); end
end

class Gem::Resolver::InstalledSpecification
end

class Gem::Resolver::InstallerSet
  def add_always_install(dependency); end

  def add_local(dep_name, spec, source); end

  def always_install(); end

  def consider_local?(); end

  def consider_remote?(); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def ignore_installed(); end

  def ignore_installed=(ignore_installed); end

  def initialize(domain); end

  def load_spec(name, ver, platform, source); end

  def local?(dep_name); end

  def prerelease=(allow_prerelease); end

  def remote=(remote); end

  def remote_set(); end
end

class Gem::Resolver::InstallerSet
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LockSet
  def add(name, version, platform); end

  def initialize(sources); end

  def load_spec(name, version, platform, source); end

  def specs(); end
end

class Gem::Resolver::LockSet
end

class Gem::Resolver::LockSpecification
  def add_dependency(dependency); end

  def initialize(set, name, version, sources, platform); end

  def sources(); end
end

class Gem::Resolver::LockSpecification
end

module Gem::Resolver::Molinillo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::Molinillo::CircularDependencyError
  def dependencies(); end

  def initialize(nodes); end
end

class Gem::Resolver::Molinillo::CircularDependencyError
end

module Gem::Resolver::Molinillo::Delegates
end

module Gem::Resolver::Molinillo::Delegates::ResolutionState
  def activated(); end

  def conflicts(); end

  def depth(); end

  def name(); end

  def possibilities(); end

  def requirement(); end

  def requirements(); end
end

module Gem::Resolver::Molinillo::Delegates::ResolutionState
  extend ::T::Sig
end

module Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  extend ::T::Sig
end

module Gem::Resolver::Molinillo::Delegates
  extend ::T::Sig
end

class Gem::Resolver::Molinillo::DependencyGraph
  include ::Enumerable
  include ::TSort
  def ==(other); end

  def add_child_vertex(name, payload, parent_names, requirement); end

  def add_edge(origin, destination, requirement); end

  def add_vertex(name, payload, root=T.unsafe(nil)); end

  def delete_edge(edge); end

  def detach_vertex_named(name); end

  def each(); end

  def log(); end

  def rewind_to(tag); end

  def root_vertex_named(name); end

  def set_payload(name, payload); end

  def tag(tag); end

  def to_dot(options=T.unsafe(nil)); end

  def tsort_each_child(vertex, &block); end

  def vertex_named(name); end

  def vertices(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Action
  def down(graph); end

  def next(); end

  def next=(_); end

  def previous(); end

  def previous=(previous); end

  def up(graph); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Action
  def self.action_name(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::AddEdgeNoCircular
  def destination(); end

  def initialize(origin, destination, requirement); end

  def make_edge(graph); end

  def origin(); end

  def requirement(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::AddEdgeNoCircular
end

class Gem::Resolver::Molinillo::DependencyGraph::AddVertex
  def initialize(name, payload, root); end

  def name(); end

  def payload(); end

  def root(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::AddVertex
end

class Gem::Resolver::Molinillo::DependencyGraph::DeleteEdge
  def destination_name(); end

  def initialize(origin_name, destination_name, requirement); end

  def make_edge(graph); end

  def origin_name(); end

  def requirement(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::DeleteEdge
end

class Gem::Resolver::Molinillo::DependencyGraph::DetachVertexNamed
  def initialize(name); end

  def name(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::DetachVertexNamed
end

class Gem::Resolver::Molinillo::DependencyGraph::Edge
  def destination(); end

  def destination=(_); end

  def origin(); end

  def origin=(_); end

  def requirement(); end

  def requirement=(_); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Edge
  def self.[](*_); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Resolver::Molinillo::DependencyGraph::SetPayload
  def initialize(name, payload); end

  def name(); end

  def payload(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::SetPayload
end

class Gem::Resolver::Molinillo::DependencyGraph::Tag
  def down(_graph); end

  def initialize(tag); end

  def tag(); end

  def up(_graph); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Tag
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
  def ==(other); end

  def ancestor?(other); end

  def descendent?(other); end

  def eql?(other); end

  def explicit_requirements(); end

  def incoming_edges(); end

  def incoming_edges=(incoming_edges); end

  def initialize(name, payload); end

  def is_reachable_from?(other); end

  def name(); end

  def name=(name); end

  def outgoing_edges(); end

  def outgoing_edges=(outgoing_edges); end

  def path_to?(other); end

  def payload(); end

  def payload=(payload); end

  def predecessors(); end

  def recursive_predecessors(); end

  def recursive_successors(); end

  def requirements(); end

  def root(); end

  def root=(root); end

  def root?(); end

  def shallow_eql?(other); end

  def successors(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
end

class Gem::Resolver::Molinillo::DependencyGraph
  def self.tsort(vertices); end
end

class Gem::Resolver::Molinillo::DependencyState
  def pop_possibility_state(); end
end

class Gem::Resolver::Molinillo::DependencyState
end

class Gem::Resolver::Molinillo::NoSuchDependencyError
  def dependency(); end

  def dependency=(dependency); end

  def initialize(dependency, required_by=T.unsafe(nil)); end

  def required_by(); end

  def required_by=(required_by); end
end

class Gem::Resolver::Molinillo::NoSuchDependencyError
end

class Gem::Resolver::Molinillo::PossibilityState
end

class Gem::Resolver::Molinillo::PossibilityState
end

class Gem::Resolver::Molinillo::ResolutionState
  def activated(); end

  def activated=(_); end

  def conflicts(); end

  def conflicts=(_); end

  def depth(); end

  def depth=(_); end

  def name(); end

  def name=(_); end

  def possibilities(); end

  def possibilities=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirements(); end

  def requirements=(_); end
end

class Gem::Resolver::Molinillo::ResolutionState
  def self.[](*_); end

  def self.empty(); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver
  def initialize(specification_provider, resolver_ui); end

  def resolve(requested, base=T.unsafe(nil)); end

  def resolver_ui(); end

  def specification_provider(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution
  include ::Gem::Resolver::Molinillo::Delegates::ResolutionState
  include ::Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def base(); end

  def initialize(specification_provider, resolver_ui, requested, base); end

  def iteration_rate=(iteration_rate); end

  def original_requested(); end

  def resolve(); end

  def resolver_ui(); end

  def specification_provider(); end

  def started_at=(started_at); end

  def states=(states); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def activated_by_name(); end

  def activated_by_name=(_); end

  def existing(); end

  def existing=(_); end

  def locked_requirement(); end

  def locked_requirement=(_); end

  def possibility(); end

  def possibility=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements(); end

  def requirements=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def self.[](*_); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution
end

class Gem::Resolver::Molinillo::Resolver
end

class Gem::Resolver::Molinillo::ResolverError
end

class Gem::Resolver::Molinillo::ResolverError
end

module Gem::Resolver::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Resolver::Molinillo::SpecificationProvider
  extend ::T::Sig
end

module Gem::Resolver::Molinillo::UI
  def after_resolution(); end

  def before_resolution(); end

  def debug(depth=T.unsafe(nil)); end

  def debug?(); end

  def indicate_progress(); end

  def output(); end

  def progress_rate(); end
end

module Gem::Resolver::Molinillo::UI
  extend ::T::Sig
end

class Gem::Resolver::Molinillo::VersionConflict
  def conflicts(); end

  def initialize(conflicts); end
end

class Gem::Resolver::Molinillo::VersionConflict
end

module Gem::Resolver::Molinillo
  extend ::T::Sig
end

class Gem::Resolver::RequirementList
  include ::Enumerable
  def add(req); end

  def each(); end

  def empty?(); end

  def next5(); end

  def remove(); end

  def size(); end
end

class Gem::Resolver::RequirementList
end

class Gem::Resolver::Set
  def errors(); end

  def errors=(errors); end

  def find_all(req); end

  def prefetch(reqs); end

  def prerelease(); end

  def prerelease=(prerelease); end

  def remote(); end

  def remote=(remote); end

  def remote?(); end
end

class Gem::Resolver::Set
end

class Gem::Resolver::SourceSet
  def add_source_gem(name, source); end
end

class Gem::Resolver::SourceSet
end

class Gem::Resolver::SpecSpecification
  def initialize(set, spec, source=T.unsafe(nil)); end
end

class Gem::Resolver::SpecSpecification
end

class Gem::Resolver::Specification
  def dependencies(); end

  def fetch_development_dependencies(); end

  def full_name(); end

  def install(options=T.unsafe(nil)); end

  def installable_platform?(); end

  def local?(); end

  def name(); end

  def platform(); end

  def set(); end

  def source(); end

  def spec(); end
end

class Gem::Resolver::Specification
end

class Gem::Resolver::Stats
  def backtracking!(); end

  def display(); end

  def iteration!(); end

  def record_depth(stack); end

  def record_requirements(reqs); end

  def requirement!(); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::Stats
end

class Gem::Resolver::VendorSet
  def add_vendor_gem(name, directory); end

  def load_spec(name, version, platform, source); end

  def specs(); end
end

class Gem::Resolver::VendorSet
end

class Gem::Resolver::VendorSpecification
  def ==(other); end
end

class Gem::Resolver::VendorSpecification
end

class Gem::Resolver
  def self.compose_sets(*sets); end

  def self.for_current_gems(needed); end
end

class Gem::RubyVersionMismatch
  extend ::T::Sig
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

module Gem::Security
  AlmostNoSecurity = ::T.let(nil, ::T.untyped)
  DIGEST_NAME = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  HighSecurity = ::T.let(nil, ::T.untyped)
  KEY_CIPHER = ::T.let(nil, ::T.untyped)
  KEY_LENGTH = ::T.let(nil, ::T.untyped)
  LowSecurity = ::T.let(nil, ::T.untyped)
  MediumSecurity = ::T.let(nil, ::T.untyped)
  NoSecurity = ::T.let(nil, ::T.untyped)
  ONE_DAY = ::T.let(nil, ::T.untyped)
  ONE_YEAR = ::T.let(nil, ::T.untyped)
  Policies = ::T.let(nil, ::T.untyped)
  SigningPolicy = ::T.let(nil, ::T.untyped)
end

class Gem::Security::DIGEST_ALGORITHM
  def initialize(data=T.unsafe(nil)); end
end

class Gem::Security::DIGEST_ALGORITHM
  def self.digest(data); end

  def self.hexdigest(data); end
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

class Gem::Security::KEY_ALGORITHM
  def d(); end

  def d=(d); end

  def dmp1(); end

  def dmp1=(dmp1); end

  def dmq1(); end

  def dmq1=(dmq1); end

  def e(); end

  def e=(e); end

  def export(*_); end

  def initialize(*_); end

  def iqmp(); end

  def iqmp=(iqmp); end

  def n(); end

  def n=(n); end

  def p(); end

  def p=(p); end

  def params(); end

  def private?(); end

  def private_decrypt(*_); end

  def private_encrypt(*_); end

  def public?(); end

  def public_decrypt(*_); end

  def public_encrypt(*_); end

  def public_key(); end

  def q(); end

  def q=(q); end

  def set_crt_params(_, _1, _2); end

  def set_factors(_, _1); end

  def set_key(_, _1, _2); end

  def sign_pss(*_); end

  def to_der(); end

  def to_pem(*_); end

  def to_s(*_); end

  def to_text(); end

  def verify_pss(*_); end
  NO_PADDING = ::T.let(nil, ::T.untyped)
  PKCS1_OAEP_PADDING = ::T.let(nil, ::T.untyped)
  PKCS1_PADDING = ::T.let(nil, ::T.untyped)
  SSLV23_PADDING = ::T.let(nil, ::T.untyped)
end

class Gem::Security::KEY_ALGORITHM
  def self.generate(*_); end
end

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def re_sign_key(); end

  def sign(data); end
end

class Gem::Security::Signer
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
  DEFAULT_PERMISSIONS = ::T.let(nil, ::T.untyped)
end

class Gem::Security::TrustDir
end

module Gem::Security
  extend ::T::Sig
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SilentUI
  def initialize(); end
end

class Gem::SilentUI
end

class Gem::Source
  include ::Comparable
  def ==(other); end

  def api_uri(); end

  def cache_dir(uri); end

  def dependency_resolver_set(); end

  def download(spec, dir=T.unsafe(nil)); end

  def eql?(other); end

  def fetch_spec(name_tuple); end

  def initialize(uri); end

  def load_specs(type); end

  def update_cache?(); end

  def uri(); end
  FILES = ::T.let(nil, ::T.untyped)
end

class Gem::Source::Git
  def base_dir(); end

  def cache(); end

  def dir_shortref(); end

  def download(full_spec, path); end

  def initialize(name, repository, reference, submodules=T.unsafe(nil)); end

  def install_dir(); end

  def name(); end

  def need_submodules(); end

  def reference(); end

  def remote(); end

  def remote=(remote); end

  def repo_cache_dir(); end

  def repository(); end

  def rev_parse(); end

  def root_dir(); end

  def root_dir=(root_dir); end

  def specs(); end

  def uri_hash(); end
end

class Gem::Source::Git
end

class Gem::Source::Installed
  def download(spec, path); end

  def initialize(); end
end

class Gem::Source::Installed
end

class Gem::Source::Local
  def download(spec, cache_dir=T.unsafe(nil)); end

  def fetch_spec(name); end

  def find_gem(gem_name, version=T.unsafe(nil), prerelease=T.unsafe(nil)); end

  def initialize(); end
end

class Gem::Source::Local
end

class Gem::Source::Lock
  def initialize(source); end

  def wrapped(); end
end

class Gem::Source::Lock
end

class Gem::Source::SpecificFile
  def fetch_spec(name); end

  def initialize(file); end

  def load_specs(*a); end

  def path(); end

  def spec(); end
end

class Gem::Source::SpecificFile
end

class Gem::Source::Vendor
  def initialize(path); end
end

class Gem::Source::Vendor
end

class Gem::Source
end

class Gem::SourceFetchProblem
  def error(); end

  def exception(); end

  def initialize(source, error); end

  def source(); end

  def wordy(); end
end

class Gem::SourceFetchProblem
  extend ::T::Sig
end

class Gem::SourceList
  include ::Enumerable
  def <<(obj); end

  def ==(other); end

  def clear(); end

  def delete(source); end

  def each(); end

  def each_source(&b); end

  def empty?(); end

  def first(); end

  def include?(other); end

  def replace(other); end

  def sources(); end

  def to_a(); end

  def to_ary(); end
end

class Gem::SourceList
  def self.from(ary); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::SpecificGemNotFoundException
  def errors(); end

  def initialize(name, version, errors=T.unsafe(nil)); end

  def name(); end
end

class Gem::SpecificGemNotFoundException
  extend ::T::Sig
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def ==(other); end

  def _dump(limit); end

  def abbreviate(); end

  def activate(); end

  def activate_dependencies(); end

  def activated(); end

  def activated=(activated); end

  def add_bindir(executables); end

  def add_dependency(gem, *requirements); end

  def add_development_dependency(gem, *requirements); end

  def add_runtime_dependency(gem, *requirements); end

  def add_self_to_load_path(); end

  def author(); end

  def author=(o); end

  def authors(); end

  def authors=(value); end

  def autorequire(); end

  def autorequire=(autorequire); end

  def bin_dir(); end

  def bin_file(name); end

  def bindir(); end

  def bindir=(bindir); end

  def build_args(); end

  def build_extensions(); end

  def build_info_dir(); end

  def build_info_file(); end

  def bundled_gem_in_old_ruby?(); end

  def cache_dir(); end

  def cache_file(); end

  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def conficts_when_loaded_with?(list_of_specs); end

  def conflicts(); end

  def date(); end

  def date=(date); end

  def default_executable(); end

  def default_executable=(default_executable); end

  def default_value(name); end

  def dependencies(); end

  def dependent_gems(); end

  def dependent_specs(); end

  def description(); end

  def description=(str); end

  def development_dependencies(); end

  def doc_dir(type=T.unsafe(nil)); end

  def email(); end

  def email=(email); end

  def encode_with(coder); end

  def eql?(other); end

  def executable(); end

  def executable=(o); end

  def executables(); end

  def executables=(value); end

  def extensions(); end

  def extensions=(extensions); end

  def extra_rdoc_files(); end

  def extra_rdoc_files=(files); end

  def file_name(); end

  def files(); end

  def files=(files); end

  def for_cache(); end

  def git_version(); end

  def groups(); end

  def has_conflicts?(); end

  def has_rdoc(); end

  def has_rdoc=(ignored); end

  def has_rdoc?(); end

  def has_test_suite?(); end

  def has_unit_tests?(); end

  def homepage(); end

  def homepage=(homepage); end

  def init_with(coder); end

  def initialize(name=T.unsafe(nil), version=T.unsafe(nil)); end

  def installed_by_version(); end

  def installed_by_version=(version); end

  def lib_files(); end

  def license(); end

  def license=(o); end

  def licenses(); end

  def licenses=(licenses); end

  def load_paths(); end

  def location(); end

  def location=(location); end

  def mark_version(); end

  def metadata(); end

  def metadata=(metadata); end

  def method_missing(sym, *a, &b); end

  def missing_extensions?(); end

  def name=(name); end

  def name_tuple(); end

  def nondevelopment_dependencies(); end

  def normalize(); end

  def original_name(); end

  def original_platform(); end

  def original_platform=(original_platform); end

  def platform=(platform); end

  def post_install_message(); end

  def post_install_message=(post_install_message); end

  def raise_if_conflicts(); end

  def rdoc_options(); end

  def rdoc_options=(options); end

  def relative_loaded_from(); end

  def relative_loaded_from=(relative_loaded_from); end

  def remote(); end

  def remote=(remote); end

  def require_path(); end

  def require_path=(path); end

  def require_paths=(val); end

  def required_ruby_version(); end

  def required_ruby_version=(req); end

  def required_rubygems_version(); end

  def required_rubygems_version=(req); end

  def requirements(); end

  def requirements=(req); end

  def reset_nil_attributes_to_default(); end

  def rg_extension_dir(); end

  def rg_full_gem_path(); end

  def rg_loaded_from(); end

  def ri_dir(); end

  def rubyforge_project(); end

  def rubyforge_project=(rubyforge_project); end

  def rubygems_version(); end

  def rubygems_version=(rubygems_version); end

  def runtime_dependencies(); end

  def sanitize(); end

  def sanitize_string(string); end

  def satisfies_requirement?(dependency); end

  def signing_key(); end

  def signing_key=(signing_key); end

  def sort_obj(); end

  def source(); end

  def source=(source); end

  def spec_dir(); end

  def spec_file(); end

  def spec_name(); end

  def specification_version(); end

  def specification_version=(specification_version); end

  def summary(); end

  def summary=(str); end

  def test_file(); end

  def test_file=(file); end

  def test_files(); end

  def test_files=(files); end

  def to_gemfile(path=T.unsafe(nil)); end

  def to_ruby(); end

  def to_ruby_for_cache(); end

  def to_yaml(opts=T.unsafe(nil)); end

  def traverse(trail=T.unsafe(nil), visited=T.unsafe(nil), &block); end

  def validate(packaging=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end

  def version=(version); end

  def warning(statement); end

  def yaml_initialize(tag, vals); end
  DateLike = ::T.let(nil, ::T.untyped)
  DateTimeFormat = ::T.let(nil, ::T.untyped)
  INITIALIZE_CODE_FOR_DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::T::Sig
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self._all(); end

  def self._clear_load_cache(); end

  def self._latest_specs(specs, prerelease=T.unsafe(nil)); end

  def self._load(str); end

  def self._resort!(specs); end

  def self.add_spec(spec); end

  def self.add_specs(*specs); end

  def self.all(); end

  def self.all=(specs); end

  def self.all_names(); end

  def self.array_attributes(); end

  def self.attribute_names(); end

  def self.dirs(); end

  def self.dirs=(dirs); end

  def self.each(); end

  def self.each_gemspec(dirs); end

  def self.each_spec(dirs); end

  def self.find_active_stub_by_path(path); end

  def self.find_all_by_full_name(full_name); end

  def self.find_all_by_name(name, *requirements); end

  def self.find_by_name(name, *requirements); end

  def self.find_by_path(path); end

  def self.find_in_unresolved(path); end

  def self.find_in_unresolved_tree(path); end

  def self.find_inactive_by_path(path); end

  def self.from_yaml(input); end

  def self.latest_specs(prerelease=T.unsafe(nil)); end

  def self.load(file); end

  def self.load_defaults(); end

  def self.non_nil_attributes(); end

  def self.normalize_yaml_input(input); end

  def self.outdated(); end

  def self.outdated_and_latest_version(); end

  def self.remove_spec(spec); end

  def self.required_attribute?(name); end

  def self.required_attributes(); end

  def self.reset(); end

  def self.stubs(); end

  def self.stubs_for(name); end

  def self.unresolved_deps(); end
end

class Gem::StreamUI
  def _gets_noecho(); end

  def alert(statement, question=T.unsafe(nil)); end

  def alert_error(statement, question=T.unsafe(nil)); end

  def alert_warning(statement, question=T.unsafe(nil)); end

  def ask(question); end

  def ask_for_password(question); end

  def ask_yes_no(question, default=T.unsafe(nil)); end

  def backtrace(exception); end

  def choose_from_list(question, list); end

  def close(); end

  def debug(statement); end

  def download_reporter(*args); end

  def errs(); end

  def initialize(in_stream, out_stream, err_stream=T.unsafe(nil), usetty=T.unsafe(nil)); end

  def ins(); end

  def outs(); end

  def progress_reporter(*args); end

  def require_io_console(); end

  def say(statement=T.unsafe(nil)); end

  def terminate_interaction(status=T.unsafe(nil)); end

  def tty?(); end
end

class Gem::StreamUI
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end
end

class Gem::StubSpecification::StubLine
  extend ::T::Sig
end

class Gem::StubSpecification
  extend ::T::Sig
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::SystemExitException
  def exit_code(); end

  def exit_code=(exit_code); end

  def initialize(exit_code); end
end

class Gem::SystemExitException
  extend ::T::Sig
end

module Gem::Text
  def clean_text(text); end

  def format_text(text, wrap, indent=T.unsafe(nil)); end

  def levenshtein_distance(str1, str2); end

  def min3(a, b, c); end

  def truncate_text(text, description, max_length=T.unsafe(nil)); end
end

module Gem::Text
  extend ::T::Sig
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

class Gem::UnsatisfiableDependencyError
  def dependency(); end

  def errors(); end

  def errors=(errors); end

  def initialize(dep, platform_mismatch=T.unsafe(nil)); end

  def name(); end
end

class Gem::UnsatisfiableDependencyError
  extend ::T::Sig
end

class Gem::UriFormatter
  def escape(); end

  def initialize(uri); end

  def normalize(); end

  def unescape(); end

  def uri(); end
end

class Gem::UriFormatter
end

module Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def alert(statement, question=T.unsafe(nil)); end

  def alert_error(statement, question=T.unsafe(nil)); end

  def alert_warning(statement, question=T.unsafe(nil)); end

  def ask(question); end

  def ask_for_password(prompt); end

  def ask_yes_no(question, default=T.unsafe(nil)); end

  def choose_from_list(question, list); end

  def say(statement=T.unsafe(nil)); end

  def terminate_interaction(exit_code=T.unsafe(nil)); end

  def verbose(msg=T.unsafe(nil)); end
end

module Gem::UserInteraction
  extend ::T::Sig
end

module Gem::Util
  NULL_DEVICE = ::T.let(nil, ::T.untyped)
end

module Gem::Util
  extend ::T::Sig
  def self.gunzip(data); end

  def self.gzip(data); end

  def self.inflate(data); end

  def self.popen(*command); end

  def self.silent_system(*command); end

  def self.traverse_parents(directory, &block); end
end

class Gem::VerificationError
  extend ::T::Sig
end

class Gem::Version
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def _segments(); end

  def _split_segments(); end

  def _version(); end

  def approximate_recommendation(); end

  def bump(); end

  def canonical_segments(); end

  def encode_with(coder); end

  def eql?(other); end

  def init_with(coder); end

  def marshal_dump(); end

  def marshal_load(array); end

  def prerelease?(); end

  def release(); end

  def segments(); end

  def to_yaml_properties(); end

  def yaml_initialize(tag, map); end
end

Gem::Version::Requirement = Gem::Requirement

class Gem::Version
  extend ::T::Sig
  def self.correct?(version); end

  def self.create(input); end

  def self.new(version); end
end

module Gem
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self._deprecated_datadir(gem_name); end

  def self.activate_bin_path(name, *args); end

  def self.default_ext_dir_for(base_dir); end

  def self.default_gems_use_full_paths?(); end

  def self.default_spec_cache_dir(); end

  def self.deflate(data); end

  def self.detect_gemdeps(path=T.unsafe(nil)); end

  def self.dir(); end

  def self.done_installing(&hook); end

  def self.done_installing_hooks(); end

  def self.ensure_default_gem_subdirectories(dir=T.unsafe(nil), mode=T.unsafe(nil)); end

  def self.ensure_gem_subdirectories(dir=T.unsafe(nil), mode=T.unsafe(nil)); end

  def self.ensure_subdirectories(dir, mode, subdirs); end

  def self.env_requirement(gem_name); end

  def self.extension_api_version(); end

  def self.find_files(glob, check_load_path=T.unsafe(nil)); end

  def self.find_files_from_load_path(glob); end

  def self.find_latest_files(glob, check_load_path=T.unsafe(nil)); end

  def self.find_unresolved_default_spec(path); end

  def self.finish_resolve(*_); end

  def self.gemdeps(); end

  def self.gunzip(data); end

  def self.gzip(data); end

  def self.host(); end

  def self.host=(host); end

  def self.inflate(data); end

  def self.install(name, version=T.unsafe(nil), *options); end

  def self.install_extension_in_lib(); end

  def self.latest_rubygems_version(); end

  def self.latest_spec_for(name); end

  def self.latest_version_for(name); end

  def self.load_env_plugins(); end

  def self.load_path_insert_index(); end

  def self.load_plugin_files(plugins); end

  def self.load_plugins(); end

  def self.load_yaml(); end

  def self.loaded_specs(); end

  def self.location_of_caller(depth=T.unsafe(nil)); end

  def self.marshal_version(); end

  def self.needs(); end

  def self.path(); end

  def self.path_separator(); end

  def self.paths(); end

  def self.paths=(env); end

  def self.platform_defaults(); end

  def self.platforms(); end

  def self.platforms=(platforms); end

  def self.post_build(&hook); end

  def self.post_build_hooks(); end

  def self.post_install(&hook); end

  def self.post_install_hooks(); end

  def self.post_reset(&hook); end

  def self.post_reset_hooks(); end

  def self.post_uninstall(&hook); end

  def self.post_uninstall_hooks(); end

  def self.pre_install(&hook); end

  def self.pre_install_hooks(); end

  def self.pre_reset(&hook); end

  def self.pre_reset_hooks(); end

  def self.pre_uninstall(&hook); end

  def self.pre_uninstall_hooks(); end

  def self.prefix(); end

  def self.read_binary(path); end

  def self.refresh(); end

  def self.register_default_spec(spec); end

  def self.remove_unresolved_default_spec(spec); end

  def self.ruby(); end

  def self.ruby_api_version(); end

  def self.ruby_engine(); end

  def self.ruby_version(); end

  def self.rubygems_version(); end

  def self.sources(); end

  def self.sources=(new_sources); end

  def self.spec_cache_dir(); end

  def self.suffix_pattern(); end

  def self.suffixes(); end

  def self.time(msg, width=T.unsafe(nil), display=T.unsafe(nil)); end

  def self.try_activate(path); end

  def self.ui(); end

  def self.use_gemdeps(path=T.unsafe(nil)); end

  def self.use_paths(home, *paths); end

  def self.user_dir(); end

  def self.user_home(); end

  def self.vendor_dir(); end

  def self.win_platform?(); end

  def self.write_binary(path, data); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def compact(); end

  def compact!(); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def dig(*_); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def merge!(_); end

  def replace(_); end

  def slice(*_); end

  def to_h(); end

  def to_proc(); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values(); end

  def transform_values!(); end

  def update(_); end
end

class Hash
  extend ::T::Sig
  def self.try_convert(_); end
end

class IO
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def external_encoding(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def pathconf(_); end

  def pread(*_); end

  def pwrite(_, _1); end

  def ready?(); end

  def scanf(str, &b); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

class IO::EAGAINWaitReadable
  extend ::T::Sig
end

class IO::EAGAINWaitWritable
  extend ::T::Sig
end

class IO::EINPROGRESSWaitReadable
  extend ::T::Sig
end

class IO::EINPROGRESSWaitWritable
  extend ::T::Sig
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

module IO::WaitReadable
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

module IO::WaitWritable
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class IO
  extend ::T::Sig
  def self.foreach(*_); end

  def self.pipe(*_); end

end

class IOError
  extend ::T::Sig
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

class IPSocket
  extend ::T::Sig
end

class IndexError
  extend ::T::Sig
end

class Installation::AutoClient
  include ::Yast::Logger
  def change(); end

  def export(); end

  def import(_profile); end

  def modified(); end

  def modified?(); end

  def packages(); end

  def read(); end

  def reset(); end

  def run(); end

  def summary(); end

  def write(); end
end

class Installation::AutoClient
  extend ::Yast::Logger
  def self.run(); end
end

class Installation::FinishClient
  include ::Yast::Logger
  def info(); end

  def modes(); end

  def run(); end

  def steps(); end

  def title(); end

  def write(); end
end

class Installation::FinishClient
  extend ::Yast::Logger
  def self.run(); end
end

class Installation::ProposalClient
  include ::Yast::Logger
  def ask_user(_attrs); end

  def description(); end

  def make_proposal(_attrs); end

  def run(); end

  def write(); end
end

class Installation::ProposalClient
  extend ::Yast::Logger
  def self.run(); end
end

module Installation
  extend ::T::Sig
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def nobits?(_); end

  def pow(*_); end

  def prime?(); end

  def prime_division(generator=T.unsafe(nil)); end

  def to_bn(); end

end

class Integer
  extend ::T::Sig
  def self.each_prime(ubound, &block); end

  def self.from_prime_division(pd); end

  def self.sqrt(_); end
end

class Interrupt
  extend ::T::Sig
end

class JSON::CircularDatastructure
  extend ::T::Sig
end

module JSON::Ext
end

module JSON::Ext::Generator
end

module JSON::Ext::Generator::GeneratorMethods
end

module JSON::Ext::Generator::GeneratorMethods::Array
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Array
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::FalseClass
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::FalseClass
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Float
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Float
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Hash
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Hash
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Integer
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Integer
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::NilClass
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Object
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Object
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::String
  def to_json(*_); end

  def to_json_raw(*_); end

  def to_json_raw_object(); end
end

module JSON::Ext::Generator::GeneratorMethods::String::Extend
  def json_create(_); end
end

module JSON::Ext::Generator::GeneratorMethods::String::Extend
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::String
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::TrueClass
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::TrueClass
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods
  extend ::T::Sig
end

class JSON::Ext::Generator::State
  def [](_); end

  def []=(_, _1); end

  def allow_nan?(); end

  def array_nl(); end

  def array_nl=(array_nl); end

  def ascii_only?(); end

  def buffer_initial_length(); end

  def buffer_initial_length=(buffer_initial_length); end

  def check_circular?(); end

  def configure(_); end

  def depth(); end

  def depth=(depth); end

  def generate(_); end

  def indent(); end

  def indent=(indent); end

  def initialize(*_); end

  def max_nesting(); end

  def max_nesting=(max_nesting); end

  def merge(_); end

  def object_nl(); end

  def object_nl=(object_nl); end

  def space(); end

  def space=(space); end

  def space_before(); end

  def space_before=(space_before); end

  def to_h(); end

  def to_hash(); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

module JSON::Ext::Generator
  extend ::T::Sig
end

class JSON::Ext::Parser
  def initialize(*_); end

  def parse(); end

  def source(); end
end

class JSON::Ext::Parser
end

module JSON::Ext
  extend ::T::Sig
end

class JSON::GeneratorError
  extend ::T::Sig
end

class JSON::GenericObject
  extend ::T::Sig
end

class JSON::JSONError
  extend ::T::Sig
end

class JSON::MissingUnicodeSupport
  extend ::T::Sig
end

class JSON::NestingError
  extend ::T::Sig
end

JSON::Parser = JSON::Ext::Parser

class JSON::ParserError
  extend ::T::Sig
end

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JSON
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

module Kernel
  def class(); end

  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def respond_to?(*_); end

  def yield_self(); end
end

module Kernel
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
  def key(); end

  def receiver(); end
end

class KeyError
  extend ::T::Sig
end

class LoadError
  def path(); end
end

class LoadError
  extend ::T::Sig
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class LocalJumpError
  extend ::T::Sig
end

class Logger
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Error
  extend ::T::Sig
end

class Logger::Formatter
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  extend ::T::Sig
end

class Logger::LogDevice
  include ::MonitorMixin
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class Logger::LogDevice
  extend ::T::Sig
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Logger::Period
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

module Logger::Severity
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class Logger::ShiftingError
  extend ::T::Sig
end

class Logger
  extend ::T::Sig
end

module Marshal
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.restore(*_); end
end

class MatchData
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def named_captures(); end
end

class MatchData
  extend ::T::Sig
end

class Math::DomainError
  extend ::T::Sig
end

module Math
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class Method
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def ===(*_); end

  def [](*_); end

  def arity(); end

  def clone(); end

  def curry(*_); end

  def name(); end

  def original_name(); end

  def owner(); end

  def parameters(); end

  def receiver(); end

  def source_location(); end

  def super_method(); end

  def unbind(); end
end

class Method
  extend ::T::Sig
end

class Module
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def deprecate_constant(*_); end

  def undef_method(*_); end
end

class Module
  extend ::T::Sig
  def self.used_modules(); end
end

class Monitor
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def enter(); end

  def exit(); end

  def try_enter(); end
end

class Monitor
  extend ::T::Sig
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
end

class MonitorMixin::ConditionVariable
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

class MonitorMixin::ConditionVariable::Timeout
  extend ::T::Sig
end

class MonitorMixin::ConditionVariable
  extend ::T::Sig
end

module MonitorMixin
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.extend_object(obj); end
end

Mutex = Thread::Mutex

class NameError
  include ::DidYouMean::Correctable
  def name(); end

  def receiver(); end
end

class NameError
  extend ::T::Sig
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def to_i(); end
end

class NilClass
  extend ::T::Sig
end

class NoMemoryError
  extend ::T::Sig
end

class NoMethodError
  include ::DidYouMean::Correctable
  def args(); end

  def private_call?(); end
end

class NoMethodError
  extend ::T::Sig
end

class NotImplementedError
  extend ::T::Sig
end

class Numeric
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def finite?(); end

  def infinite?(); end

  def negative?(); end

  def positive?(); end

end

class Numeric
  extend ::T::Sig
end

class Object
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  include ::PP::ObjectMixin
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  BASH_PATH = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  DIR_PATH = ::T.let(nil, ::T.untyped)
  ENCRYPTED_PASSWORD = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  FILE_CONTENT_RESTRICTED = ::T.let(nil, ::T.untyped)
  FILE_CONTENT_UNRESTRICTED = ::T.let(nil, ::T.untyped)
  FILE_CONTENT_WRONG = ::T.let(nil, ::T.untyped)
  GLOBAL_WFM_CONTEXT = ::T.let(nil, ::T.untyped)
  ID_MATCHERS = ::T.let(nil, ::T.untyped)
  LIMIT = ::T.let(nil, ::T.untyped)
  MAX_CHANGES_LINES = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  SIZE_PATH = ::T.let(nil, ::T.untyped)
  STAT_PATH = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TMP_RUBY_PREFIX = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  extend ::T::Sig
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def [](_); end

  def []=(_, _1); end

  def each(); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

class ObjectSpace::WeakMap
  extend ::T::Sig
end

module ObjectSpace
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

module Open3
  extend ::T::Sig
end

class OpenSSL::Digest
  extend ::T::Sig
end

class OpenSSL::PKey::PKey
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class OpenSSL::PKey::PKey
  extend ::T::Sig
end

class OpenStruct
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class OpenStruct
  extend ::T::Sig
end

OptParse = OptionParser

class OptionParser
  def abort(mesg=T.unsafe(nil)); end

  def accept(*args, &blk); end

  def add_officious(); end

  def banner(); end

  def banner=(banner); end

  def base(); end

  def candidate(word); end

  def compsys(to, name=T.unsafe(nil)); end

  def def_head_option(*opts, &block); end

  def def_option(*opts, &block); end

  def def_tail_option(*opts, &block); end

  def default_argv(); end

  def default_argv=(default_argv); end

  def define(*opts, &block); end

  def define_head(*opts, &block); end

  def define_tail(*opts, &block); end

  def environment(env=T.unsafe(nil)); end

  def getopts(*args); end

  def help(); end

  def inc(*args); end

  def initialize(banner=T.unsafe(nil), width=T.unsafe(nil), indent=T.unsafe(nil)); end

  def load(filename=T.unsafe(nil)); end

  def make_switch(opts, block=T.unsafe(nil)); end

  def new(); end

  def on(*opts, &block); end

  def on_head(*opts, &block); end

  def on_tail(*opts, &block); end

  def order(*argv, into: T.unsafe(nil), &nonopt); end

  def order!(argv=T.unsafe(nil), into: T.unsafe(nil), &nonopt); end

  def parse(*argv, into: T.unsafe(nil)); end

  def parse!(argv=T.unsafe(nil), into: T.unsafe(nil)); end

  def permute(*argv, into: T.unsafe(nil)); end

  def permute!(argv=T.unsafe(nil), into: T.unsafe(nil)); end

  def program_name(); end

  def program_name=(program_name); end

  def reject(*args, &blk); end

  def release(); end

  def release=(release); end

  def remove(); end

  def separator(string); end

  def set_banner(_); end

  def set_program_name(_); end

  def set_summary_indent(_); end

  def set_summary_width(_); end

  def summarize(to=T.unsafe(nil), width=T.unsafe(nil), max=T.unsafe(nil), indent=T.unsafe(nil), &blk); end

  def summary_indent(); end

  def summary_indent=(summary_indent); end

  def summary_width(); end

  def summary_width=(summary_width); end

  def terminate(arg=T.unsafe(nil)); end

  def to_a(); end

  def top(); end

  def ver(); end

  def version=(version); end

  def warn(mesg=T.unsafe(nil)); end
  ArgumentStyle = ::T.let(nil, ::T.untyped)
  COMPSYS_HEADER = ::T.let(nil, ::T.untyped)
  DecimalInteger = ::T.let(nil, ::T.untyped)
  DecimalNumeric = ::T.let(nil, ::T.untyped)
  DefaultList = ::T.let(nil, ::T.untyped)
  NO_ARGUMENT = ::T.let(nil, ::T.untyped)
  NoArgument = ::T.let(nil, ::T.untyped)
  OPTIONAL_ARGUMENT = ::T.let(nil, ::T.untyped)
  OctalInteger = ::T.let(nil, ::T.untyped)
  Officious = ::T.let(nil, ::T.untyped)
  OptionalArgument = ::T.let(nil, ::T.untyped)
  REQUIRED_ARGUMENT = ::T.let(nil, ::T.untyped)
  RequiredArgument = ::T.let(nil, ::T.untyped)
  SPLAT_PROC = ::T.let(nil, ::T.untyped)
end

module OptionParser::Acceptables
  DecimalInteger = ::T.let(nil, ::T.untyped)
  DecimalNumeric = ::T.let(nil, ::T.untyped)
  OctalInteger = ::T.let(nil, ::T.untyped)
end

module OptionParser::Acceptables
  extend ::T::Sig
end

class OptionParser::AmbiguousArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::AmbiguousArgument
end

class OptionParser::AmbiguousOption
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::AmbiguousOption
end

module OptionParser::Arguable
  def getopts(*args); end

  def initialize(*args); end

  def options(); end

  def options=(opt); end

  def order!(&blk); end

  def parse!(); end

  def permute!(); end
end

module OptionParser::Arguable
  extend ::T::Sig
  def self.extend_object(obj); end
end

class OptionParser::CompletingHash
  include ::OptionParser::Completion
  def match(key); end
end

class OptionParser::CompletingHash
end

module OptionParser::Completion
  def candidate(key, icase=T.unsafe(nil), pat=T.unsafe(nil)); end

  def complete(key, icase=T.unsafe(nil), pat=T.unsafe(nil)); end

  def convert(opt=T.unsafe(nil), val=T.unsafe(nil), *_); end
end

module OptionParser::Completion
  extend ::T::Sig
  def self.candidate(key, icase=T.unsafe(nil), pat=T.unsafe(nil), &block); end

  def self.regexp(key, icase); end
end

class OptionParser::InvalidArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::InvalidArgument
end

class OptionParser::InvalidOption
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::InvalidOption
end

class OptionParser::List
  def accept(t, pat=T.unsafe(nil), &block); end

  def add_banner(to); end

  def append(*args); end

  def atype(); end

  def complete(id, opt, icase=T.unsafe(nil), *pat, &block); end

  def compsys(*args, &block); end

  def each_option(&block); end

  def list(); end

  def long(); end

  def prepend(*args); end

  def reject(t); end

  def search(id, key); end

  def short(); end

  def summarize(*args, &block); end
end

class OptionParser::List
end

class OptionParser::MissingArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::MissingArgument
end

class OptionParser::NeedlessArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::NeedlessArgument
end

class OptionParser::OptionMap
  include ::OptionParser::Completion
end

class OptionParser::OptionMap
end

class OptionParser::ParseError
  def args(); end

  def initialize(*args); end

  def reason(); end

  def reason=(reason); end

  def recover(argv); end

  def set_backtrace(array); end

  def set_option(opt, eq); end
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::ParseError
  def self.filter_backtrace(array); end
end

class OptionParser::Switch
  def add_banner(to); end

  def arg(); end

  def block(); end

  def compsys(sdone, ldone); end

  def conv(); end

  def desc(); end

  def initialize(pattern=T.unsafe(nil), conv=T.unsafe(nil), short=T.unsafe(nil), long=T.unsafe(nil), arg=T.unsafe(nil), desc=T.unsafe(nil), block=T.unsafe(nil)); end

  def long(); end

  def match_nonswitch?(str); end

  def pattern(); end

  def short(); end

  def summarize(sdone=T.unsafe(nil), ldone=T.unsafe(nil), width=T.unsafe(nil), max=T.unsafe(nil), indent=T.unsafe(nil)); end

  def switch_name(); end
end

class OptionParser::Switch::NoArgument
  def parse(arg, argv); end
end

class OptionParser::Switch::NoArgument
  def self.incompatible_argument_styles(*_); end
end

class OptionParser::Switch::OptionalArgument
  def parse(arg, argv, &error); end
end

class OptionParser::Switch::OptionalArgument
end

class OptionParser::Switch::PlacedArgument
  def parse(arg, argv, &error); end
end

class OptionParser::Switch::PlacedArgument
end

class OptionParser::Switch::RequiredArgument
  def parse(arg, argv); end
end

class OptionParser::Switch::RequiredArgument
end

class OptionParser::Switch
  def self.guess(arg); end

  def self.incompatible_argument_styles(arg, t); end

  def self.pattern(); end
end

class OptionParser
  def self.accept(*args, &blk); end

  def self.getopts(*args); end

  def self.inc(arg, default=T.unsafe(nil)); end

  def self.reject(*args, &blk); end

  def self.terminate(arg=T.unsafe(nil)); end

  def self.top(); end

  def self.with(*args, &block); end
end

module PP::ObjectMixin
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

module PP::PPMethods
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class PP::SingleLine
  extend ::T::Sig
end

class PP
  extend ::T::Sig
end

module Packages
end

class Packages::DummyCallbacks
end

class Packages::DummyCallbacks
  extend ::Yast::Logger
  def self.register(); end
end

class Packages::FileConflictCallbacks
  PKG_INSTALL_WIDGET = ::T.let(nil, ::T.untyped)
end

class Packages::FileConflictCallbacks
  extend ::Yast::Logger
  extend ::Yast::I18n
  extend ::Yast::UIShortcuts
  def self.register(); end
end

class Packages::PackageDownloader
  include ::Yast::Logger
  include ::Yast::I18n
  def download(path); end

  def initialize(repo_id, package_name); end

  def repo_id(); end
end

class Packages::PackageDownloader::FetchError
end

class Packages::PackageDownloader::FetchError
end

class Packages::PackageDownloader
  extend ::Yast::Logger
end

class Packages::PackageExtractor
  include ::Yast::Logger
  def extract(dir); end

  def initialize(package_path); end

  def package_path(); end
  EXTRACT_CMD = ::T.let(nil, ::T.untyped)
end

class Packages::PackageExtractor::ExtractionFailed
end

class Packages::PackageExtractor::ExtractionFailed
end

class Packages::PackageExtractor
  extend ::Yast::Logger
end

module Packages
  extend ::T::Sig
end

class Packaging::Configuration
  AUTOYAST_RNC_DIR = ::T.let(nil, ::T.untyped)
  DESTDIR = ::T.let(nil, ::T.untyped)
  FILLUP_DIRS = ::T.let(nil, ::T.untyped)
  YAST_DESKTOP_DIR = ::T.let(nil, ::T.untyped)
  YAST_DIR = ::T.let(nil, ::T.untyped)
  YAST_ICON_BASE_DIR = ::T.let(nil, ::T.untyped)
  YAST_LIB_DIR = ::T.let(nil, ::T.untyped)
  YAST_THEME_DIR = ::T.let(nil, ::T.untyped)
end

module Packaging::Tasks
  extend ::T::Sig
end

module Packaging
  extend ::T::Sig
end

module Parallel
  extend ::T::Sig
end

class Pathname
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end

end

class Pathname
  extend ::T::Sig
end

class PrettyPrint
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class PrettyPrint::Breakable
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class PrettyPrint::Breakable
  extend ::T::Sig
end

class PrettyPrint::Group
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class PrettyPrint::Group
  extend ::T::Sig
end

class PrettyPrint::GroupQueue
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class PrettyPrint::GroupQueue
  extend ::T::Sig
end

class PrettyPrint::SingleLine
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class PrettyPrint::SingleLine
  extend ::T::Sig
end

class PrettyPrint::Text
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class PrettyPrint::Text
  extend ::T::Sig
end

class PrettyPrint
  extend ::T::Sig
end

class Prime
  include ::Enumerable
  include ::Singleton
  def each(ubound=T.unsafe(nil), generator=T.unsafe(nil), &block); end

  def int_from_prime_division(pd); end

  def prime?(value, generator=T.unsafe(nil)); end

  def prime_division(value, generator=T.unsafe(nil)); end
end

class Prime::EratosthenesGenerator
  def initialize(); end
end

class Prime::EratosthenesGenerator
end

class Prime::EratosthenesSieve
  include ::Singleton
  def get_nth_prime(n); end
end

class Prime::EratosthenesSieve
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Prime::Generator23
  def initialize(); end
end

class Prime::Generator23
end

class Prime::PseudoPrimeGenerator
  include ::Enumerable
  def each(); end

  def initialize(ubound=T.unsafe(nil)); end

  def next(); end

  def rewind(); end

  def size(); end

  def succ(); end

  def upper_bound(); end

  def upper_bound=(ubound); end

  def with_index(offset=T.unsafe(nil)); end

  def with_object(obj); end
end

class Prime::PseudoPrimeGenerator
end

class Prime::TrialDivision
  include ::Singleton
  def [](index); end

  def cache(); end

  def primes(); end

  def primes_so_far(); end
end

class Prime::TrialDivision
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Prime::TrialDivisionGenerator
  def initialize(); end
end

class Prime::TrialDivisionGenerator
end

class Prime
  extend ::Singleton::SingletonClassMethods
  extend ::Enumerable
  def self.each(*args, &block); end

  def self.instance(); end

  def self.int_from_prime_division(*args, &block); end

  def self.method_added(method); end

  def self.prime?(*args, &block); end

  def self.prime_division(*args, &block); end
end

class Proc
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def ===(*_); end

  def [](*_); end

  def clone(); end

  def lambda?(); end

  def yield(*_); end
end

class Proc
  extend ::T::Sig
end

module Process::GID
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class Process::Status
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class Process::Status
  extend ::T::Sig
end

module Process::Sys
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.getegid(); end

end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  extend ::T::Sig
  def self.[](*_); end

  def self.members(); end
end

module Process::UID
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class Process::Waiter
  extend ::T::Sig
end

module Process
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.last_status(); end

  def self.setpgrp(); end

end

module Psych
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::FALLBACK
  def to_ruby(); end

  def to_ruby=(_); end
end

class Psych::FALLBACK
  def self.[](*_); end

  def self.members(); end
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def event_location(start_line, start_column, end_line, end_column); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
  extend ::T::Sig
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
  extend ::T::Sig
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
  extend ::T::Sig
end

module Psych::JSON
  extend ::T::Sig
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def children(); end

  def each(&block); end

  def end_column(); end

  def end_column=(end_column); end

  def end_line(); end

  def end_line=(end_line); end

  def start_column(); end

  def start_column=(start_column); end

  def start_line(); end

  def start_line=(start_line); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
  extend ::T::Sig
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
  extend ::T::Sig
end

module Psych::Streaming
  extend ::T::Sig
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Delegator(o); end

  def visit_Encoding(o); end

  def visit_Enumerator(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end
end

module Psych::Visitors
  extend ::T::Sig
end

module Psych
  extend ::T::Sig
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, filename=T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.load_file(filename, fallback: T.unsafe(nil)); end

  def self.load_stream(yaml, filename=T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.parse(yaml, filename=T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_stream(yaml, filename=T.unsafe(nil), &block); end

  def self.parser(); end

  def self.remove_type(type_tag); end

  def self.safe_load(yaml, whitelist_classes=T.unsafe(nil), whitelist_symbols=T.unsafe(nil), aliases=T.unsafe(nil), filename=T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.to_json(object); end
end

Queue = Thread::Queue

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Configuration::ExposeCurrentExample
  extend ::T::Sig
end

module RSpec::Core::Configuration::Readers
  extend ::T::Sig
end

class RSpec::Core::ConfigurationOptions
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::DSL
  extend ::T::Sig
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  include ::RSpec::Matchers
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ExampleStatusPersister
  def initialize(examples, file_name); end

  def persist(); end
end

class RSpec::Core::ExampleStatusPersister
  def self.load_from(file_name); end

  def self.persist(examples, file_name); end
end

RSpec::Core::ExclusionRules = RSpec::Core::FilterRules

class RSpec::Core::FilterRules
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::FilterableItemRepository
  extend ::T::Sig
end

module RSpec::Core::FlatMap
  extend ::T::Sig
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def example_failed(notification); end

  def example_finished(notification); end

  def initialize(expected_failures); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def self.inherited(formatter); end
end

class RSpec::Core::Formatters::BaseFormatter
  def close(_notification); end

  def example_group(); end

  def example_group=(example_group); end

  def example_group_started(notification); end

  def initialize(output); end

  def output(); end

  def start(notification); end
end

class RSpec::Core::Formatters::BaseFormatter
end

class RSpec::Core::Formatters::BaseTextFormatter
  def dump_failures(notification); end

  def dump_pending(notification); end

  def dump_summary(summary); end

  def message(notification); end

  def seed(notification); end
end

class RSpec::Core::Formatters::BaseTextFormatter
end

class RSpec::Core::Formatters::BisectDRbFormatter
  def initialize(_output); end

  def notify_results(results); end
end

class RSpec::Core::Formatters::BisectDRbFormatter
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::ConsoleCodes
  extend ::T::Sig
end

class RSpec::Core::Formatters::DeprecationFormatter
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DocumentationFormatter
  def example_failed(failure); end

  def example_group_finished(_notification); end

  def example_passed(passed); end

  def example_pending(pending); end
end

class RSpec::Core::Formatters::DocumentationFormatter
end

class RSpec::Core::Formatters::ExceptionPresenter
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
  extend ::T::Sig
end

class RSpec::Core::Formatters::FallbackMessageFormatter
  def initialize(output); end

  def message(notification); end

  def output(); end
end

class RSpec::Core::Formatters::FallbackMessageFormatter
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::Helpers
  extend ::T::Sig
end

class RSpec::Core::Formatters::HtmlFormatter
  def dump_summary(summary); end

  def example_failed(failure); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::HtmlFormatter
end

class RSpec::Core::Formatters::JsonFormatter
  def dump_profile(profile); end

  def dump_profile_slowest_example_groups(profile); end

  def dump_profile_slowest_examples(profile); end

  def dump_summary(summary); end

  def message(notification); end

  def output_hash(); end

  def seed(notification); end

  def stop(notification); end
end

class RSpec::Core::Formatters::JsonFormatter
end

class RSpec::Core::Formatters::ProfileFormatter
  def dump_profile(profile); end

  def initialize(output); end

  def output(); end
end

class RSpec::Core::Formatters::ProfileFormatter
end

class RSpec::Core::Formatters::ProgressFormatter
  def example_failed(_notification); end

  def example_passed(_notification); end

  def example_pending(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::ProgressFormatter
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  extend ::T::Sig
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
  extend ::T::Sig
end

RSpec::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

module RSpec::Core::Formatters
  extend ::T::Sig
end

module RSpec::Core::HashImitatable::ClassMethods
  extend ::T::Sig
end

module RSpec::Core::HashImitatable
  extend ::T::Sig
end

class RSpec::Core::Hooks::HookCollections
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Hooks
  extend ::T::Sig
end

module RSpec::Core::Invocations
  extend ::T::Sig
end

module RSpec::Core::MemoizedHelpers::ClassMethods
  extend ::T::Sig
end

module RSpec::Core::MemoizedHelpers
  extend ::T::Sig
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Metadata
  extend ::T::Sig
end

module RSpec::Core::MetadataFilter
  extend ::T::Sig
end

module RSpec::Core::MockingAdapters::RSpec
  extend ::T::Sig
end

module RSpec::Core::MockingAdapters
  extend ::T::Sig
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  extend ::T::Sig
end

module RSpec::Core::Notifications::NullColorizer
  extend ::T::Sig
end

module RSpec::Core::Notifications
  extend ::T::Sig
end

class RSpec::Core::Ordering::Random
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Ordering
  extend ::T::Sig
end

module RSpec::Core::Pending
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Pending
  extend ::T::Sig
end

class RSpec::Core::Profiler
  def example_group_finished(notification); end

  def example_group_started(notification); end

  def example_groups(); end

  def example_started(notification); end
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
end

class RSpec::Core::Reporter
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::RubyProject
  extend ::T::Sig
end

module RSpec::Core::SharedContext
  def __shared_context_recordings(); end

  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def context(*args, &block); end

  def describe(*args, &block); end

  def hooks(*args, &block); end

  def included(group); end

  def let(*args, &block); end

  def let!(*args, &block); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end

  def subject(*args, &block); end

  def subject!(*args, &block); end
end

class RSpec::Core::SharedContext::Recording
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def method_name(); end

  def method_name=(_); end

  def playback_onto(group); end
end

class RSpec::Core::SharedContext::Recording
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::SharedContext
  extend ::T::Sig
  def self.record(methods); end
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
  extend ::T::Sig
end

module RSpec::Core::SharedExampleGroup
  extend ::T::Sig
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::ShellEscape
  extend ::T::Sig
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Version
  extend ::T::Sig
end

module RSpec::Core::Warnings
  extend ::T::Sig
end

module RSpec::Core::World::Null
  extend ::T::Sig
end

module RSpec::Core
  extend ::T::Sig
end

module RSpec::ExampleGroups
  extend ::T::Sig
end

class RSpec::Expectations::BlockSnippetExtractor
  def body_content_lines(); end

  def initialize(proc, method_name); end

  def method_name(); end
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_content_locations(); end

  def method_call_location(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_tokens(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end

  def state(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor
  def self.try_extracting_single_line_body_of(proc, method_name); end
end

class RSpec::Expectations::Configuration
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
  extend ::T::Sig
end

module RSpec::Expectations::ExpectationHelper
  extend ::T::Sig
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
  extend ::T::Sig
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
  extend ::T::Sig
end

class RSpec::Expectations::FailureAggregator
  def aggregate(); end

  def block_label(); end

  def call(failure, options); end

  def failures(); end

  def initialize(block_label, metadata); end

  def metadata(); end

  def other_errors(); end
end

class RSpec::Expectations::FailureAggregator
end

RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

class RSpec::Expectations::MultipleExpectationsNotMetError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(failure_aggregator); end

  def other_errors(); end

  def summary(); end
end

module RSpec::Expectations::Syntax
  extend ::T::Sig
end

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Version
  extend ::T::Sig
end

module RSpec::Expectations
  extend ::T::Sig
end

module RSpec::Matchers
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

RSpec::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

class RSpec::Matchers::BuiltIn::All
  def does_not_match?(_actual); end

  def failed_objects(); end

  def initialize(matcher); end

  def matcher(); end
end

class RSpec::Matchers::BuiltIn::All
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  extend ::T::Sig
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  extend ::T::Sig
end

class RSpec::Matchers::BuiltIn::Be
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def <(operand); end

  def <=(operand); end

  def ==(operand); end

  def ===(operand); end

  def =~(operand); end

  def >(operand); end

  def >=(operand); end

  def initialize(*args); end
end

class RSpec::Matchers::BuiltIn::Be
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeBetween
  def exclusive(); end

  def inclusive(); end

  def initialize(min, max); end
end

class RSpec::Matchers::BuiltIn::BeBetween
end

class RSpec::Matchers::BuiltIn::BeComparedTo
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def initialize(operand, operator); end
end

class RSpec::Matchers::BuiltIn::BeComparedTo
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

module RSpec::Matchers::BuiltIn::BeHelpers
  extend ::T::Sig
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BePredicate
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def does_not_match?(actual, &block); end

  def initialize(*args, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::BePredicate
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeWithin
  def initialize(delta); end

  def of(expected); end

  def percent_of(expected); end
end

class RSpec::Matchers::BuiltIn::BeWithin
end

class RSpec::Matchers::BuiltIn::Change
  def by(expected_delta); end

  def by_at_least(minimum); end

  def by_at_most(maximum); end

  def does_not_match?(event_proc); end

  def from(value); end

  def initialize(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def matches?(event_proc); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::Change
end

class RSpec::Matchers::BuiltIn::Compound
  def diffable_matcher_list(); end

  def does_not_match?(_actual); end

  def evaluator(); end

  def initialize(matcher_1, matcher_2); end

  def matcher_1(); end

  def matcher_2(); end
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def initialize(actual, matcher_1, matcher_2); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def self.matcher_expects_call_stack_jump?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
  def initialize(actual, *_); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
end

class RSpec::Matchers::BuiltIn::Compound
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
  def actual_to_expected_matched_indexes(); end

  def expected_to_actual_matched_indexes(); end

  def find_best_solution(); end

  def initialize(expected_to_actual_matched_indexes, actual_to_expected_matched_indexes); end

  def solution(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
  def self.worse_than?(_other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def +(derived_candidate_solution); end

  def candidate?(); end

  def ideal?(); end

  def indeterminate_actual_indexes(); end

  def indeterminate_actual_indexes=(_); end

  def indeterminate_expected_indexes(); end

  def indeterminate_expected_indexes=(_); end

  def unmatched_actual_indexes(); end

  def unmatched_actual_indexes=(_); end

  def unmatched_expected_indexes(); end

  def unmatched_expected_indexes=(_); end

  def unmatched_item_count(); end

  def worse_than?(other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::Cover
  def does_not_match?(range); end

  def initialize(*expected); end

  def matches?(range); end
end

class RSpec::Matchers::BuiltIn::Cover
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Equal
  LITERAL_SINGLETONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Equal
end

class RSpec::Matchers::BuiltIn::Exist
  def does_not_match?(actual); end

  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
  def actual_exists?(); end

  def valid_test?(); end

  def validity_message(); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
end

class RSpec::Matchers::BuiltIn::Exist
end

class RSpec::Matchers::BuiltIn::Has
  def does_not_match?(actual, &block); end

  def initialize(method_name, *args, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Has
end

class RSpec::Matchers::BuiltIn::HaveAttributes
  def does_not_match?(actual); end

  def initialize(expected); end

  def respond_to_failed(); end
end

class RSpec::Matchers::BuiltIn::HaveAttributes
end

class RSpec::Matchers::BuiltIn::Include
  def does_not_match?(actual); end

  def expecteds(); end

  def initialize(*expecteds); end
end

class RSpec::Matchers::BuiltIn::Include
end

class RSpec::Matchers::BuiltIn::Match
  def initialize(expected); end

  def with_captures(*captures); end
end

class RSpec::Matchers::BuiltIn::Match
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def !=(_expected); end

  def !~(_expected); end

  def <(expected); end

  def <=(expected); end

  def ==(expected); end

  def ===(expected); end

  def =~(expected); end

  def >(expected); end

  def >=(expected); end

  def description(); end

  def fail_with_message(message); end

  def initialize(actual); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def self.get(klass, operator); end

  def self.register(klass, operator, matcher); end

  def self.registry(); end

  def self.unregister(klass, operator); end

  def self.use_custom_matcher_or_delegate(operator); end
end

class RSpec::Matchers::BuiltIn::Output
  def does_not_match?(block); end

  def initialize(expected); end

  def matches?(block); end

  def to_stderr(); end

  def to_stderr_from_any_process(); end

  def to_stdout(); end

  def to_stdout_from_any_process(); end
end

class RSpec::Matchers::BuiltIn::Output
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
end

class RSpec::Matchers::BuiltIn::RaiseError
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_error_or_message=T.unsafe(nil), expected_message=T.unsafe(nil), &block); end

  def matches?(given_proc, negative_expectation=T.unsafe(nil), &block); end

  def supports_block_expectations?(); end

  def with_message(expected_message); end
end

class RSpec::Matchers::BuiltIn::RaiseError
end

class RSpec::Matchers::BuiltIn::RespondTo
  def and_any_keywords(); end

  def and_keywords(*keywords); end

  def and_unlimited_arguments(); end

  def argument(); end

  def arguments(); end

  def does_not_match?(actual); end

  def initialize(*names); end

  def with(n); end

  def with_any_keywords(); end

  def with_keywords(*keywords); end

  def with_unlimited_arguments(); end
end

class RSpec::Matchers::BuiltIn::RespondTo
end

class RSpec::Matchers::BuiltIn::Satisfy
  def initialize(description=T.unsafe(nil), &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Satisfy
end

class RSpec::Matchers::BuiltIn::StartOrEndWith
  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::StartOrEndWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def matches?(given_proc); end

  def supports_block_expectations?(); end
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
end

class RSpec::Matchers::BuiltIn::YieldControl
  def at_least(number); end

  def at_most(number); end

  def does_not_match?(block); end

  def exactly(number); end

  def initialize(); end

  def matches?(block); end

  def once(); end

  def thrice(); end

  def times(); end

  def twice(); end
end

class RSpec::Matchers::BuiltIn::YieldControl
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
  def does_not_match?(block); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
end

module RSpec::Matchers::BuiltIn
  extend ::T::Sig
end

module RSpec::Matchers::Composable
  extend ::T::Sig
end

module RSpec::Matchers::DSL::DefaultImplementations
  extend ::T::Sig
end

module RSpec::Matchers::DSL::Macros
  RAISE_NOTIFIER = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::DSL::Macros::Deprecated
  extend ::T::Sig
end

module RSpec::Matchers::DSL::Macros
  extend ::T::Sig
end

module RSpec::Matchers::DSL
  extend ::T::Sig
end

module RSpec::Matchers::EnglishPhrasing
  extend ::T::Sig
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  DEFAULT_DIFF_LABEL = ::T.let(nil, ::T.untyped)
  DESCRIPTION_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers
  extend ::T::Sig
end

module RSpec::Mocks
  DEFAULT_CALLBACK_INVOCATION_STRATEGY = ::T.let(nil, ::T.untyped)
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::AnyInstance
end

class RSpec::Mocks::AnyInstance::Chain
  include ::RSpec::Mocks::AnyInstance::Chain::Customizations
  def constrained_to_any_of?(*constraints); end

  def expectation_fulfilled!(); end

  def initialize(recorder, *args, &block); end

  def matches_args?(*args); end

  def never(); end

  def playback!(instance); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def exactly(*args, &block); end

  def never(*args, &block); end

  def once(*args, &block); end

  def thrice(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  extend ::T::Sig
  def self.record(method_name); end
end

class RSpec::Mocks::AnyInstance::Chain
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
  def raise_does_not_implement_error(klass, method_name); end

  def raise_message_already_received_by_other_instance_error(method_name, object_inspect, invoked_instance); end

  def raise_not_supported_with_prepend_error(method_name, problem_mod); end

  def raise_second_instance_received_message_error(unfulfilled_expectations); end
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
end

class RSpec::Mocks::AnyInstance::ExpectationChain
  def expectation_fulfilled?(); end

  def initialize(*args, &block); end
end

class RSpec::Mocks::AnyInstance::ExpectationChain
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
  def initialize(targets); end

  def method_missing(*args, &block); end
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
end

class RSpec::Mocks::AnyInstance::MessageChains
  def [](method_name); end

  def add(method_name, chain); end

  def all_expectations_fulfilled?(); end

  def each_unfulfilled_expectation_matching(method_name, *args); end

  def has_expectation?(method_name); end

  def playback!(instance, method_name); end

  def received_expected_message!(method_name); end

  def remove_stub_chains_for!(method_name); end

  def unfulfilled_expectations(); end
end

class RSpec::Mocks::AnyInstance::MessageChains
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
  ExpectationInvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
end

class RSpec::Mocks::AnyInstance::Proxy
  def expect_chain(*chain, &block); end

  def initialize(recorder, target_proxies); end

  def klass(); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stub(method_name_or_method_map, &block); end

  def stub_chain(*chain, &block); end

  def unstub(method_name); end
end

class RSpec::Mocks::AnyInstance::Proxy
end

class RSpec::Mocks::AnyInstance::Recorder
  def already_observing?(method_name); end

  def build_alias_method_name(method_name); end

  def expect_chain(*method_names_and_optional_return_values, &block); end

  def initialize(klass); end

  def instance_that_received(method_name); end

  def klass(); end

  def message_chains(); end

  def notify_received_message(_object, message, args, _blk); end

  def playback!(instance, method_name); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stop_all_observation!(); end

  def stop_observing!(method_name); end

  def stub(method_name, &block); end

  def stub_chain(*method_names_and_optional_return_values, &block); end

  def stubs(); end

  def unstub(method_name); end

  def verify(); end
end

class RSpec::Mocks::AnyInstance::Recorder
end

class RSpec::Mocks::AnyInstance::StubChain
  def expectation_fulfilled?(); end
  EmptyInvocationOrder = ::T.let(nil, ::T.untyped)
  InvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::StubChain
end

class RSpec::Mocks::AnyInstance::StubChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::StubChainChain
end

module RSpec::Mocks::AnyInstance
  extend ::T::Sig
  def self.error_generator(); end
end

class RSpec::Mocks::ArgumentListMatcher
  MATCH_ALL = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::ArgumentMatchers
  extend ::T::Sig
end

module RSpec::Mocks::ExampleMethods::ExpectHost
  extend ::T::Sig
end

module RSpec::Mocks::ExampleMethods
  extend ::T::Sig
end

class RSpec::Mocks::ExpectChain
end

class RSpec::Mocks::ExpectChain
  def self.expect_chain_on(object, *chain, &blk); end
end

module RSpec::Mocks::ExpectationTargetMethods
  extend ::T::Sig
end

class RSpec::Mocks::MarshalExtension
end

class RSpec::Mocks::MarshalExtension
  def self.patch!(); end

  def self.unpatch!(); end
end

class RSpec::Mocks::Matchers::HaveReceived
  include ::RSpec::Mocks::Matchers::Matcher
  def at_least(*args); end

  def at_most(*args); end

  def description(); end

  def does_not_match?(subject); end

  def exactly(*args); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(method_name, &block); end

  def matches?(subject, &block); end

  def name(); end

  def once(*args); end

  def ordered(*args); end

  def setup_allowance(_subject, &_block); end

  def setup_any_instance_allowance(_subject, &_block); end

  def setup_any_instance_expectation(_subject, &_block); end

  def setup_any_instance_negative_expectation(_subject, &_block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args); end

  def times(*args); end

  def twice(*args); end

  def with(*args); end
  ARGS_CONSTRAINTS = ::T.let(nil, ::T.untyped)
  CONSTRAINTS = ::T.let(nil, ::T.untyped)
  COUNT_CONSTRAINTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Matchers::HaveReceived
end

module RSpec::Mocks::Matchers::Matcher
  extend ::T::Sig
end

class RSpec::Mocks::Matchers::Receive
  include ::RSpec::Mocks::Matchers::Matcher
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def description(); end

  def does_not_match?(subject, &block); end

  def exactly(*args, &block); end

  def initialize(message, block); end

  def matches?(subject, &block); end

  def name(); end

  def never(*args, &block); end

  def once(*args, &block); end

  def ordered(*args, &block); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_any_instance_negative_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
  def description_for(verb); end

  def initialize(message); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
end

class RSpec::Mocks::Matchers::Receive
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
  include ::RSpec::Mocks::Matchers::Matcher
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_yield(*args, &block); end

  def description(); end

  def does_not_match?(*_args); end

  def initialize(chain, &block); end

  def matches?(subject, &block); end

  def name(); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(*_args); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
end

class RSpec::Mocks::Matchers::ReceiveMessages
  include ::RSpec::Mocks::Matchers::Matcher
  def description(); end

  def does_not_match?(_subject); end

  def initialize(message_return_value_hash); end

  def matches?(subject); end

  def name(); end

  def setup_allowance(subject); end

  def setup_any_instance_allowance(subject); end

  def setup_any_instance_expectation(subject); end

  def setup_expectation(subject); end

  def setup_negative_expectation(_subject); end

  def warn_about_block(); end
end

class RSpec::Mocks::Matchers::ReceiveMessages
end

module RSpec::Mocks::Matchers
  extend ::T::Sig
end

class RSpec::Mocks::MessageChain
  def block(); end

  def chain(); end

  def initialize(object, *chain, &blk); end

  def object(); end

  def setup_chain(); end
end

class RSpec::Mocks::MessageChain
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
  extend ::T::Sig
end

class RSpec::Mocks::ObjectReference
  MODULE_NAME_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::ObjectVerifyingDoubleMethods
  extend ::T::Sig
end

module RSpec::Mocks::PartialClassDoubleProxyMethods
  extend ::T::Sig
end

class RSpec::Mocks::Proxy
  DEFAULT_MESSAGE_EXPECTATION_OPTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::StubChain
end

class RSpec::Mocks::StubChain
  def self.stub_chain_on(object, *chain, &blk); end
end

module RSpec::Mocks::Syntax
  extend ::T::Sig
end

module RSpec::Mocks::TargetDelegationClassMethods
  extend ::T::Sig
end

module RSpec::Mocks::TargetDelegationInstanceMethods
  extend ::T::Sig
end

module RSpec::Mocks::TestDouble
  extend ::T::Sig
end

module RSpec::Mocks::TestDoubleFormatter
  extend ::T::Sig
end

module RSpec::Mocks::VerifyingDouble::SilentIO
  extend ::T::Sig
end

module RSpec::Mocks::VerifyingDouble
  extend ::T::Sig
end

module RSpec::Mocks::VerifyingProxyMethods
  extend ::T::Sig
end

module RSpec::Mocks::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::Version
  extend ::T::Sig
end

module RSpec::Mocks
  extend ::T::Sig
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  extend ::T::Sig
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::Differ
end

class RSpec::Support::EncodedString
  ENCODE_NO_CONVERTER = ::T.let(nil, ::T.untyped)
  ENCODE_UNCONVERTABLE_BYTES = ::T.let(nil, ::T.untyped)
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::FuzzyMatcher
  extend ::T::Sig
end

class RSpec::Support::MethodSignature
  INFINITY = ::T.let(nil, ::T.untyped)
end

RSpec::Support::Mutex = Thread::Mutex

module RSpec::Support::OS
  extend ::T::Sig
end

class RSpec::Support::ObjectFormatter
  ELLIPSIS = ::T.let(nil, ::T.untyped)
  INSPECTOR_CLASSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::TimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  OBJECT_ID_FORMAT = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::RecursiveConstMethods
  extend ::T::Sig
end

module RSpec::Support::Ruby
  extend ::T::Sig
end

module RSpec::Support::RubyFeatures
  extend ::T::Sig
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::Version
  extend ::T::Sig
end

module RSpec::Support::Warnings
  extend ::T::Sig
end

module RSpec::Support
  extend ::T::Sig
end

module RSpec::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Version
  extend ::T::Sig
end

module RSpec
  extend ::T::Sig
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  extend ::T::Sig
end

module Rake::Cloneable
  extend ::T::Sig
end

module Rake::DSL
  include ::FileUtils::StreamUtils_
end

module Rake::DSL
  extend ::T::Sig
end

class Rake::FileList
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  include ::FileUtils::StreamUtils_
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::FileUtils::StreamUtils_
  extend ::T::Sig
end

class Rake::InvocationChain
  EMPTY = ::T.let(nil, ::T.untyped)
end

module Rake::InvocationExceptionMixin
  extend ::T::Sig
end

class Rake::LinkedList
  EMPTY = ::T.let(nil, ::T.untyped)
end

module Rake::PrivateReader::ClassMethods
  extend ::T::Sig
end

module Rake::PrivateReader
  extend ::T::Sig
end

class Rake::Promise
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Scope
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::TaskLib
  include ::FileUtils::StreamUtils_
end

module Rake::TaskManager
  extend ::T::Sig
end

module Rake::TraceOutput
  extend ::T::Sig
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake::Version
  extend ::T::Sig
end

module Rake::Win32
  extend ::T::Sig
end

module Rake
  extend ::FileUtils::StreamUtils_
  extend ::T::Sig
end

RakeFileUtils = Rake::FileUtilsExt

class Random
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end

  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

module Random::Formatter
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class Random
  extend ::T::Sig
  def self.urandom(_); end
end

class Range
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class Range
  extend ::T::Sig
end

class RangeError
  extend ::T::Sig
end

class Rational
  extend ::T::Sig
end

module RbConfig
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.expand(val, config=T.unsafe(nil)); end

  def self.ruby(); end
end

class Regexp
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def match?(*_); end
end

class Regexp
  extend ::T::Sig
  def self.union(*_); end
end

class RegexpError
  extend ::T::Sig
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end

  def fetch_resource(name, typeclass); end

  def lazy_initialize(); end

  def make_tcp_requester(host, port); end

  def make_udp_requester(); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def generate_candidates(name); end

  def generate_timeouts(); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def nameserver_port(); end

  def resolv(name); end

  def single?(); end

  def timeouts=(values); end
  InitialTimeout = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config
  def self.default_config_hash(filename=T.unsafe(nil)); end

  def self.parse_resolv_conf(filename); end
end

module Resolv::DNS::Label
end

class Resolv::DNS::Label::Str
  def ==(other); end

  def downcase(); end

  def eql?(other); end

  def initialize(string); end

  def string(); end
end

class Resolv::DNS::Label::Str
end

module Resolv::DNS::Label
  extend ::T::Sig
  def self.split(arg); end
end

class Resolv::DNS::Message
  def ==(other); end

  def aa(); end

  def aa=(aa); end

  def add_additional(name, ttl, data); end

  def add_answer(name, ttl, data); end

  def add_authority(name, ttl, data); end

  def add_question(name, typeclass); end

  def additional(); end

  def answer(); end

  def authority(); end

  def each_additional(); end

  def each_answer(); end

  def each_authority(); end

  def each_question(); end

  def each_resource(); end

  def encode(); end

  def id(); end

  def id=(id); end

  def initialize(id=T.unsafe(nil)); end

  def opcode(); end

  def opcode=(opcode); end

  def qr(); end

  def qr=(qr); end

  def question(); end

  def ra(); end

  def ra=(ra); end

  def rcode(); end

  def rcode=(rcode); end

  def rd(); end

  def rd=(rd); end

  def tc(); end

  def tc=(tc); end
end

class Resolv::DNS::Message::MessageDecoder
  def get_bytes(len=T.unsafe(nil)); end

  def get_label(); end

  def get_labels(); end

  def get_length16(); end

  def get_name(); end

  def get_question(); end

  def get_rr(); end

  def get_string(); end

  def get_string_list(); end

  def get_unpack(template); end

  def initialize(data); end
end

class Resolv::DNS::Message::MessageDecoder
end

class Resolv::DNS::Message::MessageEncoder
  def put_bytes(d); end

  def put_label(d); end

  def put_labels(d); end

  def put_length16(); end

  def put_name(d); end

  def put_pack(template, *d); end

  def put_string(d); end

  def put_string_list(ds); end
end

class Resolv::DNS::Message::MessageEncoder
end

class Resolv::DNS::Message
  def self.decode(m); end
end

class Resolv::DNS::Name
  def ==(other); end

  def [](i); end

  def eql?(other); end

  def length(); end

  def to_a(); end
end

module Resolv::DNS::OpCode
  IQuery = ::T.let(nil, ::T.untyped)
  Notify = ::T.let(nil, ::T.untyped)
  Query = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  Update = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::OpCode
  extend ::T::Sig
end

class Resolv::DNS::Query
  def encode_rdata(msg); end
end

class Resolv::DNS::Query
  def self.decode_rdata(msg); end
end

module Resolv::DNS::RCode
  BADALG = ::T.let(nil, ::T.untyped)
  BADKEY = ::T.let(nil, ::T.untyped)
  BADMODE = ::T.let(nil, ::T.untyped)
  BADNAME = ::T.let(nil, ::T.untyped)
  BADSIG = ::T.let(nil, ::T.untyped)
  BADTIME = ::T.let(nil, ::T.untyped)
  BADVERS = ::T.let(nil, ::T.untyped)
  FormErr = ::T.let(nil, ::T.untyped)
  NXDomain = ::T.let(nil, ::T.untyped)
  NXRRSet = ::T.let(nil, ::T.untyped)
  NoError = ::T.let(nil, ::T.untyped)
  NotAuth = ::T.let(nil, ::T.untyped)
  NotImp = ::T.let(nil, ::T.untyped)
  NotZone = ::T.let(nil, ::T.untyped)
  Refused = ::T.let(nil, ::T.untyped)
  ServFail = ::T.let(nil, ::T.untyped)
  YXDomain = ::T.let(nil, ::T.untyped)
  YXRRSet = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::RCode
  extend ::T::Sig
end

class Resolv::DNS::Requester
  def close(); end

  def request(sender, tout); end

  def sender_for(addr, msg); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
end

class Resolv::DNS::Requester::ConnectedUDP
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::Sender
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::TCP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::TCP::Sender
end

class Resolv::DNS::Requester::TCP
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def data(); end

  def initialize(msg, data, sock, host, port); end

  def send(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
end

class Resolv::DNS::Requester::UnconnectedUDP
end

class Resolv::DNS::Requester
end

class Resolv::DNS::Resource
  def ==(other); end

  def eql?(other); end
  ClassHash = ::T.let(nil, ::T.untyped)
  ClassInsensitiveTypes = ::T.let(nil, ::T.untyped)
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::ANY
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::CNAME
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Generic
  def self.create(type_value, class_value); end
end

class Resolv::DNS::Resource::HINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::Resource::IN
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::A
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::AAAA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
end

class Resolv::DNS::Resource::IN::CNAME
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::CNAME
end

class Resolv::DNS::Resource::IN::HINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::HINFO
end

class Resolv::DNS::Resource::IN::LOC
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::LOC
end

class Resolv::DNS::Resource::IN::MINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MINFO
end

class Resolv::DNS::Resource::IN::MX
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MX
end

class Resolv::DNS::Resource::IN::NS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::NS
end

class Resolv::DNS::Resource::IN::PTR
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::PTR
end

class Resolv::DNS::Resource::IN::SOA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::SOA
end

class Resolv::DNS::Resource::IN::SRV
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
end

class Resolv::DNS::Resource::IN::WKS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::Resource::IN
  extend ::T::Sig
end

class Resolv::DNS::Resource::LOC
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MX
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::NS
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::PTR
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::SOA
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::TXT
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource
  def self.get_class(type_value, class_value); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end

  def self.rangerand(range); end
end

class Resolv::Hosts
  def lazy_initialize(); end
end

class Resolv::IPv4
  def ==(other); end

  def eql?(other); end
end

class Resolv::IPv6
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Alt
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Coord
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Size
  def ==(other); end

  def eql?(other); end
end

module Resolv::LOC
  extend ::T::Sig
end

class RubyVM
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class RubyVM::InstructionSequence
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  extend ::T::Sig
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

class RubyVM
  extend ::T::Sig
  def self.stat(*_); end
end

class RuntimeError
  extend ::T::Sig
end

module SWIG
end

class SWIG::Pointer
end

class SWIG::Pointer
end

class SWIG::TYPE_p_allocator_type
end

class SWIG::TYPE_p_allocator_type
end

class SWIG::TYPE_p_char
end

class SWIG::TYPE_p_char
end

class SWIG::TYPE_p_const_reference
end

class SWIG::TYPE_p_const_reference
end

class SWIG::TYPE_p_difference_type
end

class SWIG::TYPE_p_difference_type
end

class SWIG::TYPE_p_first_type
end

class SWIG::TYPE_p_first_type
end

class SWIG::TYPE_p_int
end

class SWIG::TYPE_p_int
end

class SWIG::TYPE_p_key_type
end

class SWIG::TYPE_p_key_type
end

class SWIG::TYPE_p_long_long
end

class SWIG::TYPE_p_long_long
end

class SWIG::TYPE_p_mapped_type
end

class SWIG::TYPE_p_mapped_type
end

class SWIG::TYPE_p_p_void
end

class SWIG::TYPE_p_p_void
end

class SWIG::TYPE_p_reference
end

class SWIG::TYPE_p_reference
end

class SWIG::TYPE_p_second_type
end

class SWIG::TYPE_p_second_type
end

class SWIG::TYPE_p_short
end

class SWIG::TYPE_p_short
end

class SWIG::TYPE_p_signed_char
end

class SWIG::TYPE_p_signed_char
end

class SWIG::TYPE_p_size_type
end

class SWIG::TYPE_p_size_type
end

class SWIG::TYPE_p_std__allocatorT_std__pairT_std__string_const_std__string_t_t
end

class SWIG::TYPE_p_std__allocatorT_std__pairT_std__string_const_std__string_t_t
end

class SWIG::TYPE_p_std__allocatorT_std__string_t
end

class SWIG::TYPE_p_std__allocatorT_std__string_t
end

class SWIG::TYPE_p_std__allocatorT_storage__BcacheCset_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__BcacheCset_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__BcacheCset_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__BcacheCset_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Bcache_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Bcache_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Bcache_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Bcache_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__BlkDevice_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__BlkDevice_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__BlkDevice_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__BlkDevice_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__BlkFilesystem_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__BlkFilesystem_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__BlkFilesystem_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__BlkFilesystem_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__BtrfsSubvolume_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__BtrfsSubvolume_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__BtrfsSubvolume_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__BtrfsSubvolume_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__CompoundAction_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__CompoundAction_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__CompoundAction_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__CompoundAction_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Dasd_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Dasd_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Dasd_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Dasd_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Device_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Device_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Device_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Device_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Disk_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Disk_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Disk_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Disk_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__DmRaid_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__DmRaid_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__DmRaid_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__DmRaid_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Encryption_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Encryption_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Encryption_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Encryption_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Filesystem_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Filesystem_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Filesystem_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Filesystem_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Holder_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Holder_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Holder_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Holder_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Luks_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Luks_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Luks_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Luks_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__LvmLv_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__LvmLv_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__LvmLv_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__LvmLv_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__LvmPv_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__LvmPv_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__LvmPv_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__LvmPv_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__LvmVg_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__LvmVg_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__LvmVg_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__LvmVg_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__MdContainer_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__MdContainer_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__MdContainer_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__MdContainer_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__MdMember_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__MdMember_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__MdMember_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__MdMember_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__MdParity_t
end

class SWIG::TYPE_p_std__allocatorT_storage__MdParity_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Md_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Md_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Md_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Md_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__MountByType_t
end

class SWIG::TYPE_p_std__allocatorT_storage__MountByType_t
end

class SWIG::TYPE_p_std__allocatorT_storage__MountPoint_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__MountPoint_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__MountPoint_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__MountPoint_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Mountable_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Mountable_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Mountable_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Mountable_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Multipath_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Multipath_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Multipath_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Multipath_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Nfs_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Nfs_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Nfs_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Nfs_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Ntfs_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Ntfs_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Ntfs_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Ntfs_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__PartitionSlot_t
end

class SWIG::TYPE_p_std__allocatorT_storage__PartitionSlot_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Partition_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Partition_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Partition_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Partition_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Partitionable_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Partitionable_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Partitionable_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Partitionable_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__PtType_t
end

class SWIG::TYPE_p_std__allocatorT_storage__PtType_t
end

class SWIG::TYPE_p_std__allocatorT_storage__SimpleEtcCrypttabEntry_t
end

class SWIG::TYPE_p_std__allocatorT_storage__SimpleEtcCrypttabEntry_t
end

class SWIG::TYPE_p_std__allocatorT_storage__SimpleEtcFstabEntry_t
end

class SWIG::TYPE_p_std__allocatorT_storage__SimpleEtcFstabEntry_t
end

class SWIG::TYPE_p_std__allocatorT_storage__StrayBlkDevice_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__StrayBlkDevice_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__StrayBlkDevice_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__StrayBlkDevice_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Swap_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Swap_const_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Swap_p_t
end

class SWIG::TYPE_p_std__allocatorT_storage__Swap_p_t
end

class SWIG::TYPE_p_std__exception
end

class SWIG::TYPE_p_std__exception
end

class SWIG::TYPE_p_std__lessT_std__string_t
end

class SWIG::TYPE_p_std__lessT_std__string_t
end

class SWIG::TYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t
end

class SWIG::TYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t
end

class SWIG::TYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t__iterator
end

class SWIG::TYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t__iterator
end

class SWIG::TYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t__reverse_iterator
end

class SWIG::TYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t__reverse_iterator
end

class SWIG::TYPE_p_std__ostream
end

class SWIG::TYPE_p_std__ostream
end

class SWIG::TYPE_p_std__pairT_bool_std__string_t
end

class SWIG::TYPE_p_std__pairT_bool_std__string_t
end

class SWIG::TYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t
end

class SWIG::TYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Action__Base_const_p_std__allocatorT_storage__Action__Base_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Action__Base_const_p_std__allocatorT_storage__Action__Base_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__BcacheCset_const_p_std__allocatorT_storage__BcacheCset_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__BcacheCset_const_p_std__allocatorT_storage__BcacheCset_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__BcacheCset_p_std__allocatorT_storage__BcacheCset_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__BcacheCset_p_std__allocatorT_storage__BcacheCset_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Bcache_const_p_std__allocatorT_storage__Bcache_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Bcache_const_p_std__allocatorT_storage__Bcache_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Bcache_p_std__allocatorT_storage__Bcache_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Bcache_p_std__allocatorT_storage__Bcache_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__BlkDevice_const_p_std__allocatorT_storage__BlkDevice_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__BlkDevice_const_p_std__allocatorT_storage__BlkDevice_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__BlkDevice_p_std__allocatorT_storage__BlkDevice_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__BlkDevice_p_std__allocatorT_storage__BlkDevice_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__BlkFilesystem_const_p_std__allocatorT_storage__BlkFilesystem_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__BlkFilesystem_const_p_std__allocatorT_storage__BlkFilesystem_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__BlkFilesystem_p_std__allocatorT_storage__BlkFilesystem_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__BlkFilesystem_p_std__allocatorT_storage__BlkFilesystem_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__BtrfsSubvolume_const_p_std__allocatorT_storage__BtrfsSubvolume_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__BtrfsSubvolume_const_p_std__allocatorT_storage__BtrfsSubvolume_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__BtrfsSubvolume_p_std__allocatorT_storage__BtrfsSubvolume_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__BtrfsSubvolume_p_std__allocatorT_storage__BtrfsSubvolume_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__CompoundAction_const_p_std__allocatorT_storage__CompoundAction_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__CompoundAction_const_p_std__allocatorT_storage__CompoundAction_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__CompoundAction_p_std__allocatorT_storage__CompoundAction_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__CompoundAction_p_std__allocatorT_storage__CompoundAction_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Dasd_const_p_std__allocatorT_storage__Dasd_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Dasd_const_p_std__allocatorT_storage__Dasd_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Dasd_p_std__allocatorT_storage__Dasd_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Dasd_p_std__allocatorT_storage__Dasd_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Device_const_p_std__allocatorT_storage__Device_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Device_const_p_std__allocatorT_storage__Device_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Device_p_std__allocatorT_storage__Device_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Device_p_std__allocatorT_storage__Device_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Disk_const_p_std__allocatorT_storage__Disk_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Disk_const_p_std__allocatorT_storage__Disk_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Disk_p_std__allocatorT_storage__Disk_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Disk_p_std__allocatorT_storage__Disk_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__DmRaid_const_p_std__allocatorT_storage__DmRaid_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__DmRaid_const_p_std__allocatorT_storage__DmRaid_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__DmRaid_p_std__allocatorT_storage__DmRaid_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__DmRaid_p_std__allocatorT_storage__DmRaid_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Encryption_const_p_std__allocatorT_storage__Encryption_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Encryption_const_p_std__allocatorT_storage__Encryption_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Encryption_p_std__allocatorT_storage__Encryption_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Encryption_p_std__allocatorT_storage__Encryption_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Filesystem_const_p_std__allocatorT_storage__Filesystem_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Filesystem_const_p_std__allocatorT_storage__Filesystem_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Filesystem_p_std__allocatorT_storage__Filesystem_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Filesystem_p_std__allocatorT_storage__Filesystem_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Gpt_const_p_std__allocatorT_storage__Gpt_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Gpt_const_p_std__allocatorT_storage__Gpt_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Gpt_p_std__allocatorT_storage__Gpt_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Gpt_p_std__allocatorT_storage__Gpt_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Holder_const_p_std__allocatorT_storage__Holder_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Holder_const_p_std__allocatorT_storage__Holder_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Holder_p_std__allocatorT_storage__Holder_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Holder_p_std__allocatorT_storage__Holder_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Luks_const_p_std__allocatorT_storage__Luks_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Luks_const_p_std__allocatorT_storage__Luks_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Luks_p_std__allocatorT_storage__Luks_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Luks_p_std__allocatorT_storage__Luks_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__LvmLv_const_p_std__allocatorT_storage__LvmLv_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__LvmLv_const_p_std__allocatorT_storage__LvmLv_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__LvmLv_p_std__allocatorT_storage__LvmLv_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__LvmLv_p_std__allocatorT_storage__LvmLv_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__LvmPv_const_p_std__allocatorT_storage__LvmPv_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__LvmPv_const_p_std__allocatorT_storage__LvmPv_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__LvmPv_p_std__allocatorT_storage__LvmPv_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__LvmPv_p_std__allocatorT_storage__LvmPv_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__LvmVg_const_p_std__allocatorT_storage__LvmVg_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__LvmVg_const_p_std__allocatorT_storage__LvmVg_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__LvmVg_p_std__allocatorT_storage__LvmVg_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__LvmVg_p_std__allocatorT_storage__LvmVg_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__MdContainer_const_p_std__allocatorT_storage__MdContainer_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__MdContainer_const_p_std__allocatorT_storage__MdContainer_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__MdContainer_p_std__allocatorT_storage__MdContainer_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__MdContainer_p_std__allocatorT_storage__MdContainer_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__MdMember_const_p_std__allocatorT_storage__MdMember_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__MdMember_const_p_std__allocatorT_storage__MdMember_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__MdMember_p_std__allocatorT_storage__MdMember_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__MdMember_p_std__allocatorT_storage__MdMember_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__MdParity_std__allocatorT_storage__MdParity_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__MdParity_std__allocatorT_storage__MdParity_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Md_const_p_std__allocatorT_storage__Md_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Md_const_p_std__allocatorT_storage__Md_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Md_p_std__allocatorT_storage__Md_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Md_p_std__allocatorT_storage__Md_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__MountByType_std__allocatorT_storage__MountByType_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__MountByType_std__allocatorT_storage__MountByType_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__MountPoint_const_p_std__allocatorT_storage__MountPoint_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__MountPoint_const_p_std__allocatorT_storage__MountPoint_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__MountPoint_p_std__allocatorT_storage__MountPoint_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__MountPoint_p_std__allocatorT_storage__MountPoint_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Mountable_const_p_std__allocatorT_storage__Mountable_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Mountable_const_p_std__allocatorT_storage__Mountable_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Mountable_p_std__allocatorT_storage__Mountable_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Mountable_p_std__allocatorT_storage__Mountable_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Multipath_const_p_std__allocatorT_storage__Multipath_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Multipath_const_p_std__allocatorT_storage__Multipath_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Multipath_p_std__allocatorT_storage__Multipath_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Multipath_p_std__allocatorT_storage__Multipath_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Nfs_const_p_std__allocatorT_storage__Nfs_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Nfs_const_p_std__allocatorT_storage__Nfs_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Nfs_p_std__allocatorT_storage__Nfs_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Nfs_p_std__allocatorT_storage__Nfs_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Ntfs_const_p_std__allocatorT_storage__Ntfs_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Ntfs_const_p_std__allocatorT_storage__Ntfs_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Ntfs_p_std__allocatorT_storage__Ntfs_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Ntfs_p_std__allocatorT_storage__Ntfs_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__PartitionSlot_std__allocatorT_storage__PartitionSlot_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__PartitionSlot_std__allocatorT_storage__PartitionSlot_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Partition_const_p_std__allocatorT_storage__Partition_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Partition_const_p_std__allocatorT_storage__Partition_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Partition_p_std__allocatorT_storage__Partition_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Partition_p_std__allocatorT_storage__Partition_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Partitionable_const_p_std__allocatorT_storage__Partitionable_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Partitionable_const_p_std__allocatorT_storage__Partitionable_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Partitionable_p_std__allocatorT_storage__Partitionable_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Partitionable_p_std__allocatorT_storage__Partitionable_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__PtType_std__allocatorT_storage__PtType_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__PtType_std__allocatorT_storage__PtType_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Region_std__allocatorT_storage__Region_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Region_std__allocatorT_storage__Region_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__SimpleEtcCrypttabEntry_std__allocatorT_storage__SimpleEtcCrypttabEntry_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__SimpleEtcCrypttabEntry_std__allocatorT_storage__SimpleEtcCrypttabEntry_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__SimpleEtcFstabEntry_std__allocatorT_storage__SimpleEtcFstabEntry_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__SimpleEtcFstabEntry_std__allocatorT_storage__SimpleEtcFstabEntry_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__StrayBlkDevice_const_p_std__allocatorT_storage__StrayBlkDevice_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__StrayBlkDevice_const_p_std__allocatorT_storage__StrayBlkDevice_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__StrayBlkDevice_p_std__allocatorT_storage__StrayBlkDevice_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__StrayBlkDevice_p_std__allocatorT_storage__StrayBlkDevice_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Swap_const_p_std__allocatorT_storage__Swap_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Swap_const_p_std__allocatorT_storage__Swap_const_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Swap_p_std__allocatorT_storage__Swap_p_t_t
end

class SWIG::TYPE_p_std__vectorT_storage__Swap_p_std__allocatorT_storage__Swap_p_t_t
end

class SWIG::TYPE_p_storage__Aborted
end

class SWIG::TYPE_p_storage__Aborted
end

class SWIG::TYPE_p_storage__Actiongraph
end

class SWIG::TYPE_p_storage__Actiongraph
end

class SWIG::TYPE_p_storage__ActivateCallbacks
end

class SWIG::TYPE_p_storage__ActivateCallbacks
end

class SWIG::TYPE_p_storage__AlignError
end

class SWIG::TYPE_p_storage__AlignError
end

class SWIG::TYPE_p_storage__Alignment
end

class SWIG::TYPE_p_storage__Alignment
end

class SWIG::TYPE_p_storage__Arch
end

class SWIG::TYPE_p_storage__Arch
end

class SWIG::TYPE_p_storage__Bcache
end

class SWIG::TYPE_p_storage__Bcache
end

class SWIG::TYPE_p_storage__BcacheCset
end

class SWIG::TYPE_p_storage__BcacheCset
end

class SWIG::TYPE_p_storage__BlkDevice
end

class SWIG::TYPE_p_storage__BlkDevice
end

class SWIG::TYPE_p_storage__BlkFilesystem
end

class SWIG::TYPE_p_storage__BlkFilesystem
end

class SWIG::TYPE_p_storage__Btrfs
end

class SWIG::TYPE_p_storage__Btrfs
end

class SWIG::TYPE_p_storage__BtrfsSubvolume
end

class SWIG::TYPE_p_storage__BtrfsSubvolume
end

class SWIG::TYPE_p_storage__BtrfsSubvolumeNotFoundByPath
end

class SWIG::TYPE_p_storage__BtrfsSubvolumeNotFoundByPath
end

class SWIG::TYPE_p_storage__Callbacks
end

class SWIG::TYPE_p_storage__Callbacks
end

class SWIG::TYPE_p_storage__CheckCallbacks
end

class SWIG::TYPE_p_storage__CheckCallbacks
end

class SWIG::TYPE_p_storage__CodeLocation
end

class SWIG::TYPE_p_storage__CodeLocation
end

class SWIG::TYPE_p_storage__CommitCallbacks
end

class SWIG::TYPE_p_storage__CommitCallbacks
end

class SWIG::TYPE_p_storage__CommitOptions
end

class SWIG::TYPE_p_storage__CommitOptions
end

class SWIG::TYPE_p_storage__CompoundAction
end

class SWIG::TYPE_p_storage__CompoundAction
end

class SWIG::TYPE_p_storage__ContentInfo
end

class SWIG::TYPE_p_storage__ContentInfo
end

class SWIG::TYPE_p_storage__Dasd
end

class SWIG::TYPE_p_storage__Dasd
end

class SWIG::TYPE_p_storage__DasdPt
end

class SWIG::TYPE_p_storage__DasdPt
end

class SWIG::TYPE_p_storage__DeactivateStatus
end

class SWIG::TYPE_p_storage__DeactivateStatus
end

class SWIG::TYPE_p_storage__Device
end

class SWIG::TYPE_p_storage__Device
end

class SWIG::TYPE_p_storage__DeviceHasWrongType
end

class SWIG::TYPE_p_storage__DeviceHasWrongType
end

class SWIG::TYPE_p_storage__DeviceNotFound
end

class SWIG::TYPE_p_storage__DeviceNotFound
end

class SWIG::TYPE_p_storage__DeviceNotFoundByName
end

class SWIG::TYPE_p_storage__DeviceNotFoundByName
end

class SWIG::TYPE_p_storage__DeviceNotFoundBySid
end

class SWIG::TYPE_p_storage__DeviceNotFoundBySid
end

class SWIG::TYPE_p_storage__DeviceNotFoundByUuid
end

class SWIG::TYPE_p_storage__DeviceNotFoundByUuid
end

class SWIG::TYPE_p_storage__Devicegraph
end

class SWIG::TYPE_p_storage__Devicegraph
end

class SWIG::TYPE_p_storage__DifferentBlockSizes
end

class SWIG::TYPE_p_storage__DifferentBlockSizes
end

class SWIG::TYPE_p_storage__Disk
end

class SWIG::TYPE_p_storage__Disk
end

class SWIG::TYPE_p_storage__DmRaid
end

class SWIG::TYPE_p_storage__DmRaid
end

class SWIG::TYPE_p_storage__Encryption
end

class SWIG::TYPE_p_storage__Encryption
end

class SWIG::TYPE_p_storage__Environment
end

class SWIG::TYPE_p_storage__Environment
end

class SWIG::TYPE_p_storage__Exception
end

class SWIG::TYPE_p_storage__Exception
end

class SWIG::TYPE_p_storage__Ext
end

class SWIG::TYPE_p_storage__Ext
end

class SWIG::TYPE_p_storage__Ext2
end

class SWIG::TYPE_p_storage__Ext2
end

class SWIG::TYPE_p_storage__Ext3
end

class SWIG::TYPE_p_storage__Ext3
end

class SWIG::TYPE_p_storage__Ext4
end

class SWIG::TYPE_p_storage__Ext4
end

class SWIG::TYPE_p_storage__Filesystem
end

class SWIG::TYPE_p_storage__Filesystem
end

class SWIG::TYPE_p_storage__FilesystemUser
end

class SWIG::TYPE_p_storage__FilesystemUser
end

class SWIG::TYPE_p_storage__Gpt
end

class SWIG::TYPE_p_storage__Gpt
end

class SWIG::TYPE_p_storage__Holder
end

class SWIG::TYPE_p_storage__Holder
end

class SWIG::TYPE_p_storage__HolderAlreadyExists
end

class SWIG::TYPE_p_storage__HolderAlreadyExists
end

class SWIG::TYPE_p_storage__HolderHasWrongType
end

class SWIG::TYPE_p_storage__HolderHasWrongType
end

class SWIG::TYPE_p_storage__HolderNotFound
end

class SWIG::TYPE_p_storage__HolderNotFound
end

class SWIG::TYPE_p_storage__HolderNotFoundBySids
end

class SWIG::TYPE_p_storage__HolderNotFoundBySids
end

class SWIG::TYPE_p_storage__IOException
end

class SWIG::TYPE_p_storage__IOException
end

class SWIG::TYPE_p_storage__ImplicitPt
end

class SWIG::TYPE_p_storage__ImplicitPt
end

class SWIG::TYPE_p_storage__IndexOutOfRangeException
end

class SWIG::TYPE_p_storage__IndexOutOfRangeException
end

class SWIG::TYPE_p_storage__InvalidBlockSize
end

class SWIG::TYPE_p_storage__InvalidBlockSize
end

class SWIG::TYPE_p_storage__InvalidExtentSize
end

class SWIG::TYPE_p_storage__InvalidExtentSize
end

class SWIG::TYPE_p_storage__InvalidMountPointPath
end

class SWIG::TYPE_p_storage__InvalidMountPointPath
end

class SWIG::TYPE_p_storage__Iso9660
end

class SWIG::TYPE_p_storage__Iso9660
end

class SWIG::TYPE_p_storage__Jfs
end

class SWIG::TYPE_p_storage__Jfs
end

class SWIG::TYPE_p_storage__LockException
end

class SWIG::TYPE_p_storage__LockException
end

class SWIG::TYPE_p_storage__Logger
end

class SWIG::TYPE_p_storage__Logger
end

class SWIG::TYPE_p_storage__LogicException
end

class SWIG::TYPE_p_storage__LogicException
end

class SWIG::TYPE_p_storage__Luks
end

class SWIG::TYPE_p_storage__Luks
end

class SWIG::TYPE_p_storage__LvmLv
end

class SWIG::TYPE_p_storage__LvmLv
end

class SWIG::TYPE_p_storage__LvmLvNotFoundByLvName
end

class SWIG::TYPE_p_storage__LvmLvNotFoundByLvName
end

class SWIG::TYPE_p_storage__LvmPv
end

class SWIG::TYPE_p_storage__LvmPv
end

class SWIG::TYPE_p_storage__LvmVg
end

class SWIG::TYPE_p_storage__LvmVg
end

class SWIG::TYPE_p_storage__LvmVgNotFoundByVgName
end

class SWIG::TYPE_p_storage__LvmVgNotFoundByVgName
end

class SWIG::TYPE_p_storage__Md
end

class SWIG::TYPE_p_storage__Md
end

class SWIG::TYPE_p_storage__MdContainer
end

class SWIG::TYPE_p_storage__MdContainer
end

class SWIG::TYPE_p_storage__MdMember
end

class SWIG::TYPE_p_storage__MdMember
end

class SWIG::TYPE_p_storage__MdSubdevice
end

class SWIG::TYPE_p_storage__MdSubdevice
end

class SWIG::TYPE_p_storage__MdUser
end

class SWIG::TYPE_p_storage__MdUser
end

class SWIG::TYPE_p_storage__MountPoint
end

class SWIG::TYPE_p_storage__MountPoint
end

class SWIG::TYPE_p_storage__Mountable
end

class SWIG::TYPE_p_storage__Mountable
end

class SWIG::TYPE_p_storage__Msdos
end

class SWIG::TYPE_p_storage__Msdos
end

class SWIG::TYPE_p_storage__Multipath
end

class SWIG::TYPE_p_storage__Multipath
end

class SWIG::TYPE_p_storage__Nfs
end

class SWIG::TYPE_p_storage__Nfs
end

class SWIG::TYPE_p_storage__NfsNotFoundByServerAndPath
end

class SWIG::TYPE_p_storage__NfsNotFoundByServerAndPath
end

class SWIG::TYPE_p_storage__NoIntersection
end

class SWIG::TYPE_p_storage__NoIntersection
end

class SWIG::TYPE_p_storage__NotInside
end

class SWIG::TYPE_p_storage__NotInside
end

class SWIG::TYPE_p_storage__Ntfs
end

class SWIG::TYPE_p_storage__Ntfs
end

class SWIG::TYPE_p_storage__NullPointerException
end

class SWIG::TYPE_p_storage__NullPointerException
end

class SWIG::TYPE_p_storage__OutOfMemoryException
end

class SWIG::TYPE_p_storage__OutOfMemoryException
end

class SWIG::TYPE_p_storage__OverflowException
end

class SWIG::TYPE_p_storage__OverflowException
end

class SWIG::TYPE_p_storage__ParseException
end

class SWIG::TYPE_p_storage__ParseException
end

class SWIG::TYPE_p_storage__Partition
end

class SWIG::TYPE_p_storage__Partition
end

class SWIG::TYPE_p_storage__PartitionSlot
end

class SWIG::TYPE_p_storage__PartitionSlot
end

class SWIG::TYPE_p_storage__PartitionTable
end

class SWIG::TYPE_p_storage__PartitionTable
end

class SWIG::TYPE_p_storage__Partitionable
end

class SWIG::TYPE_p_storage__Partitionable
end

class SWIG::TYPE_p_storage__ProbeCallbacks
end

class SWIG::TYPE_p_storage__ProbeCallbacks
end

class SWIG::TYPE_p_storage__Region
end

class SWIG::TYPE_p_storage__Region
end

class SWIG::TYPE_p_storage__Reiserfs
end

class SWIG::TYPE_p_storage__Reiserfs
end

class SWIG::TYPE_p_storage__RemoteCallbacks
end

class SWIG::TYPE_p_storage__RemoteCallbacks
end

class SWIG::TYPE_p_storage__RemoteCommand
end

class SWIG::TYPE_p_storage__RemoteCommand
end

class SWIG::TYPE_p_storage__RemoteFile
end

class SWIG::TYPE_p_storage__RemoteFile
end

class SWIG::TYPE_p_storage__ResizeInfo
end

class SWIG::TYPE_p_storage__ResizeInfo
end

class SWIG::TYPE_p_storage__Silencer
end

class SWIG::TYPE_p_storage__Silencer
end

class SWIG::TYPE_p_storage__SimpleEtcCrypttabEntry
end

class SWIG::TYPE_p_storage__SimpleEtcCrypttabEntry
end

class SWIG::TYPE_p_storage__SimpleEtcFstabEntry
end

class SWIG::TYPE_p_storage__SimpleEtcFstabEntry
end

class SWIG::TYPE_p_storage__SpaceInfo
end

class SWIG::TYPE_p_storage__SpaceInfo
end

class SWIG::TYPE_p_storage__Storage
end

class SWIG::TYPE_p_storage__Storage
end

class SWIG::TYPE_p_storage__StrayBlkDevice
end

class SWIG::TYPE_p_storage__StrayBlkDevice
end

class SWIG::TYPE_p_storage__Subdevice
end

class SWIG::TYPE_p_storage__Subdevice
end

class SWIG::TYPE_p_storage__Swap
end

class SWIG::TYPE_p_storage__Swap
end

class SWIG::TYPE_p_storage__Topology
end

class SWIG::TYPE_p_storage__Topology
end

class SWIG::TYPE_p_storage__Udf
end

class SWIG::TYPE_p_storage__Udf
end

class SWIG::TYPE_p_storage__UnsupportedException
end

class SWIG::TYPE_p_storage__UnsupportedException
end

class SWIG::TYPE_p_storage__User
end

class SWIG::TYPE_p_storage__User
end

class SWIG::TYPE_p_storage__Vfat
end

class SWIG::TYPE_p_storage__Vfat
end

class SWIG::TYPE_p_storage__WrongNumberOfChildren
end

class SWIG::TYPE_p_storage__WrongNumberOfChildren
end

class SWIG::TYPE_p_storage__WrongNumberOfParents
end

class SWIG::TYPE_p_storage__WrongNumberOfParents
end

class SWIG::TYPE_p_storage__Xfs
end

class SWIG::TYPE_p_storage__Xfs
end

class SWIG::TYPE_p_swig__ConstIterator
end

class SWIG::TYPE_p_swig__ConstIterator
end

class SWIG::TYPE_p_swig__GC_VALUE
end

class SWIG::TYPE_p_swig__GC_VALUE
end

class SWIG::TYPE_p_swig__Iterator
end

class SWIG::TYPE_p_swig__Iterator
end

class SWIG::TYPE_p_unsigned_char
end

class SWIG::TYPE_p_unsigned_char
end

class SWIG::TYPE_p_unsigned_int
end

class SWIG::TYPE_p_unsigned_int
end

class SWIG::TYPE_p_unsigned_long_long
end

class SWIG::TYPE_p_unsigned_long_long
end

class SWIG::TYPE_p_unsigned_short
end

class SWIG::TYPE_p_unsigned_short
end

class SWIG::TYPE_p_value_type
end

class SWIG::TYPE_p_value_type
end

class SWIG::TYPE_p_void
end

class SWIG::TYPE_p_void
end

class SWIG::TYPE_p_xmlNode
end

class SWIG::TYPE_p_xmlNode
end

module SWIG
  extend ::T::Sig
end

ScanError = StringScanner::Error

module Scanf
end

class Scanf::FormatSpecifier
  def conversion(); end

  def count_space?(); end

  def initialize(str); end

  def letter(); end

  def match(str); end

  def matched(); end

  def matched_string(); end

  def mid_match?(); end

  def re_string(); end

  def to_re(); end

  def width(); end
end

class Scanf::FormatSpecifier
end

class Scanf::FormatString
  def initialize(str); end

  def last_match_tried(); end

  def last_spec(); end

  def last_spec_tried(); end

  def match(str); end

  def matched_count(); end

  def prune(n=T.unsafe(nil)); end

  def space(); end

  def spec_count(); end

  def string_left(); end
  REGEX = ::T.let(nil, ::T.untyped)
  SPECIFIERS = ::T.let(nil, ::T.untyped)
end

class Scanf::FormatString
end

module Scanf
  extend ::T::Sig
end

class ScriptError
  extend ::T::Sig
end

module SecureRandom
end

module SecureRandom
  extend ::Random::Formatter
  extend ::T::Sig
  def self.bytes(n); end
end

class SecurityError
  extend ::T::Sig
end

class Set
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class Set
  extend ::T::Sig
end

module Shellwords
end

module Shellwords
  extend ::T::Sig
  def self.escape(str); end

  def self.join(array); end

  def self.shellescape(str); end

  def self.shelljoin(array); end

  def self.shellsplit(line); end

  def self.shellwords(line); end

  def self.split(line); end
end

module Signal
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class SignalException
  def signm(); end

  def signo(); end
end

class SignalException
  extend ::T::Sig
end

module SimpleCov
  VERSION = ::T.let(nil, ::T.untyped)
end

module SimpleCov::CommandGuesser
  extend ::T::Sig
end

module SimpleCov::Configuration
  extend ::T::Sig
end

module SimpleCov::ExitCodes
  EXCEPTION = ::T.let(nil, ::T.untyped)
  MAXIMUM_COVERAGE_DROP = ::T.let(nil, ::T.untyped)
  MINIMUM_COVERAGE = ::T.let(nil, ::T.untyped)
  SUCCESS = ::T.let(nil, ::T.untyped)
end

module SimpleCov::ExitCodes
  extend ::T::Sig
end

class SimpleCov::Formatter::HTMLFormatter
  VERSION = ::T.let(nil, ::T.untyped)
end

module SimpleCov::Formatter::MultiFormatter::InstanceMethods
  extend ::T::Sig
end

module SimpleCov::Formatter
  extend ::T::Sig
end

module SimpleCov::LastRun
  extend ::T::Sig
end

class SimpleCov::LinesClassifier
  COMMENT_LINE = ::T.let(nil, ::T.untyped)
  NOT_RELEVANT = ::T.let(nil, ::T.untyped)
  RELEVANT = ::T.let(nil, ::T.untyped)
  WHITESPACE_LINE = ::T.let(nil, ::T.untyped)
  WHITESPACE_OR_COMMENT_LINE = ::T.let(nil, ::T.untyped)
end

module SimpleCov::RawCoverage
  extend ::T::Sig
end

module SimpleCov::ResultMerger
  extend ::T::Sig
end

module SimpleCov
  extend ::T::Sig
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class SimpleDelegator
  extend ::T::Sig
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

module SingleForwardable
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton::SingletonClassMethods
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

module Singleton
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.__init__(klass); end
end

SizedQueue = Thread::SizedQueue

class Socket
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Socket::AncillaryData
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class Socket::AncillaryData
  extend ::T::Sig
end

module Socket::Constants
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class Socket::Ifaddr
  extend ::T::Sig
end

class Socket::Option
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class Socket::Option
  extend ::T::Sig
end

class Socket::UDPSource
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class Socket::UDPSource
  extend ::T::Sig
end

class Socket
  extend ::T::Sig
end

class SocketError
  extend ::T::Sig
end

class Sorbet
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class Sorbet::Private::ConstantLookupCache
  def all_module_aliases(); end

  def all_module_names(); end

  def all_named_modules(); end

  def class_by_name(name); end

  def name_by_class(klass); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def aliases(); end

  def aliases=(_); end

  def const(); end

  def const=(_); end

  def const_name(); end

  def const_name=(_); end

  def found_name(); end

  def found_name=(_); end

  def owner(); end

  def owner=(_); end

  def primary_name(); end

  def primary_name=(_); end
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::ConstantLookupCache
end

class Sorbet::Private::CreateConfig
  include ::Sorbet::Private::StepInterface
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::CreateConfig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::FetchRBIs
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
  SORBET_RBI_LIST = ::T.let(nil, ::T.untyped)
  SORBET_RBI_SORBET_TYPED = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REPO = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REVISION = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FetchRBIs
  def self.fetch_sorbet_typed(); end

  def self.main(); end

  def self.matching_version_directories(root, version); end

  def self.output_file(); end

  def self.paths_for_gem_version(gemspec); end

  def self.paths_for_ruby_version(ruby_version); end

  def self.paths_within_gem_sources(gemspec); end

  def self.serialize_rbi_list(gem_source_paths); end

  def self.vendor_rbis_within_paths(vendor_paths); end
end

module Sorbet::Private::GemGeneratorTracepoint
  include ::Sorbet::Private::StepInterface
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def defs(); end

  def defs=(_); end

  def id(); end

  def id=(_); end

  def klass(); end

  def klass=(_); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
  def initialize(files:, delegate_classes:); end

  def serialize(output_dir); end
  BAD_METHODS = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
end

module Sorbet::Private::GemGeneratorTracepoint::Tracer::ClassOverride
  def new(*_); end
end

module Sorbet::Private::GemGeneratorTracepoint::Tracer::ClassOverride
  extend ::T::Sig
end

module Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def include(mod, *smth); end
end

module Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  extend ::T::Sig
end

module Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def extend(mod, *args); end
end

module Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  extend ::T::Sig
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
  def self.add_to_context(item); end

  def self.disable_tracepoints(); end

  def self.finish(); end

  def self.install_tracepoints(); end

  def self.method_added(mod, method, singleton); end

  def self.module_created(mod); end

  def self.module_extended(extended, extender); end

  def self.module_included(included, includer); end

  def self.pre_cache_module_methods(); end

  def self.register_delegate_class(klass, delegate); end

  def self.start(); end

  def self.trace(); end

  def self.trace_results(); end
end

module Sorbet::Private::GemGeneratorTracepoint
  extend ::T::Sig
  def self.main(output_dir=T.unsafe(nil)); end

  def self.output_file(); end
end

class Sorbet::Private::GemLoader
  GEM_LOADER = ::T.let(nil, ::T.untyped)
  NO_GEM = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemLoader
  def self.my_require(gem); end

  def self.require_all_gems(); end

  def self.require_gem(gem); end
end

class Sorbet::Private::HiddenMethodFinder
  include ::Sorbet::Private::StepInterface
  def all_modules_and_aliases(); end

  def capture_stderr(); end

  def constant_cache(); end

  def gen_source_rbi(classes, aliases); end

  def hidden_diff(); end

  def hidden_json(); end

  def hidden_rbi(); end

  def hidden_splits(); end

  def looks_like_stub_name(name); end

  def main(); end

  def mkdir(); end

  def read_constants(); end

  def real_name(mod); end

  def remove_temp_files(); end

  def require_everything(); end

  def serialize_alias(source_entry, rbi_entry, my_klass, source_symbols, rbi_symbols); end

  def serialize_class(source_entry, rbi_entry, klass, source_symbols, rbi_symbols, source_by_name); end

  def serialize_constants(source, rbi, klass, is_singleton, source_symbols, rbi_symbols); end

  def symbols_id_to_name(entry, prefix); end

  def write_constants(); end

  def write_diff(source, rbi); end
  BLACKLIST = ::T.let(nil, ::T.untyped)
  DIFF_RBI = ::T.let(nil, ::T.untyped)
  ERRORS_RBI = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  HIDDEN_RBI = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  TMP_PATH = ::T.let(nil, ::T.untyped)
  TMP_RBI = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::HiddenMethodFinder
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private::Main
end

module Sorbet::Private::Main
  extend ::T::Sig
  def self.cyan(msg); end

  def self.emojify(emoji, msg); end

  def self.main(argv); end

  def self.make_step(step); end

  def self.parse_command(argv); end

  def self.yellow(msg); end
end

module Sorbet::Private::RealStdlib
end

module Sorbet::Private::RealStdlib
  extend ::T::Sig
  def self.real_ancestors(mod); end

  def self.real_autoload?(o, klass); end

  def self.real_const_get(obj, const, arg); end

  def self.real_constants(mod); end

  def self.real_eqeq(obj, other); end

  def self.real_hash(o); end

  def self.real_instance_methods(mod, arg); end

  def self.real_is_a?(o, klass); end

  def self.real_name(o); end

  def self.real_object_id(o); end

  def self.real_private_instance_methods(mod, arg); end

  def self.real_singleton_class(obj); end

  def self.real_singleton_methods(mod, arg); end

  def self.real_spaceship(obj, arg); end

  def self.real_superclass(o); end
end

class Sorbet::Private::RequireEverything
end

class Sorbet::Private::RequireEverything
  def self.excluded_rails_files(); end

  def self.load_bundler(); end

  def self.load_rails(); end

  def self.my_require(abs_path, numerator, denominator); end

  def self.patch_kernel(); end

  def self.rails?(); end

  def self.require_all_files(); end

  def self.require_everything(); end
end

class Sorbet::Private::Serialize
  def alias(base, other_name); end

  def ancestor_has_method(method, klass); end

  def blacklisted_method(method); end

  def class_or_module(class_name); end

  def comparable?(value); end

  def constant(const, value); end

  def from_method(method); end

  def initialize(constant_cache); end

  def serialize_method(method, static=T.unsafe(nil), with_sig: T.unsafe(nil)); end

  def serialize_sig(parameters); end

  def to_sig(kind, name); end

  def valid_class_name(name); end

  def valid_method_name(name); end
  BLACKLIST_CONSTANTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::Serialize
  def self.header(typed=T.unsafe(nil), subcommand=T.unsafe(nil)); end
end

module Sorbet::Private::Status
end

module Sorbet::Private::Status
  extend ::T::Sig
  def self.done(); end

  def self.say(message, print_without_tty: T.unsafe(nil)); end
end

module Sorbet::Private::StepInterface
end

module Sorbet::Private::StepInterface
  extend ::T::Sig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::SuggestTyped
  include ::Sorbet::Private::StepInterface
end

class Sorbet::Private::SuggestTyped
  def self.main(); end

  def self.output_file(); end

  def self.suggest_typed(); end
end

class Sorbet::Private::TodoRBI
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::TodoRBI
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class Sorbet
  extend ::T::Sig
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  extend ::T::Sig
  def self.setup(); end
end

class StandardError
  extend ::T::Sig
end

class StopIteration
  def result(); end
end

class StopIteration
  extend ::T::Sig
end

module Storage
  AlignPolicy_ALIGN_END = ::T.let(nil, ::T.untyped)
  AlignPolicy_ALIGN_START_AND_END = ::T.let(nil, ::T.untyped)
  AlignPolicy_ALIGN_START_KEEP_END = ::T.let(nil, ::T.untyped)
  AlignPolicy_ALIGN_START_KEEP_SIZE = ::T.let(nil, ::T.untyped)
  AlignPolicy_KEEP_END = ::T.let(nil, ::T.untyped)
  AlignPolicy_KEEP_SIZE = ::T.let(nil, ::T.untyped)
  AlignPolicy_KEEP_START_ALIGN_END = ::T.let(nil, ::T.untyped)
  AlignType_OPTIMAL = ::T.let(nil, ::T.untyped)
  AlignType_REQUIRED = ::T.let(nil, ::T.untyped)
  DasdFormat_CDL = ::T.let(nil, ::T.untyped)
  DasdFormat_LDL = ::T.let(nil, ::T.untyped)
  DasdFormat_NONE = ::T.let(nil, ::T.untyped)
  DasdType_ECKD = ::T.let(nil, ::T.untyped)
  DasdType_FBA = ::T.let(nil, ::T.untyped)
  DasdType_UNKNOWN = ::T.let(nil, ::T.untyped)
  EncryptionType_LUKS = ::T.let(nil, ::T.untyped)
  EncryptionType_NONE = ::T.let(nil, ::T.untyped)
  EncryptionType_TWOFISH = ::T.let(nil, ::T.untyped)
  EncryptionType_TWOFISH256_OLD = ::T.let(nil, ::T.untyped)
  EncryptionType_TWOFISH_OLD = ::T.let(nil, ::T.untyped)
  EncryptionType_UNKNOWN = ::T.let(nil, ::T.untyped)
  FsType_AUTO = ::T.let(nil, ::T.untyped)
  FsType_BTRFS = ::T.let(nil, ::T.untyped)
  FsType_EXT2 = ::T.let(nil, ::T.untyped)
  FsType_EXT3 = ::T.let(nil, ::T.untyped)
  FsType_EXT4 = ::T.let(nil, ::T.untyped)
  FsType_HFS = ::T.let(nil, ::T.untyped)
  FsType_HFSPLUS = ::T.let(nil, ::T.untyped)
  FsType_ISO9660 = ::T.let(nil, ::T.untyped)
  FsType_JFS = ::T.let(nil, ::T.untyped)
  FsType_MINIX = ::T.let(nil, ::T.untyped)
  FsType_NFS = ::T.let(nil, ::T.untyped)
  FsType_NFS4 = ::T.let(nil, ::T.untyped)
  FsType_NILFS2 = ::T.let(nil, ::T.untyped)
  FsType_NTFS = ::T.let(nil, ::T.untyped)
  FsType_NTFS3G = ::T.let(nil, ::T.untyped)
  FsType_REISERFS = ::T.let(nil, ::T.untyped)
  FsType_SWAP = ::T.let(nil, ::T.untyped)
  FsType_TMPFS = ::T.let(nil, ::T.untyped)
  FsType_UDF = ::T.let(nil, ::T.untyped)
  FsType_UNKNOWN = ::T.let(nil, ::T.untyped)
  FsType_VFAT = ::T.let(nil, ::T.untyped)
  FsType_XFS = ::T.let(nil, ::T.untyped)
  GraphvizFlags_ACTIVE = ::T.let(nil, ::T.untyped)
  GraphvizFlags_CLASSNAME = ::T.let(nil, ::T.untyped)
  GraphvizFlags_DISPLAYNAME = ::T.let(nil, ::T.untyped)
  GraphvizFlags_IN_ETC = ::T.let(nil, ::T.untyped)
  GraphvizFlags_NAME = ::T.let(nil, ::T.untyped)
  GraphvizFlags_NONE = ::T.let(nil, ::T.untyped)
  GraphvizFlags_PRETTY_CLASSNAME = ::T.let(nil, ::T.untyped)
  GraphvizFlags_SID = ::T.let(nil, ::T.untyped)
  GraphvizFlags_SIZE = ::T.let(nil, ::T.untyped)
  ID_BIOS_BOOT = ::T.let(nil, ::T.untyped)
  ID_DIAG = ::T.let(nil, ::T.untyped)
  ID_DOS12 = ::T.let(nil, ::T.untyped)
  ID_DOS16 = ::T.let(nil, ::T.untyped)
  ID_DOS32 = ::T.let(nil, ::T.untyped)
  ID_ESP = ::T.let(nil, ::T.untyped)
  ID_EXTENDED = ::T.let(nil, ::T.untyped)
  ID_LINUX = ::T.let(nil, ::T.untyped)
  ID_LVM = ::T.let(nil, ::T.untyped)
  ID_MICROSOFT_RESERVED = ::T.let(nil, ::T.untyped)
  ID_NTFS = ::T.let(nil, ::T.untyped)
  ID_PREP = ::T.let(nil, ::T.untyped)
  ID_RAID = ::T.let(nil, ::T.untyped)
  ID_SWAP = ::T.let(nil, ::T.untyped)
  ID_UNKNOWN = ::T.let(nil, ::T.untyped)
  ID_WINDOWS_BASIC_DATA = ::T.let(nil, ::T.untyped)
  LHS = ::T.let(nil, ::T.untyped)
  LIBSTORAGE_NG_VERSION_MAJOR = ::T.let(nil, ::T.untyped)
  LIBSTORAGE_NG_VERSION_MINOR = ::T.let(nil, ::T.untyped)
  LIBSTORAGE_NG_VERSION_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  LIBSTORAGE_NG_VERSION_STRING = ::T.let(nil, ::T.untyped)
  LogLevel_DEBUG = ::T.let(nil, ::T.untyped)
  LogLevel_ERROR = ::T.let(nil, ::T.untyped)
  LogLevel_MILESTONE = ::T.let(nil, ::T.untyped)
  LogLevel_WARNING = ::T.let(nil, ::T.untyped)
  LvType_NORMAL = ::T.let(nil, ::T.untyped)
  LvType_RAID = ::T.let(nil, ::T.untyped)
  LvType_THIN = ::T.let(nil, ::T.untyped)
  LvType_THIN_POOL = ::T.let(nil, ::T.untyped)
  LvType_UNKNOWN = ::T.let(nil, ::T.untyped)
  MdLevel_CONTAINER = ::T.let(nil, ::T.untyped)
  MdLevel_RAID0 = ::T.let(nil, ::T.untyped)
  MdLevel_RAID1 = ::T.let(nil, ::T.untyped)
  MdLevel_RAID10 = ::T.let(nil, ::T.untyped)
  MdLevel_RAID4 = ::T.let(nil, ::T.untyped)
  MdLevel_RAID5 = ::T.let(nil, ::T.untyped)
  MdLevel_RAID6 = ::T.let(nil, ::T.untyped)
  MdLevel_UNKNOWN = ::T.let(nil, ::T.untyped)
  MdParity_DEFAULT = ::T.let(nil, ::T.untyped)
  MdParity_FAR_2 = ::T.let(nil, ::T.untyped)
  MdParity_FAR_3 = ::T.let(nil, ::T.untyped)
  MdParity_FIRST = ::T.let(nil, ::T.untyped)
  MdParity_FIRST_6 = ::T.let(nil, ::T.untyped)
  MdParity_LAST = ::T.let(nil, ::T.untyped)
  MdParity_LEFT_ASYMMETRIC = ::T.let(nil, ::T.untyped)
  MdParity_LEFT_ASYMMETRIC_6 = ::T.let(nil, ::T.untyped)
  MdParity_LEFT_SYMMETRIC = ::T.let(nil, ::T.untyped)
  MdParity_LEFT_SYMMETRIC_6 = ::T.let(nil, ::T.untyped)
  MdParity_NEAR_2 = ::T.let(nil, ::T.untyped)
  MdParity_NEAR_3 = ::T.let(nil, ::T.untyped)
  MdParity_OFFSET_2 = ::T.let(nil, ::T.untyped)
  MdParity_OFFSET_3 = ::T.let(nil, ::T.untyped)
  MdParity_RIGHT_ASYMMETRIC = ::T.let(nil, ::T.untyped)
  MdParity_RIGHT_ASYMMETRIC_6 = ::T.let(nil, ::T.untyped)
  MdParity_RIGHT_SYMMETRIC = ::T.let(nil, ::T.untyped)
  MdParity_RIGHT_SYMMETRIC_6 = ::T.let(nil, ::T.untyped)
  MountByType_DEVICE = ::T.let(nil, ::T.untyped)
  MountByType_ID = ::T.let(nil, ::T.untyped)
  MountByType_LABEL = ::T.let(nil, ::T.untyped)
  MountByType_PATH = ::T.let(nil, ::T.untyped)
  MountByType_UUID = ::T.let(nil, ::T.untyped)
  PartitionType_EXTENDED = ::T.let(nil, ::T.untyped)
  PartitionType_LOGICAL = ::T.let(nil, ::T.untyped)
  PartitionType_PRIMARY = ::T.let(nil, ::T.untyped)
  ProbeMode_NONE = ::T.let(nil, ::T.untyped)
  ProbeMode_READ_DEVICEGRAPH = ::T.let(nil, ::T.untyped)
  ProbeMode_READ_MOCKUP = ::T.let(nil, ::T.untyped)
  ProbeMode_STANDARD = ::T.let(nil, ::T.untyped)
  ProbeMode_STANDARD_WRITE_DEVICEGRAPH = ::T.let(nil, ::T.untyped)
  ProbeMode_STANDARD_WRITE_MOCKUP = ::T.let(nil, ::T.untyped)
  PtType_DASD = ::T.let(nil, ::T.untyped)
  PtType_GPT = ::T.let(nil, ::T.untyped)
  PtType_IMPLICIT = ::T.let(nil, ::T.untyped)
  PtType_LOOP = ::T.let(nil, ::T.untyped)
  PtType_MAC = ::T.let(nil, ::T.untyped)
  PtType_MSDOS = ::T.let(nil, ::T.untyped)
  PtType_UNKNOWN = ::T.let(nil, ::T.untyped)
  RB_EXTENDED_PARTITION = ::T.let(nil, ::T.untyped)
  RB_FILESYSTEM_FULL = ::T.let(nil, ::T.untyped)
  RB_FILESYSTEM_INCONSISTENT = ::T.let(nil, ::T.untyped)
  RB_GROW_NOT_SUPPORTED_BY_FILESYSTEM = ::T.let(nil, ::T.untyped)
  RB_MAX_SIZE_FOR_FILESYSTEM = ::T.let(nil, ::T.untyped)
  RB_MAX_SIZE_FOR_LVM_LV_THIN = ::T.let(nil, ::T.untyped)
  RB_MIN_MAX_ERROR = ::T.let(nil, ::T.untyped)
  RB_MIN_SIZE_FOR_FILESYSTEM = ::T.let(nil, ::T.untyped)
  RB_MIN_SIZE_FOR_LVM_LV = ::T.let(nil, ::T.untyped)
  RB_MIN_SIZE_FOR_PARTITION = ::T.let(nil, ::T.untyped)
  RB_NO_SPACE_BEHIND_PARTITION = ::T.let(nil, ::T.untyped)
  RB_NO_SPACE_IN_LVM_VG = ::T.let(nil, ::T.untyped)
  RB_ON_IMPLICIT_PARTITION_TABLE = ::T.let(nil, ::T.untyped)
  RB_RESIZE_NOT_SUPPORTED_BY_DEVICE = ::T.let(nil, ::T.untyped)
  RB_RESIZE_NOT_SUPPORTED_FOR_LVM_LV_TYPE = ::T.let(nil, ::T.untyped)
  RB_SHRINK_NOT_SUPPORTED_BY_FILESYSTEM = ::T.let(nil, ::T.untyped)
  RB_SHRINK_NOT_SUPPORTED_FOR_LVM_LV_TYPE = ::T.let(nil, ::T.untyped)
  RHS = ::T.let(nil, ::T.untyped)
  TargetMode_CHROOT = ::T.let(nil, ::T.untyped)
  TargetMode_DIRECT = ::T.let(nil, ::T.untyped)
  TargetMode_IMAGE = ::T.let(nil, ::T.untyped)
  Transport_ATA = ::T.let(nil, ::T.untyped)
  Transport_FC = ::T.let(nil, ::T.untyped)
  Transport_FCOE = ::T.let(nil, ::T.untyped)
  Transport_ISCSI = ::T.let(nil, ::T.untyped)
  Transport_SAS = ::T.let(nil, ::T.untyped)
  Transport_SATA = ::T.let(nil, ::T.untyped)
  Transport_SBP = ::T.let(nil, ::T.untyped)
  Transport_SPI = ::T.let(nil, ::T.untyped)
  Transport_UNKNOWN = ::T.let(nil, ::T.untyped)
  Transport_USB = ::T.let(nil, ::T.untyped)
  UF_BCACHE = ::T.let(nil, ::T.untyped)
  UF_BTRFS = ::T.let(nil, ::T.untyped)
  UF_DASD = ::T.let(nil, ::T.untyped)
  UF_DMRAID = ::T.let(nil, ::T.untyped)
  UF_EXT2 = ::T.let(nil, ::T.untyped)
  UF_EXT3 = ::T.let(nil, ::T.untyped)
  UF_EXT4 = ::T.let(nil, ::T.untyped)
  UF_FC = ::T.let(nil, ::T.untyped)
  UF_FCOE = ::T.let(nil, ::T.untyped)
  UF_ISCSI = ::T.let(nil, ::T.untyped)
  UF_JFS = ::T.let(nil, ::T.untyped)
  UF_LUKS = ::T.let(nil, ::T.untyped)
  UF_LVM = ::T.let(nil, ::T.untyped)
  UF_MDRAID = ::T.let(nil, ::T.untyped)
  UF_MULTIPATH = ::T.let(nil, ::T.untyped)
  UF_NFS = ::T.let(nil, ::T.untyped)
  UF_NTFS = ::T.let(nil, ::T.untyped)
  UF_QUOTA = ::T.let(nil, ::T.untyped)
  UF_REISERFS = ::T.let(nil, ::T.untyped)
  UF_SNAPSHOTS = ::T.let(nil, ::T.untyped)
  UF_SWAP = ::T.let(nil, ::T.untyped)
  UF_VFAT = ::T.let(nil, ::T.untyped)
  UF_XFS = ::T.let(nil, ::T.untyped)
end

class Storage::Aborted
end

class Storage::Aborted
end

class Storage::Actiongraph
  def commit_actions(*_); end

  def commit_actions_as_strings(*_); end

  def compound_actions(*_); end

  def devicegraph(*_); end

  def empty?(*_); end

  def generate_compound_actions(*_); end

  def initialize(*_); end

  def num_actions(*_); end

  def print_graph(*_); end

  def print_order(*_); end

  def storage(*_); end

  def write_graphviz(*_); end
end

class Storage::Actiongraph
end

class Storage::ActivateCallbacks
  def initialize(*_); end

  def luks(*_); end

  def multipath(*_); end
end

class Storage::ActivateCallbacks
end

class Storage::AlignError
end

class Storage::AlignError
end

class Storage::Alignment
  def align(*_); end

  def can_be_aligned(*_); end

  def grain(*_); end

  def initialize(*_); end

  def offset(*_); end
end

class Storage::Alignment
end

class Storage::Arch
  def arch(*_); end

  def arch=(*arch); end

  def efiboot=(*efiboot); end

  def efiboot?(*_); end

  def ia64?(*_); end

  def initialize(*_); end

  def page_size(*_); end

  def ppc64le?(*_); end

  def ppc?(*_); end

  def ppc_mac?(*_); end

  def ppc_pegasos?(*_); end

  def ppc_power_nv?(*_); end

  def read_data(*_); end

  def s390?(*_); end

  def save_data(*_); end

  def sparc?(*_); end

  def x86?(*_); end
end

class Storage::Arch
end

class Storage::Bcache
  def bcache_cset(*_); end

  def blk_device(*_); end

  def has_bcache_cset(*_); end

  def number(*_); end
end

class Storage::Bcache
  def self.compare_by_number(*_); end

  def self.create(*_); end
end

class Storage::BcacheCset
  def bcaches(*_); end

  def blk_devices(*_); end

  def uuid(*_); end

  def uuid=(*uuid); end
end

class Storage::BcacheCset
  def self.compare_by_uuid(*_); end

  def self.create(*_); end
end

class Storage::BlkDevice
  def active?(*_); end

  def blk_filesystem(*_); end

  def create_blk_filesystem(*_); end

  def create_encryption(*_); end

  def create_filesystem(*_); end

  def dm_table_name(*_); end

  def dm_table_name=(*dm_table_name); end

  def encryption(*_); end

  def filesystem(*_); end

  def has_blk_filesystem(*_); end

  def has_encryption(*_); end

  def has_filesystem(*_); end

  def name(*_); end

  def name=(*name); end

  def region(*_); end

  def region=(*region); end

  def remove_encryption(*_); end

  def size(*_); end

  def size=(*size); end

  def size_string(*_); end

  def sysfs_name(*_); end

  def sysfs_path(*_); end

  def udev_ids(*_); end

  def udev_paths(*_); end

  def usable_as_blk_device?(*_); end
end

class Storage::BlkDevice
  def self.compare_by_dm_table_name(*_); end

  def self.find_by_any_name(*_); end

  def self.find_by_name(*_); end
end

class Storage::BlkFilesystem
  def blk_devices(*_); end

  def content_info=(*content_info); end

  def detect_content_info(*_); end

  def label(*_); end

  def label=(*label); end

  def max_labelsize(*_); end

  def mkfs_options(*_); end

  def mkfs_options=(*mkfs_options); end

  def resize_info=(*resize_info); end

  def supports_grow(*_); end

  def supports_label(*_); end

  def supports_mounted_grow(*_); end

  def supports_mounted_shrink(*_); end

  def supports_shrink(*_); end

  def supports_unmounted_grow(*_); end

  def supports_unmounted_shrink(*_); end

  def supports_uuid(*_); end

  def tune_options(*_); end

  def tune_options=(*tune_options); end

  def uuid(*_); end

  def uuid=(*uuid); end
end

class Storage::BlkFilesystem
  def self.find_by_label(*_); end

  def self.find_by_uuid(*_); end
end

class Storage::Btrfs
  def btrfs_subvolumes(*_); end

  def configure_snapper(*_); end

  def configure_snapper=(*configure_snapper); end

  def default_btrfs_subvolume(*_); end

  def default_btrfs_subvolume=(*default_btrfs_subvolume); end

  def find_btrfs_subvolume_by_path(*_); end

  def top_level_btrfs_subvolume(*_); end
end

class Storage::Btrfs
  def self.create(*_); end
end

class Storage::BtrfsSubvolume
  def btrfs(*_); end

  def create_btrfs_subvolume(*_); end

  def default_btrfs_subvolume=(*default_btrfs_subvolume); end

  def default_btrfs_subvolume?(*_); end

  def id(*_); end

  def nocow=(*nocow); end

  def nocow?(*_); end

  def path(*_); end

  def top_level?(*_); end

  def top_level_btrfs_subvolume(*_); end
end

class Storage::BtrfsSubvolume
  def self.compare_by_id(*_); end

  def self.create(*_); end
end

class Storage::BtrfsSubvolumeNotFoundByPath
end

class Storage::BtrfsSubvolumeNotFoundByPath
end

class Storage::Callbacks
  def error(*_); end

  def message(*_); end
end

class Storage::Callbacks
end

class Storage::CheckCallbacks
  def error(*_); end

  def initialize(*_); end
end

class Storage::CheckCallbacks
end

class Storage::CodeLocation
  def as_string(*_); end

  def file(*_); end

  def func(*_); end

  def initialize(*_); end

  def line(*_); end
end

class Storage::CodeLocation
end

class Storage::CommitCallbacks
  def initialize(*_); end
end

class Storage::CommitCallbacks
end

class Storage::CommitOptions
  def force_rw(*_); end

  def initialize(*_); end
end

class Storage::CommitOptions
end

class Storage::CompoundAction
  def delete?(*_); end

  def initialize(*_); end

  def sentence(*_); end

  def target_device(*_); end
end

class Storage::CompoundAction
end

class Storage::ConstIterator
  def +(*_); end

  def -(*_); end

  def ==(*_); end

  def dup(*_); end

  def inspect(*_); end

  def next(*_); end

  def previous(*_); end

  def to_s(*_); end

  def value(*_); end
end

class Storage::ConstIterator
end

class Storage::ContentInfo
  def efi?(*_); end

  def initialize(*_); end

  def num_homes(*_); end

  def num_homes=(*num_homes); end

  def save(*_); end

  def to_s(*_); end

  def windows?(*_); end
end

class Storage::ContentInfo
end

class Storage::Dasd
  def bus_id(*_); end

  def bus_id=(*bus_id); end

  def format=(*format); end

  def rotational?(*_); end

  def type(*_); end

  def type=(*type); end
end

class Storage::Dasd
  def self.create(*_); end
end

class Storage::DasdPt
end

class Storage::DasdPt
  def self.create(*_); end
end

class Storage::DeactivateStatus
  def dm_raid(*_); end

  def dm_raid=(*dm_raid); end

  def initialize(*_); end

  def luks(*_); end

  def luks=(*luks); end

  def lvm_lv(*_); end

  def lvm_lv=(*lvm_lv); end

  def md(*_); end

  def md=(*md); end

  def multipath(*_); end

  def multipath=(*multipath); end
end

class Storage::DeactivateStatus
end

class Storage::Device
  def ==(*_); end

  def ancestors(*_); end

  def children(*_); end

  def copy_to_devicegraph(*_); end

  def descendants(*_); end

  def detect_resize_info(*_); end

  def devicegraph(*_); end

  def exists_in_devicegraph?(*_); end

  def exists_in_probed?(*_); end

  def exists_in_staging?(*_); end

  def exists_in_system?(*_); end

  def has_children(*_); end

  def has_parents(*_); end

  def in_holders(*_); end

  def leaves(*_); end

  def num_children(*_); end

  def num_parents(*_); end

  def out_holders(*_); end

  def parents(*_); end

  def remove_descendants(*_); end

  def roots(*_); end

  def save(*_); end

  def siblings(*_); end

  def sid(*_); end

  def to_s(*_); end

  def userdata(*_); end

  def userdata=(*userdata); end
end

class Storage::Device
  def self.all(*_); end

  def self.compare_by_name(*_); end

  def self.compare_by_sid(*_); end
end

class Storage::DeviceHasWrongType
end

class Storage::DeviceHasWrongType
end

class Storage::DeviceNotFound
end

class Storage::DeviceNotFound
end

class Storage::DeviceNotFoundByName
end

class Storage::DeviceNotFoundByName
end

class Storage::DeviceNotFoundBySid
end

class Storage::DeviceNotFoundBySid
end

class Storage::DeviceNotFoundByUuid
end

class Storage::DeviceNotFoundByUuid
end

class Storage::Devicegraph
  def ==(*_); end

  def all_blk_filesystems(*_); end

  def all_disks(*_); end

  def all_filesystems(*_); end

  def all_lvm_vgs(*_); end

  def all_mds(*_); end

  def check(*_); end

  def clear(*_); end

  def copy(*_); end

  def device_exists?(*_); end

  def empty?(*_); end

  def find_device(*_); end

  def find_holder(*_); end

  def holder_exists(*_); end

  def initialize(*_); end

  def num_devices(*_); end

  def num_holders(*_); end

  def remove_device(*_); end

  def remove_devices(*_); end

  def remove_holder(*_); end

  def save(*_); end

  def storage(*_); end

  def to_s(*_); end

  def used_features(*_); end

  def write_graphviz(*_); end
end

class Storage::Devicegraph
end

class Storage::DifferentBlockSizes
end

class Storage::DifferentBlockSizes
end

class Storage::Disk
  def rotational?(*_); end

  def transport(*_); end
end

class Storage::Disk
  def self.create(*_); end
end

class Storage::DmRaid
  def rotational?(*_); end
end

class Storage::DmRaid
  def self.create(*_); end
end

class Storage::Encryption
  def blk_device(*_); end

  def crypt_options(*_); end

  def crypt_options=(*crypt_options); end

  def default_mount_by=(*default_mount_by); end

  def in_etc_crypttab=(*in_etc_crypttab); end

  def in_etc_crypttab?(*_); end

  def mount_by(*_); end

  def mount_by=(*mount_by); end

  def password(*_); end

  def password=(*password); end

  def type(*_); end
end

class Storage::Encryption
  def self.create(*_); end
end

class Storage::Environment
  def arch_filename(*_); end

  def arch_filename=(*arch_filename); end

  def devicegraph_filename(*_); end

  def devicegraph_filename=(*devicegraph_filename); end

  def initialize(*_); end

  def mockup_filename(*_); end

  def mockup_filename=(*mockup_filename); end

  def probe_mode(*_); end

  def read_only?(*_); end

  def target_mode(*_); end
end

class Storage::Environment
end

class Storage::Exception
  def as_string(*_); end

  def log_level(*_); end

  def msg(*_); end

  def relocate(*_); end

  def set_msg(*_); end

  def what(*_); end

  def where(*_); end
end

class Storage::Exception
  def self.log(*_); end

  def self.str_errno(*_); end
end

class Storage::Ext
end

class Storage::Ext
end

class Storage::Ext2
end

class Storage::Ext2
  def self.create(*_); end
end

class Storage::Ext3
end

class Storage::Ext3
  def self.create(*_); end
end

class Storage::Ext4
end

class Storage::Ext4
  def self.create(*_); end
end

class Storage::Filesystem
  def detect_space_info(*_); end

  def has_space_info(*_); end

  def space_info=(*space_info); end

  def type(*_); end
end

class Storage::Filesystem
end

class Storage::FilesystemUser
  def journal=(*journal); end

  def journal?(*_); end
end

class Storage::FilesystemUser
end

class Storage::GCVALUE
  def inspect(*_); end

  def to_s(*_); end
end

class Storage::GCVALUE
end

class Storage::Gpt
  def pmbr_boot=(*pmbr_boot); end

  def pmbr_boot?(*_); end
end

class Storage::Gpt
  def self.create(*_); end
end

class Storage::Holder
  def ==(*_); end

  def copy_to_devicegraph(*_); end

  def save(*_); end

  def source(*_); end

  def source_sid(*_); end

  def target(*_); end

  def target_sid(*_); end

  def to_s(*_); end
end

class Storage::Holder
end

class Storage::HolderAlreadyExists
end

class Storage::HolderAlreadyExists
end

class Storage::HolderHasWrongType
end

class Storage::HolderHasWrongType
end

class Storage::HolderNotFound
end

class Storage::HolderNotFound
end

class Storage::HolderNotFoundBySids
end

class Storage::HolderNotFoundBySids
end

class Storage::IOException
end

class Storage::IOException
end

class Storage::ImplicitPt
  def create_implicit_partition(*_); end
end

class Storage::ImplicitPt
  def self.create(*_); end
end

class Storage::IndexOutOfRangeException
  def invalid_index(*_); end

  def valid_max(*_); end

  def valid_min(*_); end
end

class Storage::IndexOutOfRangeException
end

class Storage::InvalidBlockSize
end

class Storage::InvalidBlockSize
end

class Storage::InvalidExtentSize
end

class Storage::InvalidExtentSize
end

class Storage::InvalidMountPointPath
end

class Storage::InvalidMountPointPath
end

class Storage::Iso9660
end

class Storage::Iso9660
  def self.create(*_); end
end

class Storage::Iterator
  def value=(*value); end
end

class Storage::Iterator
end

class Storage::Jfs
end

class Storage::Jfs
  def self.create(*_); end
end

class Storage::LockException
  def locker_pid(*_); end
end

class Storage::LockException
end

class Storage::Logger
  def initialize(*_); end

  def write(*_); end
end

class Storage::Logger
end

class Storage::LogicException
end

class Storage::LogicException
end

class Storage::Luks
end

class Storage::Luks
end

class Storage::LvmLv
  def chunk_size(*_); end

  def chunk_size=(*chunk_size); end

  def create_lvm_lv(*_); end

  def lv_name(*_); end

  def lv_name=(*lv_name); end

  def lv_type(*_); end

  def lvm_lv(*_); end

  def lvm_lvs(*_); end

  def lvm_vg(*_); end

  def max_size_for_lvm_lv(*_); end

  def stripe_size(*_); end

  def stripe_size=(*stripe_size); end

  def stripes(*_); end

  def stripes=(*stripes); end

  def thin_pool(*_); end
end

class Storage::LvmLv
  def self.compare_by_lv_name(*_); end

  def self.create(*_); end
end

class Storage::LvmLvNotFoundByLvName
end

class Storage::LvmLvNotFoundByLvName
end

class Storage::LvmPv
  def blk_device(*_); end

  def has_blk_device(*_); end

  def has_lvm_vg(*_); end

  def lvm_vg(*_); end
end

class Storage::LvmPv
  def self.create(*_); end
end

class Storage::LvmVg
  def add_lvm_pv(*_); end

  def create_lvm_lv(*_); end

  def delete_lvm_lv(*_); end

  def extent_size(*_); end

  def extent_size=(*extent_size); end

  def lvm_lv(*_); end

  def lvm_lvs(*_); end

  def lvm_pvs(*_); end

  def max_size_for_lvm_lv(*_); end

  def number_of_extents(*_); end

  def number_of_free_extents(*_); end

  def number_of_used_extents(*_); end

  def overcommitted?(*_); end

  def region(*_); end

  def remove_lvm_pv(*_); end

  def size(*_); end

  def size_string(*_); end

  def vg_name(*_); end

  def vg_name=(*vg_name); end
end

class Storage::LvmVg
  def self.compare_by_vg_name(*_); end

  def self.create(*_); end

  def self.find_by_vg_name(*_); end
end

class Storage::LvmVgNotFoundByVgName
end

class Storage::LvmVgNotFoundByVgName
end

class Storage::MapStringString
  include ::Enumerable
  def [](*_); end

  def []=(*_); end

  def allocator(*_); end

  def begin(*_); end

  def clear(*_); end

  def delete(*_); end

  def dup(*_); end

  def each(*_); end

  def each_key(*_); end

  def each_value(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def has_key?(*_); end

  def include?(*_); end

  def initialize(*_); end

  def inspect(*_); end

  def key_iterator(*_); end

  def keys(*_); end

  def lower_bound(*_); end

  def rbegin(*_); end

  def rend(*_); end

  def select(*_); end

  def size(*_); end

  def swap(*_); end

  def to_s(*_); end

  def upper_bound(*_); end

  def value_iterator(*_); end

  def values(*_); end

  def values_at(*_); end
end

class Storage::MapStringString
end

class Storage::Md
  def add_device(*_); end

  def allowed_md_parities(*_); end

  def chunk_size(*_); end

  def chunk_size=(*chunk_size); end

  def devices(*_); end

  def in_etc_mdadm=(*in_etc_mdadm); end

  def in_etc_mdadm?(*_); end

  def md_level(*_); end

  def md_level=(*md_level); end

  def md_parity(*_); end

  def md_parity=(*md_parity); end

  def metadata(*_); end

  def metadata=(*metadata); end

  def minimal_number_of_devices(*_); end

  def number(*_); end

  def numeric?(*_); end

  def remove_device(*_); end

  def uuid(*_); end
end

class Storage::Md
  def self.compare_by_number(*_); end

  def self.create(*_); end

  def self.find_free_numeric_name(*_); end
end

class Storage::MdContainer
  def md_members(*_); end
end

class Storage::MdContainer
end

class Storage::MdMember
  def md_container(*_); end
end

class Storage::MdMember
end

class Storage::MdSubdevice
  def member(*_); end

  def member=(*member); end
end

class Storage::MdSubdevice
end

class Storage::MdUser
  def faulty=(*faulty); end

  def faulty?(*_); end

  def sort_key(*_); end

  def sort_key=(*sort_key); end

  def spare=(*spare); end

  def spare?(*_); end
end

class Storage::MdUser
end

class Storage::MountPoint
  def active=(*active); end

  def active?(*_); end

  def default_mount_by=(*default_mount_by); end

  def default_mount_options=(*default_mount_options); end

  def filesystem(*_); end

  def freq(*_); end

  def freq=(*freq); end

  def has_mountable(*_); end

  def immediate_activate(*_); end

  def immediate_deactivate(*_); end

  def in_etc_fstab=(*in_etc_fstab); end

  def in_etc_fstab?(*_); end

  def mount_by(*_); end

  def mount_by=(*mount_by); end

  def mount_options(*_); end

  def mount_options=(*mount_options); end

  def mount_type(*_); end

  def mount_type=(*mount_type); end

  def mountable(*_); end

  def passno(*_); end

  def passno=(*passno); end

  def path(*_); end

  def path=(*path); end

  def possible_mount_bys(*_); end
end

class Storage::MountPoint
  def self.create(*_); end

  def self.find_by_path(*_); end

  def self.normalize_path(*_); end
end

class Storage::Mountable
  def create_mount_point(*_); end

  def filesystem(*_); end

  def fstab_options(*_); end

  def fstab_options=(*fstab_options); end

  def has_filesystem(*_); end

  def has_mount_point(*_); end

  def mount_by(*_); end

  def mount_by=(*mount_by); end

  def mount_opts(*_); end

  def mount_opts=(*mount_opts); end

  def mount_point(*_); end

  def remove_mount_point(*_); end
end

class Storage::Mountable
end

class Storage::Msdos
  def minimal_mbr_gap(*_); end

  def minimal_mbr_gap=(*minimal_mbr_gap); end
end

class Storage::Msdos
  def self.create(*_); end
end

class Storage::Multipath
  def model(*_); end

  def rotational?(*_); end

  def vendor(*_); end
end

class Storage::Multipath
  def self.create(*_); end
end

class Storage::Nfs
  def path(*_); end

  def server(*_); end
end

class Storage::Nfs
  def self.create(*_); end

  def self.find_by_server_and_path(*_); end
end

class Storage::NfsNotFoundByServerAndPath
end

class Storage::NfsNotFoundByServerAndPath
end

class Storage::NoIntersection
end

class Storage::NoIntersection
end

class Storage::NotInside
end

class Storage::NotInside
end

class Storage::Ntfs
end

class Storage::Ntfs
  def self.create(*_); end
end

class Storage::NullPointerException
end

class Storage::NullPointerException
end

class Storage::OutOfMemoryException
end

class Storage::OutOfMemoryException
end

class Storage::OverflowException
end

class Storage::OverflowException
end

class Storage::PairBoolString
  def [](*_); end

  def []=(*_); end

  def first(*_); end

  def first=(*first); end

  def initialize(*_); end

  def inspect(*_); end

  def second(*_); end

  def second=(*second); end

  def to_s(*_); end
end

class Storage::PairBoolString
end

class Storage::ParseException
  def dump_on(*_); end

  def expected(*_); end

  def seen(*_); end
end

class Storage::ParseException
end

class Storage::Partition
  def boot=(*boot); end

  def boot?(*_); end

  def id(*_); end

  def id=(*id); end

  def legacy_boot=(*legacy_boot); end

  def legacy_boot?(*_); end

  def number(*_); end

  def partition_table(*_); end

  def partitionable(*_); end

  def type(*_); end

  def type=(*type); end

  def unused_surrounding_region(*_); end
end

class Storage::Partition
  def self.compare_by_number(*_); end

  def self.create(*_); end
end

class Storage::PartitionSlot
  def extended_possible(*_); end

  def extended_possible=(*extended_possible); end

  def extended_slot(*_); end

  def extended_slot=(*extended_slot); end

  def initialize(*_); end

  def logical_possible(*_); end

  def logical_possible=(*logical_possible); end

  def logical_slot(*_); end

  def logical_slot=(*logical_slot); end

  def name(*_); end

  def name=(*name); end

  def nr(*_); end

  def number(*_); end

  def number=(*number); end

  def possible?(*_); end

  def primary_possible(*_); end

  def primary_possible=(*primary_possible); end

  def primary_slot(*_); end

  def primary_slot=(*primary_slot); end

  def region(*_); end

  def region=(*region); end

  def to_s(*_); end
end

class Storage::PartitionSlot
end

class Storage::PartitionTable
  def align(*_); end

  def alignment(*_); end

  def create_partition(*_); end

  def delete_partition(*_); end

  def extended(*_); end

  def extended_possible(*_); end

  def has_extended(*_); end

  def max_logical(*_); end

  def max_primary(*_); end

  def num_logical(*_); end

  def num_primary(*_); end

  def partition(*_); end

  def partition_boot_flag_supported?(*_); end

  def partition_id_supported?(*_); end

  def partition_legacy_boot_flag_supported?(*_); end

  def partitionable(*_); end

  def partitions(*_); end

  def type(*_); end

  def unused_partition_slots(*_); end
end

class Storage::PartitionTable
end

class Storage::Partitionable
  def create_partition_table(*_); end

  def default_partition_table_type(*_); end

  def has_partition_table(*_); end

  def partition_name(*_); end

  def partition_table(*_); end

  def possible_partition_table_types(*_); end

  def range(*_); end

  def range=(*range); end

  def topology(*_); end

  def topology=(*topology); end

  def usable_as_partitionable?(*_); end
end

class Storage::Partitionable
end

class Storage::ProbeCallbacks
  def initialize(*_); end
end

class Storage::ProbeCallbacks
end

class Storage::Region
  def <(*_); end

  def <=(*_); end

  def ==(*_); end

  def >(*_); end

  def >=(*_); end

  def adjust_length(*_); end

  def adjust_start(*_); end

  def block_size(*_); end

  def block_size=(*block_size); end

  def empty?(*_); end

  def end(*_); end

  def initialize(*_); end

  def inside(*_); end

  def intersect(*_); end

  def intersection(*_); end

  def length(*_); end

  def length=(*length); end

  def start(*_); end

  def start=(*start); end

  def to_blocks(*_); end

  def to_bytes(*_); end

  def to_s(*_); end

  def unused_regions(*_); end
end

class Storage::Region
end

class Storage::Reiserfs
end

class Storage::Reiserfs
  def self.create(*_); end
end

class Storage::RemoteCallbacks
  def command(*_); end

  def file(*_); end

  def initialize(*_); end
end

class Storage::RemoteCallbacks
end

class Storage::RemoteCommand
  def exit_code(*_); end

  def exit_code=(*exit_code); end

  def initialize(*_); end

  def stderr(*_); end

  def stderr=(*stderr); end

  def stdout(*_); end

  def stdout=(*stdout); end
end

class Storage::RemoteCommand
end

class Storage::RemoteFile
  def content(*_); end

  def content=(*content); end

  def initialize(*_); end
end

class Storage::RemoteFile
end

class Storage::ResizeInfo
  def block_size(*_); end

  def block_size=(*block_size); end

  def combine(*_); end

  def combine_block_size(*_); end

  def combine_max(*_); end

  def combine_min(*_); end

  def initialize(*_); end

  def max_size(*_); end

  def max_size=(*max_size); end

  def min_size(*_); end

  def min_size=(*min_size); end

  def reasons(*_); end

  def reasons=(*reasons); end

  def resize_ok(*_); end

  def resize_ok=(*resize_ok); end

  def save(*_); end

  def shift(*_); end

  def to_s(*_); end
end

class Storage::ResizeInfo
end

class Storage::Silencer
  def initialize(*_); end

  def turn_off(*_); end

  def turn_on(*_); end
end

class Storage::Silencer
  def self.any_active?(*_); end
end

class Storage::SimpleEtcCrypttabEntry
  def crypt_options(*_); end

  def crypt_options=(*crypt_options); end

  def device(*_); end

  def device=(*device); end

  def initialize(*_); end

  def name(*_); end

  def name=(*name); end

  def password(*_); end

  def password=(*password); end
end

class Storage::SimpleEtcCrypttabEntry
end

class Storage::SimpleEtcFstabEntry
  def device(*_); end

  def device=(*device); end

  def fs_freq(*_); end

  def fs_freq=(*fs_freq); end

  def fs_passno(*_); end

  def fs_passno=(*fs_passno); end

  def fs_type(*_); end

  def fs_type=(*fs_type); end

  def initialize(*_); end

  def mount_options(*_); end

  def mount_options=(*mount_options); end

  def mount_point(*_); end

  def mount_point=(*mount_point); end
end

class Storage::SimpleEtcFstabEntry
end

class Storage::SpaceInfo
  def initialize(*_); end

  def save(*_); end

  def size(*_); end

  def size=(*size); end

  def size_string(*_); end

  def to_s(*_); end

  def used(*_); end

  def used=(*used); end
end

class Storage::SpaceInfo
end

class Storage::Storage
  def activate(*_); end

  def arch(*_); end

  def calculate_actiongraph(*_); end

  def check(*_); end

  def commit(*_); end

  def copy_devicegraph(*_); end

  def create_devicegraph(*_); end

  def deactivate(*_); end

  def default_mount_by(*_); end

  def default_mount_by=(*default_mount_by); end

  def devicegraph(*_); end

  def devicegraph_names(*_); end

  def environment(*_); end

  def equal_devicegraph(*_); end

  def exist_devicegraph(*_); end

  def initialize(*_); end

  def prepend_rootprefix(*_); end

  def probe(*_); end

  def probed(*_); end

  def remove_devicegraph(*_); end

  def restore_devicegraph(*_); end

  def rootprefix(*_); end

  def rootprefix=(*rootprefix); end

  def staging(*_); end
end

class Storage::Storage
end

class Storage::StrayBlkDevice
end

class Storage::StrayBlkDevice
  def self.create(*_); end
end

class Storage::Subdevice
end

class Storage::Subdevice
  def self.create(*_); end
end

class Storage::Swap
end

class Storage::Swap
  def self.create(*_); end
end

class Storage::Topology
  def ==(*_); end

  def alignment_offset(*_); end

  def alignment_offset=(*alignment_offset); end

  def initialize(*_); end

  def minimal_grain(*_); end

  def minimal_grain=(*minimal_grain); end

  def optimal_io_size(*_); end

  def optimal_io_size=(*optimal_io_size); end
end

class Storage::Topology
end

class Storage::Udf
end

class Storage::Udf
  def self.create(*_); end
end

class Storage::UnsupportedException
end

class Storage::UnsupportedException
end

class Storage::User
end

class Storage::User
  def self.create(*_); end
end

class Storage::VectorBcacheCsetPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorBcacheCsetPtr
end

class Storage::VectorBcachePtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorBcachePtr
end

class Storage::VectorBlkDevicePtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorBlkDevicePtr
end

class Storage::VectorBlkFilesystemPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorBlkFilesystemPtr
end

class Storage::VectorBtrfsSubvolumePtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorBtrfsSubvolumePtr
end

class Storage::VectorCompoundActionPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorCompoundActionPtr
end

class Storage::VectorConstBcacheCsetPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstBcacheCsetPtr
end

class Storage::VectorConstBcachePtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstBcachePtr
end

class Storage::VectorConstBlkDevicePtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstBlkDevicePtr
end

class Storage::VectorConstBlkFilesystemPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstBlkFilesystemPtr
end

class Storage::VectorConstBtrfsSubvolumePtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstBtrfsSubvolumePtr
end

class Storage::VectorConstCompoundActionPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstCompoundActionPtr
end

class Storage::VectorConstDasdPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstDasdPtr
end

class Storage::VectorConstDevicePtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstDevicePtr
end

class Storage::VectorConstDiskPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstDiskPtr
end

class Storage::VectorConstDmRaidPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstDmRaidPtr
end

class Storage::VectorConstEncryptionPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstEncryptionPtr
end

class Storage::VectorConstFilesystemPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstFilesystemPtr
end

class Storage::VectorConstHolderPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstHolderPtr
end

class Storage::VectorConstLuksPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstLuksPtr
end

class Storage::VectorConstLvmLvPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstLvmLvPtr
end

class Storage::VectorConstLvmPvPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstLvmPvPtr
end

class Storage::VectorConstLvmVgPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstLvmVgPtr
end

class Storage::VectorConstMdContainerPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstMdContainerPtr
end

class Storage::VectorConstMdMemberPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstMdMemberPtr
end

class Storage::VectorConstMdPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstMdPtr
end

class Storage::VectorConstMountPointPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstMountPointPtr
end

class Storage::VectorConstMountablePtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstMountablePtr
end

class Storage::VectorConstMultipathPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstMultipathPtr
end

class Storage::VectorConstNfsPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstNfsPtr
end

class Storage::VectorConstNtfsPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstNtfsPtr
end

class Storage::VectorConstPartitionPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstPartitionPtr
end

class Storage::VectorConstPartitionablePtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstPartitionablePtr
end

class Storage::VectorConstStrayBlkDevicePtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstStrayBlkDevicePtr
end

class Storage::VectorConstSwapPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorConstSwapPtr
end

class Storage::VectorDasdPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorDasdPtr
end

class Storage::VectorDevicePtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorDevicePtr
end

class Storage::VectorDiskPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorDiskPtr
end

class Storage::VectorDmRaidPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorDmRaidPtr
end

class Storage::VectorEncryptionPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorEncryptionPtr
end

class Storage::VectorFilesystemPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorFilesystemPtr
end

class Storage::VectorHolderPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorHolderPtr
end

class Storage::VectorLuksPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorLuksPtr
end

class Storage::VectorLvmLvPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorLvmLvPtr
end

class Storage::VectorLvmPvPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorLvmPvPtr
end

class Storage::VectorLvmVgPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorLvmVgPtr
end

class Storage::VectorMdContainerPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorMdContainerPtr
end

class Storage::VectorMdMemberPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorMdMemberPtr
end

class Storage::VectorMdParity
  include ::Enumerable
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def select(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorMdParity
end

class Storage::VectorMdPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorMdPtr
end

class Storage::VectorMountByType
  include ::Enumerable
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def select(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorMountByType
end

class Storage::VectorMountPointPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorMountPointPtr
end

class Storage::VectorMountablePtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorMountablePtr
end

class Storage::VectorMultipathPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorMultipathPtr
end

class Storage::VectorNfsPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorNfsPtr
end

class Storage::VectorNtfsPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorNtfsPtr
end

class Storage::VectorPartitionPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorPartitionPtr
end

class Storage::VectorPartitionSlot
  include ::Enumerable
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def select(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorPartitionSlot
end

class Storage::VectorPartitionablePtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorPartitionablePtr
end

class Storage::VectorPtType
  include ::Enumerable
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def select(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorPtType
end

class Storage::VectorSimpleEtcCrypttabEntry
  include ::Enumerable
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def select(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorSimpleEtcCrypttabEntry
end

class Storage::VectorSimpleEtcFstabEntry
  include ::Enumerable
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def select(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorSimpleEtcFstabEntry
end

class Storage::VectorStrayBlkDevicePtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorStrayBlkDevicePtr
end

class Storage::VectorString
  include ::Enumerable
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def map!(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def select(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorString
end

class Storage::VectorSwapPtr
  def <<(*_); end

  def [](*_); end

  def []=(*_); end

  def __delete_2__(*_); end

  def allocator(*_); end

  def assign(*_); end

  def at(*_); end

  def back(*_); end

  def begin(*_); end

  def capacity(*_); end

  def clear(*_); end

  def delete_at(*_); end

  def delete_if(*_); end

  def dup(*_); end

  def each(*_); end

  def empty?(*_); end

  def end(*_); end

  def erase(*_); end

  def front(*_); end

  def initialize(*_); end

  def insert(*_); end

  def inspect(*_); end

  def pop(*_); end

  def push(*_); end

  def rbegin(*_); end

  def reject(*_); end

  def reject!(*_); end

  def rend(*_); end

  def reserve(*_); end

  def resize(*_); end

  def shift(*_); end

  def size(*_); end

  def slice(*_); end

  def swap(*_); end

  def to_a(*_); end

  def to_s(*_); end

  def unshift(*_); end
end

class Storage::VectorSwapPtr
end

class Storage::Vfat
end

class Storage::Vfat
  def self.create(*_); end
end

class Storage::WrongNumberOfChildren
end

class Storage::WrongNumberOfChildren
end

class Storage::WrongNumberOfParents
end

class Storage::WrongNumberOfParents
end

class Storage::Xfs
end

class Storage::Xfs
  def self.create(*_); end
end

module Storage
  extend ::T::Sig
  def self.&(*_); end

  def self.<<(*_); end

  def self.B(); end

  def self.EiB(); end

  def self.GiB(); end

  def self.KiB(); end

  def self.MiB(); end

  def self.PiB(); end

  def self.TiB(); end

  def self.bcache?(*_); end

  def self.bcache_cset?(*_); end

  def self.blk_device?(*_); end

  def self.blk_filesystem?(*_); end

  def self.btrfs?(*_); end

  def self.btrfs_subvolume?(*_); end

  def self.byte_to_humanstring(*_); end

  def self.dasd?(*_); end

  def self.dasd_pt?(*_); end

  def self.disk?(*_); end

  def self.disown_ActivateCallbacks(*_); end

  def self.disown_CheckCallbacks(*_); end

  def self.disown_CommitCallbacks(*_); end

  def self.disown_Logger(*_); end

  def self.disown_ProbeCallbacks(*_); end

  def self.disown_RemoteCallbacks(*_); end

  def self.dm_raid?(*_); end

  def self.downcast(*_); end

  def self.encryption?(*_); end

  def self.ext2?(*_); end

  def self.ext3?(*_); end

  def self.ext4?(*_); end

  def self.ext?(*_); end

  def self.filesystem?(*_); end

  def self.filesystem_user?(*_); end

  def self.fs_type_name(*_); end

  def self.gpt?(*_); end

  def self.humanstring_to_byte(*_); end

  def self.implicit_pt?(*_); end

  def self.iso9660?(*_); end

  def self.jfs?(*_); end

  def self.light_probe(*_); end

  def self.logfile_logger(*_); end

  def self.logger(*_); end

  def self.logger=(*logger); end

  def self.luks?(*_); end

  def self.lvm_lv?(*_); end

  def self.lvm_pv?(*_); end

  def self.lvm_vg?(*_); end

  def self.md?(*_); end

  def self.md_container?(*_); end

  def self.md_level_name(*_); end

  def self.md_member?(*_); end

  def self.md_parity_name(*_); end

  def self.md_subdevice?(*_); end

  def self.md_user?(*_); end

  def self.mount_by_name(*_); end

  def self.mount_point?(*_); end

  def self.mountable?(*_); end

  def self.msdos?(*_); end

  def self.multipath?(*_); end

  def self.nfs?(*_); end

  def self.ntfs?(*_); end

  def self.num_suffixes(*_); end

  def self.partition?(*_); end

  def self.partition_table?(*_); end

  def self.partition_type_name(*_); end

  def self.partitionable?(*_); end

  def self.pt_type_name(*_); end

  def self.read_simple_etc_crypttab(*_); end

  def self.read_simple_etc_fstab(*_); end

  def self.reiserfs?(*_); end

  def self.remote_callbacks(*_); end

  def self.remote_callbacks=(*remote_callbacks); end

  def self.stdout_logger(*_); end

  def self.stray_blk_device?(*_); end

  def self.subdevice?(*_); end

  def self.suffix(*_); end

  def self.swap?(*_); end

  def self.to_bcache(*_); end

  def self.to_bcache_cset(*_); end

  def self.to_blk_device(*_); end

  def self.to_blk_filesystem(*_); end

  def self.to_btrfs(*_); end

  def self.to_btrfs_subvolume(*_); end

  def self.to_dasd(*_); end

  def self.to_dasd_pt(*_); end

  def self.to_disk(*_); end

  def self.to_dm_raid(*_); end

  def self.to_encryption(*_); end

  def self.to_ext(*_); end

  def self.to_ext2(*_); end

  def self.to_ext3(*_); end

  def self.to_ext4(*_); end

  def self.to_filesystem(*_); end

  def self.to_filesystem_user(*_); end

  def self.to_gpt(*_); end

  def self.to_implicit_pt(*_); end

  def self.to_iso_9660(*_); end

  def self.to_jfs(*_); end

  def self.to_luks(*_); end

  def self.to_lvm_lv(*_); end

  def self.to_lvm_pv(*_); end

  def self.to_lvm_vg(*_); end

  def self.to_md(*_); end

  def self.to_md_container(*_); end

  def self.to_md_member(*_); end

  def self.to_md_subdevice(*_); end

  def self.to_md_user(*_); end

  def self.to_mount_point(*_); end

  def self.to_mountable(*_); end

  def self.to_msdos(*_); end

  def self.to_multipath(*_); end

  def self.to_nfs(*_); end

  def self.to_ntfs(*_); end

  def self.to_partition(*_); end

  def self.to_partition_table(*_); end

  def self.to_partitionable(*_); end

  def self.to_reiserfs(*_); end

  def self.to_stray_blk_device(*_); end

  def self.to_subdevice(*_); end

  def self.to_swap(*_); end

  def self.to_udf(*_); end

  def self.to_user(*_); end

  def self.to_vfat(*_); end

  def self.to_xfs(*_); end

  def self.transport_name(*_); end

  def self.udf?(*_); end

  def self.user?(*_); end

  def self.vfat?(*_); end

  def self.xfs?(*_); end

  def self.|(*_); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def +@(); end

  def -@(); end

  def []=(*_); end

  def block_scanf(fstr); end

  def casecmp?(_); end

  def delete_prefix(_); end

  def delete_prefix!(_); end

  def delete_suffix(_); end

  def delete_suffix!(_); end

  def each_grapheme_cluster(); end

  def encode(*_); end

  def encode!(*_); end

  def grapheme_clusters(); end

  def match?(*_); end

  def reverse!(); end

  def scanf(fstr, &b); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(_); end

end

class String
  extend ::T::Sig
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

class StringIO
  def length(); end

  def truncate(_); end

end

class StringIO
  extend ::T::Sig
end

class StringScanner
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner::Error
  extend ::T::Sig
end

class StringScanner
  extend ::T::Sig
  def self.must_C_version(); end
end

class Struct
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class Struct
  extend ::T::Sig
end

class Symbol
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def casecmp?(_); end

  def match?(*_); end

  def next(); end

end

class Symbol
  extend ::T::Sig
end

class SyntaxError
  extend ::T::Sig
end

class SystemCallError
  def errno(); end
end

class SystemCallError
  extend ::T::Sig
end

class SystemExit
  def status(); end

  def success?(); end
end

class SystemExit
  extend ::T::Sig
end

class SystemStackError
  extend ::T::Sig
end

class TCPServer
  extend ::T::Sig
end

class TCPSocket
  extend ::T::Sig
end

class TSort::Cyclic
  extend ::T::Sig
end

module TSort
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class Tempfile
  def _close(); end

  def inspect(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class Thread
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def abort_on_exception(); end

  def abort_on_exception=(abort_on_exception); end

  def add_trace_func(_); end

  def backtrace(*_); end

  def backtrace_locations(*_); end

  def exit(); end

  def fetch(*_); end

  def group(); end

  def initialize(*_); end

  def join(*_); end

  def key?(_); end

  def keys(); end

  def name(); end

  def name=(name); end

  def pending_interrupt?(*_); end

  def priority(); end

  def priority=(priority); end

  def report_on_exception(); end

  def report_on_exception=(report_on_exception); end

  def run(); end

  def safe_level(); end

  def status(); end

  def stop?(); end

  def terminate(); end

  def thread_variable?(_); end

  def thread_variable_get(_); end

  def thread_variable_set(_, _1); end

  def thread_variables(); end

  def value(); end

  def wakeup(); end
end

class Thread::Backtrace
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class Thread::Backtrace::Location
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class Thread::Backtrace::Location
  extend ::T::Sig
end

class Thread::Backtrace
  extend ::T::Sig
end

class Thread::ConditionVariable
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def broadcast(); end

  def marshal_dump(); end

  def signal(); end

  def wait(*_); end
end

class Thread::ConditionVariable
  extend ::T::Sig
end

class Thread::Mutex
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def lock(); end

  def locked?(); end

  def owned?(); end

  def synchronize(); end

  def try_lock(); end

  def unlock(); end
end

class Thread::Mutex
  extend ::T::Sig
end

class Thread::Queue
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def <<(_); end

  def clear(); end

  def close(); end

  def closed?(); end

  def deq(*_); end

  def empty?(); end

  def enq(_); end

  def length(); end

  def marshal_dump(); end

  def num_waiting(); end

  def pop(*_); end

  def push(_); end

  def shift(*_); end

  def size(); end
end

class Thread::Queue
  extend ::T::Sig
end

class Thread::SizedQueue
  def <<(*_); end

  def enq(*_); end

  def initialize(_); end

  def max(); end

  def max=(max); end

  def push(*_); end
end

class Thread::SizedQueue
  extend ::T::Sig
end

class Thread
  extend ::T::Sig
  def self.abort_on_exception(); end

  def self.abort_on_exception=(abort_on_exception); end

  def self.exclusive(&block); end

  def self.exit(); end

  def self.fork(*_); end

  def self.handle_interrupt(_); end

  def self.kill(_); end

  def self.list(); end

  def self.pass(); end

  def self.pending_interrupt?(*_); end

  def self.report_on_exception(); end

  def self.report_on_exception=(report_on_exception); end

  def self.start(*_); end

  def self.stop(); end
end

class ThreadError
  extend ::T::Sig
end

class ThreadGroup
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def add(_); end

  def enclose(); end

  def enclosed?(); end

  def list(); end
  Default = ::T.let(nil, ::T.untyped)
end

class ThreadGroup
  extend ::T::Sig
end

class Time
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class Time
  extend ::T::Sig
end

class Timeout::Error
  extend ::T::Sig
end

module Timeout
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class TracePoint
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def event(); end
end

class TracePoint
  extend ::T::Sig
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
end

class TrueClass
  extend ::T::Sig
end

class TypeError
  extend ::T::Sig
end

class UDPSocket
  extend ::T::Sig
end

module UI
end

class UI::Dialog
  include ::UI::EventDispatcher
  include ::Yast::UIShortcuts
  include ::Yast::Logger
  include ::Yast::I18n
  def close_dialog(); end

  def create_dialog(); end

  def dialog_content(); end

  def dialog_options(); end

  def run(); end
end

class UI::Dialog
  extend ::Yast::Logger
  def self.run(); end
end

module UI::EventDispatcher
  def cancel_handler(); end

  def event_loop(); end

  def finish_dialog(return_value=T.unsafe(nil)); end

  def user_input(); end
end

module UI::EventDispatcher
  extend ::T::Sig
end

module UI
  extend ::T::Sig
end

class UNIXServer
  extend ::T::Sig
end

class UNIXSocket
  extend ::T::Sig
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::BadURIError
  extend ::T::Sig
end

class URI::Error
  extend ::T::Sig
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module URI::Escape
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  extend ::T::Sig
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::Generic
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
end

class URI::Generic
  extend ::T::Sig
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class URI::HTTP
  def request_uri(); end
end

class URI::HTTP
  extend ::T::Sig
end

class URI::HTTPS
  extend ::T::Sig
end

class URI::InvalidComponentError
  extend ::T::Sig
end

class URI::InvalidURIError
  extend ::T::Sig
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::LDAP
  extend ::T::Sig
end

class URI::LDAPS
  extend ::T::Sig
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

class URI::MailTo
  extend ::T::Sig
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC2396_Parser
  extend ::T::Sig
end

module URI::RFC2396_REGEXP::PATTERN
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

module URI::RFC2396_REGEXP
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

class URI::RFC3986_Parser
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class URI::RFC3986_Parser
  extend ::T::Sig
end

module URI::Util
  extend ::T::Sig
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::T::Sig
  extend ::URI::Escape
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.get_encoding(label); end
end

class UnboundMethod
  include ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ObjectOverride
  def clone(); end

  def original_name(); end
end

class UnboundMethod
  extend ::T::Sig
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

class UncaughtThrowError
  extend ::T::Sig
end

module UnicodeNormalize
end

module UnicodeNormalize
  extend ::T::Sig
end

module Warning
  def warn(_); end
end

module Warning
  extend ::T::Sig
  extend ::Warning
  extend ::Sorbet::Private::GemGeneratorTracepoint::Tracer::ModuleOverride
end

module Y2Autoinstallation
end

module Y2Autoinstallation::AutoinstIssues
end

class Y2Autoinstallation::AutoinstIssues::InvalidValue
  include ::Yast::Logger
  def initialize(section, attribute, value, description, severity=T.unsafe(nil)); end
end

class Y2Autoinstallation::AutoinstIssues::InvalidValue
  extend ::Yast::Logger
end

class Y2Autoinstallation::AutoinstIssues::Issue
  include ::Yast::I18n
  def fatal?(); end

  def message(); end

  def section(); end

  def severity(); end

  def warn?(); end
end

class Y2Autoinstallation::AutoinstIssues::Issue
end

class Y2Autoinstallation::AutoinstIssues::List
  include ::Yast::Logger
  include ::Enumerable
  def <<(*args, &block); end

  def add(type, *extra_args); end

  def each(*args, &block); end

  def empty?(*args, &block); end

  def fatal?(); end

  def to_a(); end
end

class Y2Autoinstallation::AutoinstIssues::List
  extend ::Yast::Logger
  extend ::Forwardable
end

class Y2Autoinstallation::AutoinstIssues::MissingValue
  def attr(); end

  def description(); end

  def initialize(section, attr, description=T.unsafe(nil), severity=T.unsafe(nil)); end
end

class Y2Autoinstallation::AutoinstIssues::MissingValue
end

module Y2Autoinstallation::AutoinstIssues
  extend ::T::Sig
end

class Y2Autoinstallation::AutoinstIssuesPresenter
  include ::Yast::I18n
  def error_text(issues); end

  def initialize(issues_list); end

  def issues_by_section(issues); end

  def issues_list(); end

  def issues_list_content(issues); end

  def to_html(); end

  def to_plain(); end

  def warning_text(issues); end
end

class Y2Autoinstallation::AutoinstIssuesPresenter
end

module Y2Autoinstallation
  extend ::T::Sig
end

module Y2Packager
  PRODUCT_SORTER = ::T.let(nil, ::T.untyped)
end

class Y2Packager::License
  include ::Yast::Logger
  def accept!(); end

  def accepted(); end

  def accepted?(); end

  def add_content_for(lang, content); end

  def content_for(lang=T.unsafe(nil)); end

  def id(); end

  def initialize(fetcher: T.unsafe(nil), content: T.unsafe(nil)); end

  def locales(); end

  def reject!(); end

  def translations(); end
  DEFAULT_LANG = ::T.let(nil, ::T.untyped)
end

class Y2Packager::License
  extend ::Yast::Logger
  def self.clear_cache(); end

  def self.find(product_name, source: T.unsafe(nil), content: T.unsafe(nil)); end
end

module Y2Packager::LicensesFetchers
end

class Y2Packager::LicensesFetchers::Base
  include ::Yast::Logger
  def initialize(product_name, _options=T.unsafe(nil)); end

  def product_name(); end
end

class Y2Packager::LicensesFetchers::Base
  extend ::Yast::Logger
end

class Y2Packager::LicensesFetchers::Libzypp
  def confirmation_required?(); end

  def content(lang); end

  def locales(); end
end

class Y2Packager::LicensesFetchers::Libzypp
end

module Y2Packager::LicensesFetchers
  extend ::T::Sig
  def self.for(source, product_name); end
end

module Y2Packager::LicensesHandlers
end

class Y2Packager::LicensesHandlers::Base
  include ::Yast::Logger
  def initialize(product_name); end

  def product_name(); end
end

class Y2Packager::LicensesHandlers::Base
  extend ::Yast::Logger
end

class Y2Packager::LicensesHandlers::Libzypp
  def confirmation=(confirmed); end

  def confirmation_required?(); end
end

class Y2Packager::LicensesHandlers::Libzypp
end

module Y2Packager::LicensesHandlers
  extend ::T::Sig
  def self.for(source, product_name); end
end

class Y2Packager::Package
  include ::Yast::Logger
  def download_to(path); end

  def extract_to(directory); end

  def initialize(name, repo_id, version); end

  def name(); end

  def repo_id(); end

  def status(); end
end

class Y2Packager::Package
  extend ::Yast::Logger
  def self.find(name); end
end

class Y2Packager::Product
  include ::Yast::Logger
  def ==(other); end

  def arch(); end

  def category(); end

  def display_name(); end

  def initialize(name: T.unsafe(nil), short_name: T.unsafe(nil), display_name: T.unsafe(nil), version: T.unsafe(nil), arch: T.unsafe(nil), category: T.unsafe(nil), vendor: T.unsafe(nil), order: T.unsafe(nil), installation_package: T.unsafe(nil)); end

  def installation_package(); end

  def installed?(); end

  def label(); end

  def license(); end

  def license?(); end

  def license_confirmation=(confirmed); end

  def license_confirmation_required?(); end

  def license_confirmed?(); end

  def license_content(lang); end

  def license_locales(); end

  def name(); end

  def order(); end

  def release_notes(user_lang, format=T.unsafe(nil)); end

  def relnotes_url(); end

  def resolvable_properties(); end

  def restore(); end

  def select(); end

  def selected?(); end

  def short_name(); end

  def status?(*statuses); end

  def vendor(); end
  DEFAULT_LICENSE_LANG = ::T.let(nil, ::T.untyped)
end

class Y2Packager::Product
  extend ::Yast::Logger
  def self.all(); end

  def self.available_base_products(); end

  def self.from_h(p); end

  def self.installed_base_product(); end

  def self.installed_products(); end

  def self.selected_base(); end

  def self.with_status(*statuses); end
end

class Y2Packager::ProductLicense
  def accept!(); end

  def accepted?(); end

  def confirmation=(*args, &block); end

  def confirmation_required?(*args, &block); end

  def content_for(*args, &block); end

  def initialize(product_name, license, source: T.unsafe(nil)); end

  def license(); end

  def locales(*args, &block); end

  def reject!(); end
end

class Y2Packager::ProductLicense
  extend ::Forwardable
  def self.clear_cache(); end

  def self.find(product_name, source: T.unsafe(nil), content: T.unsafe(nil)); end
end

class Y2Packager::ProductReader
  include ::Yast::Logger
  def all_installed_products(); end

  def all_products(); end

  def available_base_products(); end

  def installed_base_product(); end

  def product_package(name, repo_id); end
end

class Y2Packager::ProductReader
  extend ::Yast::Logger
  def self.installation_package_mapping(); end
end

class Y2Packager::ReleaseNotes
  def content(); end

  def format(); end

  def initialize(product_name:, content:, user_lang:, lang:, format:, version:); end

  def lang(); end

  def matches?(user_lang, format, version); end

  def product_name(); end

  def user_lang(); end
end

class Y2Packager::ReleaseNotes
end

class Y2Packager::ReleaseNotesContentPrefs
  def fallback_lang(); end

  def fallback_lang=(_); end

  def format(); end

  def format=(_); end

  def user_lang(); end

  def user_lang=(_); end
end

class Y2Packager::ReleaseNotesContentPrefs
  def self.[](*_); end

  def self.members(); end
end

module Y2Packager::ReleaseNotesFetchers
end

class Y2Packager::ReleaseNotesFetchers::Base
  include ::Yast::Logger
  def initialize(product); end

  def latest_version(); end

  def product(); end

  def release_notes(_prefs); end
end

class Y2Packager::ReleaseNotesFetchers::Base
  extend ::Yast::Logger
end

class Y2Packager::ReleaseNotesFetchers::Rpm
  def release_notes(prefs); end
  AVAILABLE_STATUSES = ::T.let(nil, ::T.untyped)
end

class Y2Packager::ReleaseNotesFetchers::Rpm
end

class Y2Packager::ReleaseNotesFetchers::Url
  def release_notes(prefs); end
  CURL_GIVE_UP_RETURN_CODES = ::T.let(nil, ::T.untyped)
end

class Y2Packager::ReleaseNotesFetchers::Url
  def self.add_to_blacklist(url); end

  def self.blacklist(); end

  def self.blacklisted?(url); end

  def self.clear_blacklist(); end

  def self.disable!(); end

  def self.enable!(); end

  def self.enabled?(); end
end

module Y2Packager::ReleaseNotesFetchers
  extend ::T::Sig
end

class Y2Packager::ReleaseNotesReader
  include ::Yast::Logger
  def initialize(product, release_notes_store=T.unsafe(nil)); end

  def product(); end

  def release_notes(user_lang: T.unsafe(nil), format: T.unsafe(nil)); end

  def release_notes_via_reader(reader, prefs); end
  FALLBACK_LANG = ::T.let(nil, ::T.untyped)
end

class Y2Packager::ReleaseNotesReader
  extend ::Yast::Logger
end

class Y2Packager::ReleaseNotesStore
  def clear(); end

  def retrieve(product_name, user_lang, format, version); end

  def store(rn); end
end

class Y2Packager::ReleaseNotesStore
  def self.current(); end
end

class Y2Packager::Repository
  def addons(); end

  def autorefresh?(); end

  def disable!(); end

  def enable!(); end

  def enabled?(); end

  def initialize(repo_id:, name:, enabled:, autorefresh:, url:); end

  def local?(); end

  def name(); end

  def products(); end

  def repo_id(); end

  def scheme(); end

  def url(); end
  LOCAL_SCHEMES = ::T.let(nil, ::T.untyped)
end

class Y2Packager::Repository::NotFound
end

class Y2Packager::Repository::NotFound
end

class Y2Packager::Repository
  def self.all(); end

  def self.create(name:, url:, enabled: T.unsafe(nil), autorefresh: T.unsafe(nil)); end

  def self.disabled(); end

  def self.enabled(); end

  def self.find(repo_id); end
end

module Y2Packager
  extend ::T::Sig
end

class Y2Storage::AbstractDeviceFactory
  include ::Yast::Logger
  def build_tree(obj); end

  def devicegraph(); end

  def initialize(devicegraph); end

  def load_yaml_file(yaml_file); end
end

class Y2Storage::AbstractDeviceFactory::DependencyHash
  include ::TSort
  def initialize(hash); end

  def tsort_each_child(node, &block); end

  def tsort_each_node(&block); end
end

class Y2Storage::AbstractDeviceFactory::DependencyHash
end

class Y2Storage::AbstractDeviceFactory::HierarchyError
end

class Y2Storage::AbstractDeviceFactory::HierarchyError
end

class Y2Storage::AbstractDeviceFactory
  extend ::Yast::Logger
end

class Y2Storage::AccessModeError
end

class Y2Storage::AccessModeError
end

class Y2Storage::Actiongraph
  include ::Y2Storage::StorageClassWrapper
  def commit_actions_as_strings(*args); end

  def compound_actions(); end

  def empty?(*args); end

  def print_graph(*args); end

  def write_graphviz(*args); end
end

class Y2Storage::Actiongraph
  extend ::Y2Storage::StorageClassWrapper::ClassMethods
end

class Y2Storage::ActionsPresenter
  include ::Yast::I18n
  def action_to_item(action); end

  def actiongraph(); end

  def actions_to_items(actions); end

  def actions_to_text(actions); end

  def can_handle?(event); end

  def collapsed_subvolumes(); end

  def collapsed_subvolumes?(); end

  def dump(file_base_name=T.unsafe(nil)); end

  def empty?(); end

  def events(); end

  def general_actions(); end

  def general_actions_items(); end

  def html_list(items); end

  def initialize(actiongraph); end

  def save(filename); end

  def sort_actions(actions); end

  def subvolume_actions(); end

  def subvolume_actions_items(); end

  def to_html(); end

  def toggle_subvolumes(); end

  def toggle_subvolumes_event(); end

  def update_status(event); end
  TOGGLE_SUBVOLUMES_EVENT = ::T.let(nil, ::T.untyped)
end

class Y2Storage::ActionsPresenter
end

class Y2Storage::AlignPolicy
  include ::Y2Storage::StorageEnumWrapper
  ALIGN_END = ::T.let(nil, ::T.untyped)
  ALIGN_START_AND_END = ::T.let(nil, ::T.untyped)
  ALIGN_START_KEEP_END = ::T.let(nil, ::T.untyped)
  ALIGN_START_KEEP_SIZE = ::T.let(nil, ::T.untyped)
  KEEP_END = ::T.let(nil, ::T.untyped)
  KEEP_SIZE = ::T.let(nil, ::T.untyped)
  KEEP_START_ALIGN_END = ::T.let(nil, ::T.untyped)
end

class Y2Storage::AlignPolicy
  extend ::Y2Storage::StorageEnumWrapper::ClassMethods
end

class Y2Storage::AlignType
  include ::Y2Storage::StorageEnumWrapper
  OPTIMAL = ::T.let(nil, ::T.untyped)
  REQUIRED = ::T.let(nil, ::T.untyped)
end

class Y2Storage::AlignType
  extend ::Y2Storage::StorageEnumWrapper::ClassMethods
end

module Y2Storage::AutoinstIssues
end

class Y2Storage::AutoinstIssues::CouldNotCreateBoot
  def initialize(*args); end
end

class Y2Storage::AutoinstIssues::CouldNotCreateBoot
end

class Y2Storage::AutoinstIssues::Exception
  def error(); end

  def initialize(error); end
end

class Y2Storage::AutoinstIssues::Exception
end

class Y2Storage::AutoinstIssues::InvalidValue
  def attr(); end

  def initialize(section, attr, new_value=T.unsafe(nil)); end

  def new_value(); end

  def value(); end
end

class Y2Storage::AutoinstIssues::InvalidValue
end

class Y2Storage::AutoinstIssues::Issue
  include ::Yast::I18n
  def fatal?(); end

  def message(); end

  def section(); end

  def severity(); end

  def warn?(); end
end

class Y2Storage::AutoinstIssues::Issue
end

class Y2Storage::AutoinstIssues::List
  include ::Enumerable
  def <<(*args, &block); end

  def add(type, *extra_args); end

  def each(*args, &block); end

  def empty?(*args, &block); end

  def fatal?(); end

  def to_a(); end
end

class Y2Storage::AutoinstIssues::List
  extend ::Forwardable
end

class Y2Storage::AutoinstIssues::MissingReusableDevice
  def initialize(section); end
end

class Y2Storage::AutoinstIssues::MissingReusableDevice
end

class Y2Storage::AutoinstIssues::MissingReuseInfo
  def initialize(section); end
end

class Y2Storage::AutoinstIssues::MissingReuseInfo
end

class Y2Storage::AutoinstIssues::MissingRoot
  def initialize(*args); end
end

class Y2Storage::AutoinstIssues::MissingRoot
end

class Y2Storage::AutoinstIssues::MissingValue
  def attr(); end

  def initialize(section, attr); end
end

class Y2Storage::AutoinstIssues::MissingValue
end

class Y2Storage::AutoinstIssues::NoDisk
  def initialize(section); end
end

class Y2Storage::AutoinstIssues::NoDisk
end

class Y2Storage::AutoinstIssues::NoDiskSpace
  def initialize(*args); end
end

class Y2Storage::AutoinstIssues::NoDiskSpace
end

class Y2Storage::AutoinstIssues::NoProposal
  def initialize(*args); end
end

class Y2Storage::AutoinstIssues::NoProposal
end

class Y2Storage::AutoinstIssues::ShrinkedPlannedDevices
  def device_shrinkages(); end

  def diff(); end

  def initialize(device_shrinkages); end
  DEVICE_TYPES_MAP = ::T.let(nil, ::T.untyped)
end

class Y2Storage::AutoinstIssues::ShrinkedPlannedDevices
  extend ::Yast::I18n
end

class Y2Storage::AutoinstIssues::ThinPoolNotFound
  def initialize(section); end
end

class Y2Storage::AutoinstIssues::ThinPoolNotFound
end

module Y2Storage::AutoinstIssues
  extend ::T::Sig
end

module Y2Storage::AutoinstProfile
  HWINFO_KEYS = ::T.let(nil, ::T.untyped)
  KEYS = ::T.let(nil, ::T.untyped)
end

class Y2Storage::AutoinstProfile::DriveSection
  def default_type_for(hash); end

  def device(); end

  def device=(device); end

  def disklabel(); end

  def disklabel=(disklabel); end

  def enable_snapshots(); end

  def enable_snapshots=(enable_snapshots); end

  def enabled_snapshots?(filesystems); end

  def imsmdriver(); end

  def imsmdriver=(imsmdriver); end

  def init_from_device(device); end

  def init_from_disk(disk); end

  def init_from_md(md); end

  def init_from_vg(vg); end

  def initialize_attr(); end

  def initialize_attr=(initialize_attr); end

  def is_lvm_vg(); end

  def is_lvm_vg=(is_lvm_vg); end

  def keep_unknown_lv(); end

  def keep_unknown_lv=(keep_unknown_lv); end

  def lvm2(); end

  def lvm2=(lvm2); end

  def name_for_md(); end

  def partitions(); end

  def partitions=(partitions); end

  def partitions_from_collection(collection); end

  def partitions_from_disk(disk); end

  def partitions_from_hash(hash); end

  def pesize(); end

  def pesize=(pesize); end

  def reuse_partitions?(disk); end

  def skip_list(); end

  def skip_list=(skip_list); end

  def skip_partition?(partition); end

  def type(); end

  def type=(type); end

  def use(); end

  def use=(use); end

  def use_value_from_string(use); end

  def windows?(partition); end
end

class Y2Storage::AutoinstProfile::DriveSection
  def self.new_from_storage(device); end
end

class Y2Storage::AutoinstProfile::PartitionSection
  def create(); end

  def create=(create); end

  def create_subvolumes(); end

  def create_subvolumes=(create_subvolumes); end

  def crypt_fs(); end

  def crypt_fs=(crypt_fs); end

  def crypt_key(); end

  def crypt_key=(crypt_key); end

  def enforce_bios_boot?(partition); end

  def filesystem(); end

  def filesystem=(filesystem); end

  def format(); end

  def format=(format); end

  def fstab_options(); end

  def fstab_options=(fstab_options); end

  def id_for_partition(); end

  def init_encryption_fields(partition); end

  def init_fields_by_type(device); end

  def init_filesystem_fields(partition); end

  def init_from_device(device); end

  def init_lv_fields(lv); end

  def init_md_fields(md); end

  def init_mount_options(fs); end

  def init_partition_fields(partition); end

  def init_subvolumes(fs); end

  def label(); end

  def label=(label); end

  def loop_fs(); end

  def loop_fs=(loop_fs); end

  def lv_name(); end

  def lv_name=(lv_name); end

  def lvm_group(); end

  def lvm_group=(lvm_group); end

  def mkfs_options(); end

  def mkfs_options=(mkfs_options); end

  def mount(); end

  def mount=(mount); end

  def mountby(); end

  def mountby=(mountby); end

  def name_for_md(); end

  def partition_id(); end

  def partition_id=(partition_id); end

  def partition_id_from(partition); end

  def partition_nr(); end

  def partition_nr=(partition_nr); end

  def partition_type(); end

  def partition_type=(partition_type); end

  def pool(); end

  def pool=(pool); end

  def raid_name(); end

  def raid_name=(raid_name); end

  def raid_options(); end

  def raid_options=(raid_options); end

  def resize(); end

  def resize=(resize); end

  def size(); end

  def size=(size); end

  def stripe_size(); end

  def stripe_size=(stripe_size); end

  def stripes(); end

  def stripes=(stripes); end

  def subvolumes(); end

  def subvolumes=(subvolumes); end

  def subvolumes_from_hashes(hashes); end

  def subvolumes_prefix(); end

  def subvolumes_prefix=(subvolumes_prefix); end

  def subvolumes_to_hashes(); end

  def type_for_filesystem(); end

  def type_for_mountby(); end

  def used_pool(); end

  def used_pool=(used_pool); end

  def uuid(); end

  def uuid=(uuid); end
end

class Y2Storage::AutoinstProfile::PartitionSection
  def self.new_from_storage(device); end
end

class Y2Storage::AutoinstProfile::PartitioningSection
  def disk_drives(); end

  def drives(); end

  def drives=(drives); end

  def lvm_drives(); end

  def md_drives(); end

  def parent(); end

  def section_name(); end

  def to_hashes(); end
end

class Y2Storage::AutoinstProfile::PartitioningSection
  def self.new_from_hashes(drives_array); end

  def self.new_from_storage(devicegraph); end
end

class Y2Storage::AutoinstProfile::RaidOptionsSection
  def chunk_size(); end

  def chunk_size=(chunk_size); end

  def device_order(); end

  def device_order=(device_order); end

  def init_from_raid(md); end

  def parity_algorithm(); end

  def parity_algorithm=(parity_algorithm); end

  def persistent_superblock(); end

  def persistent_superblock=(persistent_superblock); end

  def raid_name(); end

  def raid_name=(raid_name); end

  def raid_type(); end

  def raid_type=(raid_type); end
end

class Y2Storage::AutoinstProfile::RaidOptionsSection
  def self.new_from_storage(device); end
end

class Y2Storage::AutoinstProfile::SectionWithAttributes
  include ::Yast::Logger
  def attrib_key(attrib); end

  def attrib_name(key); end

  def attrib_scalar(element); end

  def attrib_skip?(value); end

  def attrib_value(attrib); end

  def attributes(); end

  def init_from_hashes(hash); end

  def init_scalars_from_hash(hash); end

  def initialize(parent=T.unsafe(nil)); end

  def parent(); end

  def section_name(); end

  def to_hashes(); end
end

class Y2Storage::AutoinstProfile::SectionWithAttributes
  extend ::Yast::Logger
  def self.attributes(); end

  def self.define_attr_accessors(); end

  def self.new_from_hashes(hash, parent=T.unsafe(nil)); end
end

class Y2Storage::AutoinstProfile::SkipListSection
  include ::Yast::Logger
  def initialize(rules, parent=T.unsafe(nil)); end

  def matches?(disk); end

  def parent(); end

  def rules(); end

  def section_name(); end

  def to_hashes(); end
end

class Y2Storage::AutoinstProfile::SkipListSection
  extend ::Yast::Logger
  def self.new_from_hashes(profile_rules, parent=T.unsafe(nil)); end
end

class Y2Storage::AutoinstProfile::SkipListValue
  def dasd_format(); end

  def dasd_type(); end

  def device(); end

  def initialize(disk); end

  def label(); end

  def max_logical(); end

  def max_primary(); end

  def name(); end

  def sector_size(); end

  def size_k(); end

  def to_hash(); end

  def transport(); end

  def udev_id(); end

  def udev_path(); end
end

class Y2Storage::AutoinstProfile::SkipListValue
end

class Y2Storage::AutoinstProfile::SkipRule
  include ::Yast::Logger
  def initialize(key, predicate, raw_reference); end

  def key(); end

  def matches?(disk); end

  def predicate(); end

  def raw_reference(); end

  def to_profile_rule(); end

  def valid?(); end

  def value(disk); end
  PREDICATES = ::T.let(nil, ::T.untyped)
end

class Y2Storage::AutoinstProfile::SkipRule::NotValidSkipRule
end

class Y2Storage::AutoinstProfile::SkipRule::NotValidSkipRule
end

class Y2Storage::AutoinstProfile::SkipRule
  extend ::Yast::Logger
  def self.from_profile_rule(hash); end
end

module Y2Storage::AutoinstProfile
  extend ::T::Sig
end

class Y2Storage::AutoinstProposal
  def initialize(partitioning: T.unsafe(nil), devicegraph: T.unsafe(nil), disk_analyzer: T.unsafe(nil), issues_list: T.unsafe(nil)); end

  def issues_list(); end

  def missing_space(); end

  def partitioning(); end
end

class Y2Storage::AutoinstProposal
end

class Y2Storage::BlkDevice
  include ::Y2Storage::ComparableByName
  include ::Y2Storage::MatchVolumeSpec
  def active?(*args); end

  def basename(); end

  def blk_filesystem(); end

  def block_size(); end

  def bus(); end

  def create_blk_filesystem(*args); end

  def create_encryption(*args); end

  def create_filesystem(*args); end

  def delete_filesystem(); end

  def direct_blk_filesystem(*args); end

  def direct_lvm_pv(); end

  def direct_md(); end

  def dm_table_name(*args); end

  def dm_table_name=(*args); end

  def encrypt(dm_name: T.unsafe(nil), password: T.unsafe(nil)); end

  def encrypted?(); end

  def encryption(*args); end

  def end(); end

  def filesystem(); end

  def filesystem_label(); end

  def filesystem_mountpoint(); end

  def filesystem_type(); end

  def filesystem_uuid(); end

  def formatted?(); end

  def formatted_as?(*fs_types); end

  def hwinfo(); end

  def lvm_pv(); end

  def md(); end

  def model(); end

  def name(*args); end

  def name=(*args); end

  def part_of_lvm_or_md?(); end

  def plain_device(); end

  def recoverable_size(); end

  def region(*args); end

  def region=(*args); end

  def remove_encryption(*args); end

  def size(*args); end

  def size=(*args); end

  def start(); end

  def sysfs_name(*args); end

  def sysfs_path(*args); end

  def to_be_formatted?(initial_devicegraph); end

  def udev_full_all(); end

  def udev_full_ids(); end

  def udev_full_label(); end

  def udev_full_paths(); end

  def udev_full_uuid(); end

  def udev_ids(*args); end

  def udev_paths(*args); end

  def usable_as_blk_device?(*args); end

  def vendor(); end
end

class Y2Storage::BlkDevice
  extend ::Y2Storage::ComparableByName::ClassMethods
  def self.all(*args); end

  def self.find_by_any_name(*args); end

  def self.find_by_name(*args); end
end

class Y2Storage::BootRequirementsChecker
  include ::Yast::Logger
  def arch(); end

  def boot_disk_name(); end

  def devicegraph(); end

  def errors(); end

  def initialize(devicegraph, planned_devices: T.unsafe(nil), boot_disk_name: T.unsafe(nil)); end

  def needed_partitions(target=T.unsafe(nil)); end

  def nfs_root?(); end

  def planned_devices(); end

  def strategy(); end

  def valid?(); end

  def warnings(); end
end

class Y2Storage::BootRequirementsChecker::Error
end

class Y2Storage::BootRequirementsChecker::Error
end

class Y2Storage::BootRequirementsChecker
  extend ::Yast::Logger
end

module Y2Storage::BootRequirementsStrategies
end

class Y2Storage::BootRequirementsStrategies::Analyzer
  def boot_disk(); end

  def boot_disk_from_devicegraph(); end

  def boot_disk_from_planned_dev(); end

  def boot_disk_name(); end

  def boot_filesystem(); end

  def boot_filesystem_type(); end

  def boot_in_lvm?(); end

  def boot_in_software_raid?(); end

  def boot_planned_dev(); end

  def boot_ptable_type(); end

  def boot_ptable_type?(type); end

  def btrfs_root?(); end

  def device_for_boot(); end

  def device_for_root(); end

  def devicegraph(); end

  def efi_in_md_raid1?(); end

  def encrypted?(device); end

  def encrypted_boot?(); end

  def encrypted_root?(); end

  def filesystem_for_mountpoint(path); end

  def filesystem_type(device); end

  def free_mountpoint?(path); end

  def graph_prep_partitions(); end

  def in_lvm?(device); end

  def in_software_raid?(device); end

  def initialize(devicegraph, planned_devices, boot_disk_name); end

  def max_planned_weight(); end

  def planned_devices(); end

  def planned_for_mountpoint(path); end

  def planned_grub_partitions(); end

  def planned_partitions_with_id(id); end

  def planned_prep_partitions(); end

  def planned_weight(device); end

  def root_filesystem(); end

  def root_in_lvm?(); end

  def root_in_software_raid?(); end

  def root_planned_dev(); end
end

class Y2Storage::BootRequirementsStrategies::Analyzer
end

class Y2Storage::BootRequirementsStrategies::Base
  include ::Yast::Logger
  include ::Yast::I18n
  def analyzer(); end

  def boot_disk(*args, &block); end

  def boot_filesystem_type(*args, &block); end

  def boot_in_lvm?(*args, &block); end

  def boot_in_software_raid?(*args, &block); end

  def boot_partition(target); end

  def boot_partition_missing?(); end

  def boot_partition_needed?(); end

  def boot_ptable_type?(*args, &block); end

  def boot_volume(); end

  def btrfs_root?(*args, &block); end

  def create_planned_partition(volume, target); end

  def devicegraph(); end

  def encrypted_boot?(*args, &block); end

  def encrypted_root?(*args, &block); end

  def errors(); end

  def free_mountpoint?(*args, &block); end

  def initialize(devicegraph, planned_devices, boot_disk_name); end

  def missing_partition_for?(volume); end

  def needed_partitions(target); end

  def root_filesystem(*args, &block); end

  def root_filesystem_missing?(); end

  def root_in_lvm?(*args, &block); end

  def root_in_software_raid?(*args, &block); end

  def too_small_boot?(); end

  def unknown_boot_disk_error(); end

  def volume_specification_for(mount_point); end

  def warnings(); end
end

class Y2Storage::BootRequirementsStrategies::Base
  extend ::Yast::Logger
  extend ::Forwardable
end

class Y2Storage::BootRequirementsStrategies::Error
end

class Y2Storage::BootRequirementsStrategies::Error
end

class Y2Storage::BootRequirementsStrategies::Legacy
  def btrfs_without_encryption?(); end

  def btrfs_without_lvm?(); end

  def btrfs_without_software_raid?(); end

  def errors_on_gpt(); end

  def errors_on_msdos(); end

  def grub_in_mbr?(); end

  def grub_partition(target); end

  def grub_partition_missing?(); end

  def grub_partition_needed?(); end

  def grub_volume(); end

  def initialize(*args); end

  def mbr_gap(); end

  def mbr_gap_error(); end

  def plain_btrfs?(); end

  def unknown_boot_partition_table_error(); end

  def valid_mbr_gap?(); end
  GRUBENV_SIZE = ::T.let(nil, ::T.untyped)
  GRUB_SIZE = ::T.let(nil, ::T.untyped)
end

class Y2Storage::BootRequirementsStrategies::Legacy
end

class Y2Storage::BootRequirementsStrategies::NfsRoot
end

class Y2Storage::BootRequirementsStrategies::NfsRoot
end

class Y2Storage::BootRequirementsStrategies::PReP
  def arch(); end

  def big_prep_warning(big_partitions); end

  def initialize(*args); end

  def max_prep_size(); end

  def prep_partition(target); end

  def prep_partition_missing?(); end

  def prep_partition_needed?(); end

  def prep_volume(); end

  def prep_warnings(); end

  def too_big_preps(); end
end

class Y2Storage::BootRequirementsStrategies::PReP
end

class Y2Storage::BootRequirementsStrategies::UEFI
  def biggest_efi(); end

  def biggest_efi_in_boot_device(); end

  def biggest_partition(partitions); end

  def efi_missing?(); end

  def efi_partition(target); end

  def efi_volume(); end

  def initialize(*args); end

  def reusable_efi(); end

  def suitable_efi_partitions(device); end
end

class Y2Storage::BootRequirementsStrategies::UEFI
end

class Y2Storage::BootRequirementsStrategies::ZIPL
  def initialize(*args); end

  def supported_boot_disk?(); end

  def unsupported_boot_disk_error(); end

  def zipl_partition(target); end

  def zipl_partition_missing?(); end

  def zipl_partition_needed?(); end

  def zipl_volume(); end
end

class Y2Storage::BootRequirementsStrategies::ZIPL
end

module Y2Storage::BootRequirementsStrategies
  extend ::T::Sig
end

class Y2Storage::BtrfsSubvolume
  def blk_filesystem(*args); end

  def btrfs(*args); end

  def can_be_auto_deleted=(value); end

  def can_be_auto_deleted?(); end

  def copy_mount_by_from_filesystem(); end

  def create_btrfs_subvolume(*args); end

  def default_btrfs_subvolume?(*args); end

  def filesystem(*args); end

  def id(*args); end

  def nocow=(*args); end

  def nocow?(*args); end

  def path(*args); end

  def set_default_btrfs_subvolume(); end

  def shadowed?(); end

  def shadowers(); end

  def top_level?(*args); end

  def top_level_btrfs_subvolume(*args); end
end

class Y2Storage::BtrfsSubvolume
  def self.shadowed?(devicegraph, mount_path); end

  def self.shadowers(devicegraph, mount_path); end

  def self.shadowing?(mount_path, other_mount_path); end
end

module Y2Storage::Callbacks
end

class Y2Storage::Callbacks::Activate
  include ::Y2Storage::Callbacks::LibstorageCallback
  include ::Yast::Logger
  include ::Yast::I18n
  def initialize(); end

  def luks(uuid, attempt); end

  def multipath(looks_like_real_multipath); end
end

class Y2Storage::Callbacks::Activate
  extend ::Yast::Logger
end

class Y2Storage::Callbacks::Commit
  include ::Y2Storage::Callbacks::LibstorageCallback
  include ::Yast::Logger
  include ::Yast::I18n
end

class Y2Storage::Callbacks::Commit
end

class Y2Storage::Callbacks::Initialize
  include ::Yast
  include ::Yast::Logger
  include ::Yast::I18n
  def initialize(error); end

  def retry?(); end
end

class Y2Storage::Callbacks::Initialize
  extend ::Yast::Logger
end

module Y2Storage::Callbacks::LibstorageCallback
  include ::Yast::Logger
  include ::Yast::I18n
  def abort_button_label(); end

  def default_answer_to_error(); end

  def duplicated_pv_description(); end

  def error(message, what); end

  def error_description(what); end

  def forced_multipath?(); end

  def message(message); end
end

module Y2Storage::Callbacks::LibstorageCallback
  extend ::Yast::Logger
  extend ::T::Sig
end

class Y2Storage::Callbacks::Probe
  include ::Y2Storage::Callbacks::LibstorageCallback
  include ::Yast::Logger
  include ::Yast::I18n
end

class Y2Storage::Callbacks::Probe
end

class Y2Storage::Callbacks::Sanitize
  include ::Yast::Logger
  include ::Yast::I18n
  def abort_button_label(); end

  def sanitize?(errors); end
end

class Y2Storage::Callbacks::Sanitize
  extend ::Yast::Logger
end

module Y2Storage::Callbacks
  extend ::T::Sig
end

module Y2Storage::ComparableByName
  def compare_by_name(other); end
end

module Y2Storage::ComparableByName::ClassMethods
  def sorted_by_name(devicegraph); end
end

module Y2Storage::ComparableByName::ClassMethods
  extend ::T::Sig
end

module Y2Storage::ComparableByName
  extend ::T::Sig
  def self.included(base); end
end

class Y2Storage::CompoundAction
  include ::Y2Storage::StorageClassWrapper
  def delete?(*args); end

  def device_is?(type); end

  def sentence(*args); end

  def target_device(*args); end
end

class Y2Storage::CompoundAction
  extend ::Y2Storage::StorageClassWrapper::ClassMethods
end

class Y2Storage::Crypttab
  include ::Yast::Logger
  def entries(); end

  def filesystem(); end

  def initialize(path=T.unsafe(nil), filesystem=T.unsafe(nil)); end
end

class Y2Storage::Crypttab
  extend ::Yast::Logger
end

class Y2Storage::Dasd
  include ::Y2Storage::DiskDevice
  def format(*args); end

  def format=(*args); end

  def rotational?(*args); end

  def type(*args); end

  def type=(*args); end
end

class Y2Storage::Dasd
  def self.create(*args); end
end

class Y2Storage::DasdFormat
  include ::Y2Storage::StorageEnumWrapper
  CDL = ::T.let(nil, ::T.untyped)
  LDL = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
end

class Y2Storage::DasdFormat
  extend ::Y2Storage::StorageEnumWrapper::ClassMethods
end

class Y2Storage::DasdType
  include ::Y2Storage::StorageEnumWrapper
  ECKD = ::T.let(nil, ::T.untyped)
  FBA = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class Y2Storage::DasdType
  extend ::Y2Storage::StorageEnumWrapper::ClassMethods
end

class Y2Storage::DataTransport
  include ::Y2Storage::StorageEnumWrapper
  def network?(); end
  ATA = ::T.let(nil, ::T.untyped)
  FC = ::T.let(nil, ::T.untyped)
  FCOE = ::T.let(nil, ::T.untyped)
  ISCSI = ::T.let(nil, ::T.untyped)
  SAS = ::T.let(nil, ::T.untyped)
  SATA = ::T.let(nil, ::T.untyped)
  SBP = ::T.let(nil, ::T.untyped)
  SPI = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  USB = ::T.let(nil, ::T.untyped)
end

class Y2Storage::DataTransport
  extend ::Y2Storage::StorageEnumWrapper::ClassMethods
end

class Y2Storage::Device
  include ::Yast::Logger
  include ::Y2Storage::StorageClassWrapper
  def !=(other); end

  def ==(other); end

  def ancestors(); end

  def can_resize?(); end

  def children(*args); end

  def descendants(); end

  def detect_resize_info(*args); end

  def devicegraph(*args); end

  def eql?(other); end

  def etc_status_autoset=(value); end

  def etc_status_autoset?(); end

  def exists_in_devicegraph?(*args); end

  def exists_in_probed?(); end

  def exists_in_raw_probed?(*args); end

  def exists_in_staging?(*args); end

  def has_children?(*args); end

  def in_etc?(); end

  def is?(*types); end

  def num_children(*args); end

  def parents(*args); end

  def potential_orphans(); end

  def remove_descendants(); end

  def resize_info(); end

  def save_userdata(key, value); end

  def siblings(); end

  def sid(*args); end

  def storage_ancestors(*args); end

  def storage_descendants(*args); end

  def storage_eql(*args); end

  def storage_siblings(*args); end

  def types_for_is(); end

  def update_etc_attributes(); end

  def update_etc_status(); end

  def update_parents_etc_status(); end

  def userdata(*args); end

  def userdata=(*args); end

  def userdata_value(key); end
end

class Y2Storage::Device
  extend ::Yast::Logger
  extend ::Y2Storage::StorageClassWrapper::ClassMethods
  def self.compare_by_name(*args); end
end

class Y2Storage::DeviceNotFoundError
end

class Y2Storage::DeviceNotFoundError
end

class Y2Storage::Devicegraph
  include ::Yast::Logger
  include ::Y2Storage::StorageClassWrapper
  def !=(*args); end

  def ==(*args); end

  def actiongraph(from: T.unsafe(nil)); end

  def bios_raids(); end

  def blk_devices(); end

  def blk_filesystems(); end

  def check(*args); end

  def clear(*args); end

  def copy(*args); end

  def dasds(); end

  def disk_devices(); end

  def disks(); end

  def dm_raids(); end

  def dump(file_base_name=T.unsafe(nil)); end

  def duplicate(); end

  def empty?(*args); end

  def filesystem_in_network?(mountpoint); end

  def filesystems(); end

  def find_by_any_name(name); end

  def find_by_name(name); end

  def find_device(*args); end

  def free_spaces(); end

  def load(*args); end

  def lvm_lvs(); end

  def lvm_pvs(); end

  def lvm_vgs(); end

  def md_member_raids(); end

  def md_raids(); end

  def multipaths(); end

  def nfs_mounts(); end

  def partitions(); end

  def raids(); end

  def remove_btrfs_subvolume(subvol); end

  def remove_lvm_vg(vg); end

  def remove_md(md); end

  def remove_nfs(nfs); end

  def safe_copy(devicegraph); end

  def save(*args); end

  def software_raids(); end

  def to_str(); end

  def to_xml(); end

  def used_features(*args); end

  def write_graphviz(*args); end
end

class Y2Storage::Devicegraph
  extend ::Yast::Logger
  extend ::Y2Storage::StorageClassWrapper::ClassMethods
  def self.new_from_file(filename); end
end

class Y2Storage::DevicegraphSanitizer
  include ::Yast::I18n
  def devicegraph(); end

  def errors(); end

  def initialize(devicegraph); end

  def sanitized_devicegraph(); end
end

class Y2Storage::DevicegraphSanitizer::Error
  def device(); end

  def initialize(device, message); end

  def message(); end
end

class Y2Storage::DevicegraphSanitizer::Error
end

class Y2Storage::DevicegraphSanitizer
end

module Y2Storage::Dialogs
end

module Y2Storage::Dialogs::Callbacks
end

class Y2Storage::Dialogs::Callbacks::ActivateLuks
  include ::Y2Storage::SecretAttributes
  def accept_handler(); end

  def activate_button(); end

  def attempt(); end

  def encryption_password(); end

  def encryption_password=(value); end

  def explanation_widgets(); end

  def initialize(uuid, attempt); end

  def password(); end

  def password_handler(); end

  def uuid(); end
end

class Y2Storage::Dialogs::Callbacks::ActivateLuks
  extend ::Y2Storage::SecretAttributes::ClassMethods
end

module Y2Storage::Dialogs::Callbacks
  extend ::T::Sig
end

module Y2Storage::Dialogs
  extend ::T::Sig
end

class Y2Storage::Disk
  include ::Y2Storage::DiskDevice
  def rotational?(*args); end

  def transport(*args); end
end

class Y2Storage::Disk
  def self.create(*args); end
end

class Y2Storage::DiskAnalyzer
  include ::Yast::Logger
  def candidate_disks(); end

  def crypttabs(); end

  def device_by_name(name); end

  def fstabs(); end

  def initialize(devicegraph); end

  def installed_systems(*disks); end

  def linux_partitions(*disks); end

  def linux_systems(*disks); end

  def windows_partitions(*disks); end

  def windows_systems(*disks); end
  DEFAULT_CHECK_LIMIT = ::T.let(nil, ::T.untyped)
  NO_INSTALLATION_IDS = ::T.let(nil, ::T.untyped)
end

class Y2Storage::DiskAnalyzer
  extend ::Yast::Logger
end

module Y2Storage::DiskDevice
  def bios_raid_disk?(); end

  def disk_device?(); end

  def in_network?(); end

  def multipath_wire?(); end

  def types_for_is(); end

  def usb?(); end
end

module Y2Storage::DiskDevice
  extend ::T::Sig
end

class Y2Storage::DiskSize
  include ::Comparable
  def %(other); end

  def *(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def ceil(unit_size); end

  def floor(unit_size); end

  def human_ceil(); end

  def human_floor(); end

  def initialize(size=T.unsafe(nil)); end

  def power_of?(exp); end

  def pretty_print(*_); end

  def size(); end

  def to_human_string(rounding_method: T.unsafe(nil)); end

  def to_i(); end

  def to_storage_value(); end

  def unlimited?(); end

  def zero?(); end
  DEPRECATED_UNITS = ::T.let(nil, ::T.untyped)
  SI_UNITS = ::T.let(nil, ::T.untyped)
  UNITS = ::T.let(nil, ::T.untyped)
  UNLIMITED = ::T.let(nil, ::T.untyped)
end

class Y2Storage::DiskSize
  def self.B(v); end

  def self.EB(v); end

  def self.EiB(v); end

  def self.GB(v); end

  def self.GiB(v); end

  def self.KB(v); end

  def self.KiB(v); end

  def self.MB(v); end

  def self.MiB(v); end

  def self.PB(v); end

  def self.PiB(v); end

  def self.TB(v); end

  def self.TiB(v); end

  def self.YB(v); end

  def self.YiB(v); end

  def self.ZB(v); end

  def self.ZiB(v); end

  def self.from_human_string(str, legacy_units: T.unsafe(nil)); end

  def self.from_s(str, legacy_units: T.unsafe(nil)); end

  def self.parse(str, legacy_units: T.unsafe(nil)); end

  def self.sum(sizes, rounding: T.unsafe(nil)); end

  def self.unlimited(); end

  def self.zero(); end
end

class Y2Storage::DmRaid
  include ::Y2Storage::DiskDevice
  include ::Y2Storage::MultiDiskDevice
  def rotational?(*args); end

  def software_defined?(); end
end

class Y2Storage::DmRaid
  def self.create(*args); end
end

class Y2Storage::DumpManager
  include ::Singleton
  include ::Yast::Logger
  def base_dir(); end

  def devicegraph_dump_name(devicegraph); end

  def dump(dump_obj, file_base_name=T.unsafe(nil)); end

  def dump_actions(actions_presenter, file_base_name=T.unsafe(nil)); end

  def dump_devicegraph(devicegraph, file_base_name=T.unsafe(nil)); end

  def dump_dir(); end

  def installation?(); end

  def kill_all_dump_dirs(); end

  def reset(); end

  def rotate_dump_dirs(); end
  KEEP_OLD_DUMP_DIRS = ::T.let(nil, ::T.untyped)
end

class Y2Storage::DumpManager
  extend ::Singleton::SingletonClassMethods
  extend ::Yast::Logger
  def self.dump(dump_obj, file_base_name=T.unsafe(nil)); end

  def self.instance(); end
end

class Y2Storage::EncryptPasswordChecker
  include ::Yast::Logger
  include ::Yast::I18n
  def error_msg(passwd, repeat_passwd); end

  def tear_down(); end

  def warning_msg(passwd); end
end

class Y2Storage::EncryptPasswordChecker
  extend ::Yast::Logger
end

class Y2Storage::Encryption
  def assign_dm_table_name(*args); end

  def assign_etc_attribute(value); end

  def auto_dm_name=(value); end

  def auto_dm_name?(); end

  def blk_device(*args); end

  def dm_table_name=(name); end

  def in_etc_crypttab?(*args); end

  def password(*args); end

  def password=(*args); end
end

class Y2Storage::Encryption
  def self.dm_name_for(device); end

  def self.update_dm_names(devicegraph); end

  def self.use_crypttab_names(devicegraph, crypttab); end
end

class Y2Storage::Error
end

class Y2Storage::Error
end

class Y2Storage::ExistingFilesystem
  include ::Yast::Logger
  def crypttab(); end

  def device(); end

  def filesystem(); end

  def fstab(); end

  def initialize(filesystem, root=T.unsafe(nil), mount_point=T.unsafe(nil)); end

  def mount(); end

  def processed(); end

  def processed?(); end

  def read_crypttab(); end

  def read_fstab(); end

  def read_release_name(); end

  def release_name(); end

  def set_attributes(); end

  def umount(); end
end

class Y2Storage::ExistingFilesystem
  extend ::Yast::Logger
end

class Y2Storage::FakeDeviceFactory
  def add_defaults_for_dasd(args); end

  def add_mount_point(filesystem, fs_param); end

  def assign_file_system_params(file_system, fs_param); end

  def create_btrfs(parent, args); end

  def create_dasd(_parent, args); end

  def create_disk(_parent, args); end

  def create_encryption(parent, args); end

  def create_file_system(parent, args); end

  def create_free(parent, args); end

  def create_lvm_lv(parent, args); end

  def create_lvm_lv_stripe_parameters(lvm_lv, args); end

  def create_lvm_pv(parent, args); end

  def create_lvm_vg(_parent, args); end

  def create_partition(parent, args); end

  def create_partition_table(parent, args); end

  def create_subvolume(parent, args); end

  def dependencies(); end

  def encryption_name(name, parent); end

  def file_system_data_picker(name, args); end

  def file_system_directly_on_disk(disk, args); end

  def fixup_param(name, param); end

  def new_partitionable(partitionable_class, args); end

  def processed_encryption_name(name, parent); end

  def set_topology_attributes!(disk, args); end

  def str_to_ptable_type(string); end

  def valid_hierarchy(); end

  def valid_param(); end

  def valid_toplevel(); end
  DEPENDENCIES = ::T.let(nil, ::T.untyped)
  FILE_SYSTEM_PARAM = ::T.let(nil, ::T.untyped)
  VALID_HIERARCHY = ::T.let(nil, ::T.untyped)
  VALID_PARAM = ::T.let(nil, ::T.untyped)
  VALID_TOPLEVEL = ::T.let(nil, ::T.untyped)
end

class Y2Storage::FakeDeviceFactory
  def self.load_yaml_file(devicegraph, input_file); end
end

class Y2Storage::Filesystems::Base
  def compute_free_space(); end

  def detect_space_info(*args); end

  def free_space(); end

  def in_network?(); end

  def match_fstab_spec?(spec); end

  def type(*args); end
  FREE_SPACE_FALLBACK = ::T.let(nil, ::T.untyped)
end

class Y2Storage::Filesystems::Base
end

class Y2Storage::Filesystems::BlkFilesystem
  def blk_devices(*args); end

  def can_configure_snapper?(); end

  def detect_content_info(*args); end

  def label(*args); end

  def label=(*args); end

  def max_labelsize(*args); end

  def mkfs_options(*args); end

  def mkfs_options=(*args); end

  def plain_blk_devices(); end

  def supports_btrfs_subvolumes?(); end

  def supports_grow?(*args); end

  def supports_label?(*args); end

  def supports_resize?(); end

  def supports_shrink?(*args); end

  def supports_uuid?(*args); end

  def tune_options(*args); end

  def tune_options=(*args); end

  def uuid(*args); end

  def uuid=(*args); end

  def volume_specification(); end
end

class Y2Storage::Filesystems::BlkFilesystem
end

class Y2Storage::Filesystems::Btrfs
  def add_auto_deleted_subvolume(path, nocow); end

  def add_btrfs_subvolumes(specs); end

  def auto_deleted_subvolumes(); end

  def auto_deleted_subvolumes=(subvolumes); end

  def btrfs_subvolume_mount_point(subvolume_path); end

  def btrfs_subvolume_path(subvolume_path); end

  def btrfs_subvolumes(*args); end

  def canonical_subvolume_name(path); end

  def configure_snapper(*args); end

  def configure_snapper=(*args); end

  def copy_mount_by_to_subvolumes(); end

  def create_btrfs_subvolume(path, nocow); end

  def default_btrfs_subvolume(*args); end

  def default_configure_snapper?(); end

  def delete_btrfs_subvolume(path); end

  def ensure_default_btrfs_subvolume(path: T.unsafe(nil)); end

  def find_btrfs_subvolume_by_path(*args); end

  def path_without_prefix(subvolume_path); end

  def remove_auto_deleted_subvolume(path); end

  def remove_shadowed_subvolumes(); end

  def restore_unshadowed_subvolumes(); end

  def setup_default_btrfs_subvolumes(); end

  def shadow_btrfs_subvolume(path); end

  def snapshots?(); end

  def snapshots_root(); end

  def subvolume_can_be_created?(path); end

  def subvolume_descendants(path); end

  def subvolumes_prefix(); end

  def top_level_btrfs_subvolume(*args); end

  def unshadow_btrfs_subvolume(path); end
  SNAPSHOTS_ROOT_SUBVOL_NAME = ::T.let(nil, ::T.untyped)
end

class Y2Storage::Filesystems::Btrfs
  def self.btrfs_subvolume_mount_point(fs_mount_path, subvolume_path); end

  def self.btrfs_subvolume_path(subvolumes_prefix, subvolume_path); end

  def self.refresh_subvolumes_shadowing(devicegraph); end
end

class Y2Storage::Filesystems::LegacyNfs
  include ::Yast::Logger
  def check_devicegraph_argument(devicegraph); end

  def create_nfs_device(devicegraph=T.unsafe(nil)); end

  def default_devicegraph(); end

  def default_devicegraph=(default_devicegraph); end

  def find_nfs_device(devicegraph=T.unsafe(nil)); end

  def fs_type(); end

  def fstopt(); end

  def initialize_from_hash(attributes); end

  def initialize_from_nfs(nfs); end

  def mountpoint(); end

  def old_path(); end

  def old_server(); end

  def path(); end

  def server(); end

  def share(); end

  def share_changed?(); end

  def share_string(svr, dir); end

  def split_share(share_string); end

  def to_hash(); end

  def update_nfs_device(devicegraph=T.unsafe(nil)); end
end

class Y2Storage::Filesystems::LegacyNfs
  extend ::Yast::Logger
  def self.new_from_hash(legacy_hash); end

  def self.new_from_nfs(nfs); end
end

class Y2Storage::Filesystems::MountByType
  include ::Y2Storage::StorageEnumWrapper
  include ::Yast::I18n
  def to_human_string(); end
  DEVICE = ::T.let(nil, ::T.untyped)
  ID = ::T.let(nil, ::T.untyped)
  LABEL = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PROPERTIES = ::T.let(nil, ::T.untyped)
  UUID = ::T.let(nil, ::T.untyped)
end

class Y2Storage::Filesystems::MountByType
  extend ::Y2Storage::StorageEnumWrapper::ClassMethods
  extend ::Yast::I18n
  def self.from_fstab_spec(spec); end
end

class Y2Storage::Filesystems::Nfs
  def name(); end

  def path(*args); end

  def reachable?(); end

  def server(*args); end

  def share(); end

  def to_legacy_hash(); end
end

class Y2Storage::Filesystems::Nfs
  def self.create(*args); end

  def self.find_by_server_and_path(*args); end
end

class Y2Storage::Filesystems::Type
  include ::Y2Storage::StorageEnumWrapper
  def boot_fstab_options(opt); end

  def codepage(); end

  def default_fstab_options(mount_path=T.unsafe(nil)); end

  def default_mount_options(mount_path=T.unsafe(nil)); end

  def default_partition_id(); end

  def home_ok?(); end

  def iocharset(); end

  def label_valid_chars(); end

  def lang_typical_encoding(); end

  def legacy_home?(); end

  def legacy_root?(); end

  def patch_codepage(fstab_options); end

  def patch_iocharset(fstab_options); end

  def root_fstab_options(opt); end

  def root_ok?(); end

  def special_path_fstab_options(opt, mount_path=T.unsafe(nil)); end

  def supported_fstab_options(); end

  def to_human(); end

  def to_human_string(); end

  def zipl_ok?(); end
  ALPHANUM = ::T.let(nil, ::T.untyped)
  AUTO = ::T.let(nil, ::T.untyped)
  DEFAULT_CODEPAGE = ::T.let(nil, ::T.untyped)
  EXT2 = ::T.let(nil, ::T.untyped)
  EXT3 = ::T.let(nil, ::T.untyped)
  EXT4 = ::T.let(nil, ::T.untyped)
  HFS = ::T.let(nil, ::T.untyped)
  HFSPLUS = ::T.let(nil, ::T.untyped)
  ISO9660 = ::T.let(nil, ::T.untyped)
  JFS = ::T.let(nil, ::T.untyped)
  LABEL_VALID_CHARS = ::T.let(nil, ::T.untyped)
  MINIX = ::T.let(nil, ::T.untyped)
  NFS = ::T.let(nil, ::T.untyped)
  NFS4 = ::T.let(nil, ::T.untyped)
  NILFS2 = ::T.let(nil, ::T.untyped)
  NTFS = ::T.let(nil, ::T.untyped)
  NTFS3G = ::T.let(nil, ::T.untyped)
  REISERFS = ::T.let(nil, ::T.untyped)
  SWAP = ::T.let(nil, ::T.untyped)
  TMPFS = ::T.let(nil, ::T.untyped)
  UDF = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VFAT = ::T.let(nil, ::T.untyped)
end

class Y2Storage::Filesystems::Type
  extend ::Y2Storage::StorageEnumWrapper::ClassMethods
  def self.home_filesystems(); end

  def self.legacy_home_filesystems(); end

  def self.legacy_root_filesystems(); end

  def self.root_filesystems(); end

  def self.zipl_filesystems(); end
end

module Y2Storage::Filesystems
  extend ::T::Sig
end

class Y2Storage::FreeDiskSpace
  def align_grain(); end

  def disk(); end

  def disk_name(); end

  def disk_size(); end

  def initialize(disk, region); end

  def region(); end

  def require_end_alignment?(); end

  def reused_partition?(); end

  def start_offset(); end
end

class Y2Storage::FreeDiskSpace
end

class Y2Storage::Fstab
  include ::Yast::Logger
  def device(); end

  def entries(); end

  def filesystem(); end

  def filesystem_entries(); end

  def initialize(path=T.unsafe(nil), filesystem=T.unsafe(nil)); end
end

class Y2Storage::Fstab
  extend ::Yast::Logger
end

class Y2Storage::GuidedProposal
  def initialize(settings: T.unsafe(nil), devicegraph: T.unsafe(nil), disk_analyzer: T.unsafe(nil)); end

  def settings(); end
end

class Y2Storage::GuidedProposal
  def self.initial(settings: T.unsafe(nil), devicegraph: T.unsafe(nil), disk_analyzer: T.unsafe(nil)); end
end

class Y2Storage::HWInfoReader
  include ::Singleton
  def for_device(name); end

  def reset(); end
  BUS_REGEXP = ::T.let(nil, ::T.untyped)
  DEVICE_REGEXP = ::T.let(nil, ::T.untyped)
  MULTI_VALUED = ::T.let(nil, ::T.untyped)
end

class Y2Storage::HWInfoReader
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module Y2Storage::InstDialogMixin
  def without_title_on_left(&block); end
end

module Y2Storage::InstDialogMixin
  extend ::T::Sig
end

class Y2Storage::LvType
  include ::Y2Storage::StorageEnumWrapper
  NORMAL = ::T.let(nil, ::T.untyped)
  RAID = ::T.let(nil, ::T.untyped)
  THIN = ::T.let(nil, ::T.untyped)
  THIN_POOL = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class Y2Storage::LvType
  extend ::Y2Storage::StorageEnumWrapper::ClassMethods
end

class Y2Storage::LvmLv
  def create_lvm_lv(*args); end

  def lv_name(*args); end

  def lv_type(*args); end

  def lvm_lvs(*args); end

  def lvm_vg(*args); end

  def max_size_for_lvm_lv(*args); end

  def overcommitted?(); end

  def resize(new_size); end

  def stripe_size(*args); end

  def stripe_size=(*args); end

  def stripes(*args); end

  def stripes=(*args); end
end

class Y2Storage::LvmLv
end

class Y2Storage::LvmPv
  def blk_device(*args); end

  def lvm_vg(*args); end

  def plain_blk_device(); end
end

class Y2Storage::LvmPv
  def self.all(*args); end
end

class Y2Storage::LvmVg
  include ::Y2Storage::ComparableByName
  def add_lvm_pv(*args); end

  def all_lvm_lvs(); end

  def available_space(); end

  def basename(*args); end

  def create_lvm_lv(*args); end

  def delete_lvm_lv(*args); end

  def extent_size(*args); end

  def extent_size=(*args); end

  def lvm_lvs(*args); end

  def lvm_pvs(*args); end

  def max_size_for_lvm_lv(*args); end

  def name(); end

  def number_of_extents(*args); end

  def number_of_free_extents(*args); end

  def number_of_used_extents(*args); end

  def overcommitted?(*args); end

  def remove_lvm_pv(*args); end

  def size(*args); end

  def thin_lvm_lvs(); end

  def thin_pool_lvm_lvs(); end

  def total_size(); end

  def vg_name(*args); end

  def vg_name=(*args); end
end

class Y2Storage::LvmVg
  extend ::Y2Storage::ComparableByName::ClassMethods
  def self.all(*args); end

  def self.create(*args); end

  def self.find_by_vg_name(*args); end
end

module Y2Storage::MatchVolumeSpec
  def match_fs_type?(volume); end

  def match_mount_point?(volume); end

  def match_partition_id?(volume); end

  def match_size?(volume); end

  def match_volume?(volume, exclude: T.unsafe(nil)); end

  def volume_match_values(); end
end

module Y2Storage::MatchVolumeSpec
  extend ::T::Sig
end

class Y2Storage::Md
  include ::Y2Storage::DiskDevice
  def add_device(*args); end

  def allowed_md_parities(*args); end

  def assign_etc_attribute(value); end

  def chunk_size(*args); end

  def chunk_size=(*args); end

  def devices(*args); end

  def in_etc_mdadm?(*args); end

  def md_level(*args); end

  def md_level=(*args); end

  def md_name(); end

  def md_name=(new_name); end

  def md_parity(*args); end

  def md_parity=(*args); end

  def md_users(); end

  def metadata(*args); end

  def minimal_number_of_devices(*args); end

  def number(*args); end

  def numeric?(*args); end

  def plain_devices(); end

  def push_device(device); end

  def remove_device(*args); end

  def software_defined?(); end

  def sorted_devices(); end

  def sorted_devices=(devs_list); end

  def sorted_plain_devices(); end

  def uuid(*args); end
end

class Y2Storage::Md
  def self.create(*args); end

  def self.find_free_numeric_name(*args); end
end

class Y2Storage::MdContainer
  def md_members(*args); end
end

class Y2Storage::MdContainer
  def self.all(devicegraph); end
end

class Y2Storage::MdLevel
  include ::Y2Storage::StorageEnumWrapper
  include ::Yast::I18n
  def to_human_string(); end
  CONTAINER = ::T.let(nil, ::T.untyped)
  RAID0 = ::T.let(nil, ::T.untyped)
  RAID1 = ::T.let(nil, ::T.untyped)
  RAID10 = ::T.let(nil, ::T.untyped)
  RAID4 = ::T.let(nil, ::T.untyped)
  RAID5 = ::T.let(nil, ::T.untyped)
  RAID6 = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class Y2Storage::MdLevel
  extend ::Y2Storage::StorageEnumWrapper::ClassMethods
  extend ::Yast::I18n
end

class Y2Storage::MdMember
  include ::Y2Storage::MultiDiskDevice
  def md_container(*args); end
end

class Y2Storage::MdMember
  def self.all(devicegraph); end
end

class Y2Storage::MdParity
  include ::Y2Storage::StorageEnumWrapper
  include ::Yast::I18n
  def to_human_string(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
  FAR_2 = ::T.let(nil, ::T.untyped)
  FAR_3 = ::T.let(nil, ::T.untyped)
  FIRST = ::T.let(nil, ::T.untyped)
  FIRST_6 = ::T.let(nil, ::T.untyped)
  LAST = ::T.let(nil, ::T.untyped)
  LEFT_ASYMMETRIC = ::T.let(nil, ::T.untyped)
  LEFT_ASYMMETRIC_6 = ::T.let(nil, ::T.untyped)
  LEFT_SYMMETRIC = ::T.let(nil, ::T.untyped)
  LEFT_SYMMETRIC_6 = ::T.let(nil, ::T.untyped)
  NEAR_2 = ::T.let(nil, ::T.untyped)
  NEAR_3 = ::T.let(nil, ::T.untyped)
  OFFSET_2 = ::T.let(nil, ::T.untyped)
  OFFSET_3 = ::T.let(nil, ::T.untyped)
  RIGHT_ASYMMETRIC = ::T.let(nil, ::T.untyped)
  RIGHT_ASYMMETRIC_6 = ::T.let(nil, ::T.untyped)
  RIGHT_SYMMETRIC = ::T.let(nil, ::T.untyped)
  RIGHT_SYMMETRIC_6 = ::T.let(nil, ::T.untyped)
end

class Y2Storage::MdParity
  extend ::Y2Storage::StorageEnumWrapper::ClassMethods
  extend ::Yast::I18n
end

class Y2Storage::MountPoint
  def active=(*args); end

  def active?(*args); end

  def filesystem(*args); end

  def freq(*args); end

  def in_etc_fstab?(*args); end

  def mount_by(*args); end

  def mount_by=(*args); end

  def mount_options(*args); end

  def mount_options=(options); end

  def mount_type(*args); end

  def mount_type=(*args); end

  def mountable(*args); end

  def passno(*args); end

  def passno_must_be_set?(); end

  def path(*args); end

  def path=(path); end

  def path?(other_path); end

  def possible_mount_bys(*args); end

  def root?(); end

  def set_default_mount_by(*args); end

  def set_default_mount_options(*args); end
  ROOT_PATH = ::T.let(nil, ::T.untyped)
  SWAP_PATH = ::T.let(nil, ::T.untyped)
end

class Y2Storage::MountPoint
  def self.all(*args); end

  def self.find_by_path(*args); end
end

class Y2Storage::Mountable
  def create_mount_point(path); end

  def mount_by(); end

  def mount_options(); end

  def mount_path(); end

  def mount_path=(path); end

  def mount_point(*args); end

  def persistent?(); end

  def remove_mount_point(); end

  def root?(); end
end

class Y2Storage::Mountable
  def self.all(*args); end
end

module Y2Storage::MultiDiskDevice
  def in_network?(); end

  def preferred_ptable_type(); end

  def usb?(); end
end

module Y2Storage::MultiDiskDevice
  extend ::T::Sig
end

class Y2Storage::Multipath
  include ::Y2Storage::DiskDevice
  include ::Y2Storage::MultiDiskDevice
  def rotational?(*args); end
end

class Y2Storage::Multipath
  def self.create(*args); end
end

class Y2Storage::NoDiskSpaceError
end

class Y2Storage::NoDiskSpaceError
end

class Y2Storage::NoMorePartitionSlotError
end

class Y2Storage::NoMorePartitionSlotError
end

class Y2Storage::NotBootableError
end

class Y2Storage::NotBootableError
end

class Y2Storage::PackageHandler
  include ::Yast::Logger
  include ::Yast::I18n
  def add_feature_packages(devicegraph); end

  def add_packages(pkg_list); end

  def commit(); end

  def compact(); end

  def install(); end

  def pkg_list(); end

  def reset(); end

  def set_proposal_packages(); end

  def solve(); end

  def unavailable_optional_package?(package); end
  PROPOSAL_ID = ::T.let(nil, ::T.untyped)
end

class Y2Storage::PackageHandler
  extend ::Yast::Logger
end

class Y2Storage::Partition
  def adapted_id=(partition_id); end

  def align_grain(align_type=T.unsafe(nil)); end

  def aligned_min_size(align_type=T.unsafe(nil)); end

  def aligned_region(align_type, fallback); end

  def boot=(*args); end

  def boot?(*args); end

  def disk(); end

  def end_aligned?(align_type=T.unsafe(nil)); end

  def id(*args); end

  def id=(*args); end

  def implicit?(); end

  def legacy_boot=(*args); end

  def legacy_boot?(*args); end

  def number(*args); end

  def partition_table(*args); end

  def partitionable(*args); end

  def resize(new_size, align_type: T.unsafe(nil)); end

  def start_aligned?(align_type=T.unsafe(nil)); end

  def type(*args); end

  def type=(*args); end
end

class Y2Storage::Partition
  def self.all(devicegraph); end

  def self.create(*args); end
end

class Y2Storage::PartitionId
  include ::Yast::I18n
  include ::Y2Storage::StorageEnumWrapper
  include ::Yast::Logger
  def formattable?(); end

  def to_human_string(); end

  def to_i_legacy(); end
  BIOS_BOOT = ::T.let(nil, ::T.untyped)
  DIAG = ::T.let(nil, ::T.untyped)
  DOS12 = ::T.let(nil, ::T.untyped)
  DOS16 = ::T.let(nil, ::T.untyped)
  DOS32 = ::T.let(nil, ::T.untyped)
  ESP = ::T.let(nil, ::T.untyped)
  EXTENDED = ::T.let(nil, ::T.untyped)
  LINUX = ::T.let(nil, ::T.untyped)
  LVM = ::T.let(nil, ::T.untyped)
  MICROSOFT_RESERVED = ::T.let(nil, ::T.untyped)
  NTFS = ::T.let(nil, ::T.untyped)
  PREP = ::T.let(nil, ::T.untyped)
  RAID = ::T.let(nil, ::T.untyped)
  SWAP = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  WINDOWS_BASIC_DATA = ::T.let(nil, ::T.untyped)
end

class Y2Storage::PartitionId
  extend ::Yast::I18n
  extend ::Y2Storage::StorageEnumWrapper::ClassMethods
  extend ::Yast::Logger
  def self.linux_system_ids(); end

  def self.new_from_legacy(number); end

  def self.windows_system_ids(); end
end

module Y2Storage::PartitionTables
end

class Y2Storage::PartitionTables::Base
  def align(*args); end

  def align_end(region, align_type=T.unsafe(nil), max_end: T.unsafe(nil)); end

  def align_grain(align_type=T.unsafe(nil)); end

  def create_partition(name, region, type, *extra_args); end

  def delete_all_partitions(); end

  def delete_partition(partition, *extra_args); end

  def extended_possible?(*args); end

  def free_spaces(); end

  def has_extended?(*args); end

  def max_logical(*args); end

  def max_logical?(); end

  def max_primary(*args); end

  def max_primary?(); end

  def num_logical(*args); end

  def num_primary(*args); end

  def partition_boot_flag_supported?(*args); end

  def partition_id_for(partition_id); end

  def partition_id_supported?(*args); end

  def partition_legacy_boot_flag_supported?(*args); end

  def partitionable(*args); end

  def partitions(*args); end

  def require_end_alignment?(); end

  def storage_create_partition(*args); end

  def storage_delete_partition(*args); end

  def supported_partition_ids(); end

  def type(*args); end

  def unused_partition_slots(*args); end

  def unused_slot_for(region, align_policy: T.unsafe(nil), align_type: T.unsafe(nil)); end
end

class Y2Storage::PartitionTables::Base
end

class Y2Storage::PartitionTables::Dasd
end

class Y2Storage::PartitionTables::Dasd
end

class Y2Storage::PartitionTables::Gpt
  def pmbr_boot=(*args); end

  def pmbr_boot?(*args); end
end

class Y2Storage::PartitionTables::Gpt
end

class Y2Storage::PartitionTables::ImplicitPt
  def partition(); end
end

class Y2Storage::PartitionTables::ImplicitPt
end

class Y2Storage::PartitionTables::Msdos
  def mbr_gap(); end

  def minimal_mbr_gap(*args); end

  def minimal_mbr_gap=(*args); end
end

class Y2Storage::PartitionTables::Msdos
end

class Y2Storage::PartitionTables::PartitionSlot
  include ::Y2Storage::StorageClassWrapper
  def available?(); end

  def name(*args); end

  def nr(*args); end

  def possible?(*args); end

  def region(*args); end
end

class Y2Storage::PartitionTables::PartitionSlot
  extend ::Y2Storage::StorageClassWrapper::ClassMethods
end

class Y2Storage::PartitionTables::Type
  include ::Y2Storage::StorageEnumWrapper
  def to_human_string(); end
  DASD = ::T.let(nil, ::T.untyped)
  GPT = ::T.let(nil, ::T.untyped)
  IMPLICIT = ::T.let(nil, ::T.untyped)
  LOOP = ::T.let(nil, ::T.untyped)
  MAC = ::T.let(nil, ::T.untyped)
  MSDOS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class Y2Storage::PartitionTables::Type
  extend ::Y2Storage::StorageEnumWrapper::ClassMethods
end

module Y2Storage::PartitionTables
  extend ::T::Sig
end

class Y2Storage::PartitionType
  include ::Y2Storage::StorageEnumWrapper
  EXTENDED = ::T.let(nil, ::T.untyped)
  LOGICAL = ::T.let(nil, ::T.untyped)
  PRIMARY = ::T.let(nil, ::T.untyped)
end

class Y2Storage::PartitionType
  extend ::Y2Storage::StorageEnumWrapper::ClassMethods
end

class Y2Storage::Partitionable
  def as_not_empty(); end

  def create_partition_table(*args); end

  def delete_partition_table(); end

  def efi_partitions(); end

  def ensure_partition_table(); end

  def free_spaces(); end

  def gpt?(); end

  def grub_partitions(); end

  def implicit_partition_table?(); end

  def linux_system_partitions(); end

  def mbr_gap(); end

  def name_or_partition?(name); end

  def partition_table(*args); end

  def partitions(); end

  def partitions_with_id(*ids); end

  def possible_partition_table_types(*args); end

  def possible_windows_partitions(); end

  def preferred_ptable_type(); end

  def prep_partitions(); end

  def range(*args); end

  def range=(*args); end

  def swap_partitions(); end

  def topology(*args); end

  def usable_as_partitionable?(*args); end
end

class Y2Storage::Partitionable
  def self.find_by_name_or_partition(devicegraph, name); end
end

module Y2Storage::PartitioningFeatures
  def feature(*feature, source: T.unsafe(nil)); end

  def load_feature(*feature, to: T.unsafe(nil), source: T.unsafe(nil)); end

  def load_integer_feature(*feature, to: T.unsafe(nil), source: T.unsafe(nil)); end

  def load_size_feature(*feature, to: T.unsafe(nil), source: T.unsafe(nil)); end

  def load_subvolumes_feature(*feature, to: T.unsafe(nil), source: T.unsafe(nil)); end

  def load_volumes_feature(*feature, to: T.unsafe(nil), source: T.unsafe(nil)); end
end

module Y2Storage::PartitioningFeatures
  extend ::T::Sig
end

module Y2Storage::Planned
end

class Y2Storage::Planned::AssignedSpace
  def align_grain(); end

  def compare(one, other, attrs, nils_first, descending); end

  def compare_attr(one, other, attr, nils_first, descending); end

  def compare_values(one, other, descending); end

  def compare_with_nil(one, other, nils_first); end

  def disk(); end

  def disk_name(); end

  def disk_size(); end

  def disk_space(); end

  def enforced_last(); end

  def extended_partition(); end

  def extra_size(); end

  def initialize(disk_space, planned_partitions); end

  def inside_extended?(); end

  def num_logical(); end

  def num_logical=(num_logical); end

  def overhead_of_logical(); end

  def partition_type(); end

  def partitions(); end

  def partitions_sorted_by_attr(*attrs, nils_first: T.unsafe(nil), descending: T.unsafe(nil)); end

  def primary_partitions_fit?(); end

  def region(); end

  def require_end_alignment?(); end

  def sort_partitions!(); end

  def space_start(); end

  def total_weight(); end

  def unused(); end

  def usable_extra_size(); end

  def usable_size(); end

  def valid?(); end

  def wrong_usage_of_reused_partition?(); end
end

class Y2Storage::Planned::AssignedSpace
  def self.overhead_of_logical(disk); end
end

module Y2Storage::Planned::CanBeEncrypted
  include ::Y2Storage::SecretAttributes
  def create_encryption?(); end

  def encrypt?(); end

  def encryption_password(); end

  def encryption_password=(value); end

  def final_device!(plain_device); end

  def initialize_can_be_encrypted(); end
end

module Y2Storage::Planned::CanBeEncrypted::ClassMethods
  def encryption_overhead(); end
end

module Y2Storage::Planned::CanBeEncrypted::ClassMethods
  extend ::T::Sig
end

module Y2Storage::Planned::CanBeEncrypted
  extend ::Y2Storage::SecretAttributes::ClassMethods
  extend ::T::Sig
  def self.included(base); end
end

module Y2Storage::Planned::CanBeFormatted
  def assign_mount_point(filesystem); end

  def btrfs?(); end

  def btrfs_setup(filesystem); end

  def default_subvolume(); end

  def default_subvolume=(default_subvolume); end

  def filesystem_type(); end

  def filesystem_type=(filesystem_type); end

  def format!(blk_dev); end

  def fstab_options_for(mount_point); end

  def initialize_can_be_formatted(); end

  def label(); end

  def label=(label); end

  def mkfs_options(); end

  def mkfs_options=(mkfs_options); end

  def mount_point_for(device); end

  def reformat(); end

  def reformat=(reformat); end

  def reformat?(); end

  def reuse_device!(device); end

  def setup_filesystem(filesystem); end

  def setup_fstab_options(mount_point); end

  def setup_mount_point(filesystem); end

  def shadowed_subvolumes(all_devices); end

  def snapshots=(snapshots); end

  def snapshots?(); end

  def subvolumes(); end

  def subvolumes=(list); end

  def subvolumes?(); end

  def uuid(); end

  def uuid=(uuid); end
end

module Y2Storage::Planned::CanBeFormatted
  extend ::T::Sig
end

module Y2Storage::Planned::CanBeMounted
  def fstab_options(); end

  def fstab_options=(fstab_options); end

  def initialize_can_be_mounted(); end

  def mount_by(); end

  def mount_by=(mount_by); end

  def mount_point(); end

  def mount_point=(mount_point); end

  def read_only(); end

  def read_only=(read_only); end

  def root?(); end

  def swap?(); end
end

module Y2Storage::Planned::CanBeMounted
  extend ::T::Sig
end

module Y2Storage::Planned::CanBePv
  def initialize_can_be_pv(); end

  def lvm_pv?(); end

  def lvm_volume_group_name(); end

  def lvm_volume_group_name=(lvm_volume_group_name); end

  def pv_for?(vg_name); end
end

module Y2Storage::Planned::CanBePv
  extend ::T::Sig
end

module Y2Storage::Planned::CanBeResized
  def resize(); end

  def resize=(resize); end

  def resize?(); end

  def resize_device!(device, resize_info); end

  def reuse_device!(device); end

  def shrink?(devicegraph); end
end

module Y2Storage::Planned::CanBeResized
  extend ::T::Sig
end

class Y2Storage::Planned::Device
  include ::Yast::Logger
  def ==(other); end

  def device_to_reuse(devicegraph); end

  def final_device!(plain_device); end

  def internal_state(); end

  def planned_id(); end

  def reuse!(devicegraph); end

  def reuse?(); end

  def reuse_device!(dev); end

  def reuse_name(); end

  def reuse_name=(reuse_name); end

  def reuse_sid(); end

  def reuse_sid=(reuse_sid); end
end

class Y2Storage::Planned::Device
  extend ::Yast::Logger
  def self.to_string_attrs(); end
end

module Y2Storage::Planned::HasSize
  def initialize_has_size(); end

  def max(); end

  def max=(max); end

  def max_size(); end

  def max_size=(max_size); end

  def min(); end

  def min=(min); end

  def min_size(); end

  def min_size=(min_size); end

  def size(); end

  def size=(size); end

  def weight(); end

  def weight=(weight); end
end

module Y2Storage::Planned::HasSize::ClassMethods
  include ::Yast::Logger
  def adjust_size_to_last_slot(device, space_size, align_grain); end

  def adjusted_size_after_ceil(device, space_size, align_grain); end

  def device_extra_size(device, total_size, total_weight, assigned_size, rounding); end

  def distributable?(size, rounding); end

  def distribute_extra_space!(candidates, extra_size, rounding); end

  def distribute_space(devices, space_size, rounding: T.unsafe(nil), align_grain: T.unsafe(nil), end_alignment: T.unsafe(nil)); end

  def extra_space_candidates(devices); end

  def total_weight(devices); end
end

module Y2Storage::Planned::HasSize::ClassMethods
  extend ::Yast::Logger
  extend ::T::Sig
end

module Y2Storage::Planned::HasSize
  extend ::T::Sig
  def self.included(base); end
end

class Y2Storage::Planned::LvmLv
  include ::Y2Storage::Planned::HasSize
  include ::Y2Storage::Planned::CanBeFormatted
  include ::Y2Storage::Planned::CanBeResized
  include ::Y2Storage::Planned::CanBeMounted
  include ::Y2Storage::Planned::CanBeEncrypted
  include ::Y2Storage::SecretAttributes
  include ::Y2Storage::MatchVolumeSpec
  def add_thin_lv(lv); end

  def initialize(mount_point, filesystem_type=T.unsafe(nil)); end

  def initialize_from_real_lv(real_lv); end

  def logical_volume_name(); end

  def logical_volume_name=(logical_volume_name); end

  def lv_type(); end

  def lv_type=(lv_type); end

  def percent_size(); end

  def percent_size=(percent_size); end

  def real_size_in(container); end

  def size_in(container); end

  def size_in_percentage(container); end

  def size_in_thin_pool(thin_pool); end

  def stripe_size(); end

  def stripe_size=(stripe_size); end

  def stripes(); end

  def stripes=(stripes); end

  def thin_lvs(); end

  def thin_pool(); end

  def thin_pool=(thin_pool); end
end

class Y2Storage::Planned::LvmLv
  extend ::Y2Storage::Planned::HasSize::ClassMethods
  extend ::Y2Storage::Planned::CanBeEncrypted::ClassMethods
  def self.from_real_lv(real_lv); end
end

class Y2Storage::Planned::LvmVg
  include ::Y2Storage::Planned::HasSize
  def all_lvs(); end

  def extent_size(); end

  def extent_size=(extent_size); end

  def initialize(volume_group_name: T.unsafe(nil), lvs: T.unsafe(nil), pvs: T.unsafe(nil)); end

  def initialize_from_real_vg(real_vg); end

  def lvs(); end

  def lvs=(lvs); end

  def make_space_policy(); end

  def make_space_policy=(make_space_policy); end

  def pvs(); end

  def pvs=(pvs); end

  def target_size(); end

  def thin_pool_lvs(); end

  def total_size(); end

  def volume_group_name(); end

  def volume_group_name=(volume_group_name); end
end

class Y2Storage::Planned::LvmVg
  extend ::Y2Storage::Planned::HasSize::ClassMethods
  def self.from_real_vg(real_vg); end
end

class Y2Storage::Planned::Md
  include ::Y2Storage::Planned::CanBeFormatted
  include ::Y2Storage::Planned::CanBeMounted
  include ::Y2Storage::Planned::CanBeEncrypted
  include ::Y2Storage::SecretAttributes
  include ::Y2Storage::Planned::CanBePv
  include ::Y2Storage::MatchVolumeSpec
  def add_devices(md_device, devices); end

  def chunk_size(); end

  def chunk_size=(chunk_size); end

  def devices_order(); end

  def devices_order=(devices_order); end

  def initialize(name: T.unsafe(nil)); end

  def md_level(); end

  def md_level=(md_level); end

  def md_parity(); end

  def md_parity=(md_parity); end

  def name(); end

  def name=(name); end
end

class Y2Storage::Planned::Md
  extend ::Y2Storage::Planned::CanBeEncrypted::ClassMethods
end

class Y2Storage::Planned::Partition
  include ::Y2Storage::Planned::HasSize
  include ::Y2Storage::Planned::CanBeFormatted
  include ::Y2Storage::Planned::CanBeResized
  include ::Y2Storage::Planned::CanBeMounted
  include ::Y2Storage::Planned::CanBeEncrypted
  include ::Y2Storage::SecretAttributes
  include ::Y2Storage::Planned::CanBePv
  include ::Y2Storage::MatchVolumeSpec
  def bootable(); end

  def bootable=(bootable); end

  def disk(); end

  def disk=(disk); end

  def initialize(mount_point, filesystem_type=T.unsafe(nil)); end

  def max_start_offset(); end

  def max_start_offset=(max_start_offset); end

  def partition_id(); end

  def partition_id=(partition_id); end

  def primary(); end

  def primary=(primary); end

  def raid_name(); end

  def raid_name=(raid_name); end
end

class Y2Storage::Planned::Partition
  extend ::Y2Storage::Planned::HasSize::ClassMethods
  extend ::Y2Storage::Planned::CanBeEncrypted::ClassMethods
end

class Y2Storage::Planned::PartitionsDistribution
  include ::Yast::Logger
  def add_partitions(partitions_by_disk_space); end

  def assigned_space(disk_space, partitions); end

  def better_than(other); end

  def calculate_num_logical_for(spaces, ptable); end

  def calculate_num_logical_with_new_extended(spaces, ptable); end

  def calculate_weight_space_deviation(); end

  def comparable_string(); end

  def extended_space(spaces, num_logical); end

  def gaps_count(); end

  def gaps_total_size(); end

  def initialize(partitions_by_disk_space); end

  def num_partitions(spaces); end

  def partitions_comparable_string(partitions); end

  def partitions_count(); end

  def room_for_logical?(assigned_space, num); end

  def set_num_logical(assigned_space, num); end

  def set_num_logical_for(spaces, ptable); end

  def space_at(disk_space); end

  def space_comparable_string(space); end

  def spaces(); end

  def spaces_by_disk(); end

  def spaces_count(); end

  def spaces_total_size(); end

  def too_many_primary?(spaces, ptable); end

  def too_many_primary_with_extended?(primary_spaces, ptable); end

  def unassigned_spaces(); end

  def weight_space_deviation(); end
end

class Y2Storage::Planned::PartitionsDistribution
  extend ::Yast::Logger
  def self.partitions_in_new_extended(partitions, ptable); end
end

module Y2Storage::Planned
  extend ::T::Sig
end

module Y2Storage::Proposal
end

class Y2Storage::Proposal::AutoinstCreatorResult
  def created_names(*args, &block); end

  def devicegraph(*args, &block); end

  def devices_map(*args, &block); end

  def initialize(creator_result, planned_devices); end

  def missing_space(); end

  def planned_devices(); end

  def real_device_by_planned_id(planned_id); end

  def shrinked_lvs(); end

  def shrinked_partitions(); end
end

class Y2Storage::Proposal::AutoinstCreatorResult
  extend ::Forwardable
end

class Y2Storage::Proposal::AutoinstDevicesCreator
  include ::Yast::Logger
  def best_distribution(planned_partitions, disk_names); end

  def initialize(original_graph); end

  def original_graph(); end

  def populated_devicegraph(planned_devices, disk_names); end
end

class Y2Storage::Proposal::AutoinstDevicesCreator
  extend ::Yast::Logger
end

class Y2Storage::Proposal::AutoinstDevicesPlanner
  include ::Yast::Logger
  def add_common_device_attrs(device, section); end

  def add_device_reuse(device, name, section); end

  def add_lv_reuse(lv, vg_name, section); end

  def add_md_reuse(md, section); end

  def add_partition_reuse(partition, section); end

  def add_snapshots(device, drive_section); end

  def add_stripes(lv, section); end

  def add_subvolumes_attrs(device, section); end

  def add_thin_pool_lv_reuse(lv, _drive); end

  def add_to_thin_pool(lv, vg, section); end

  def add_vg_reuse(vg, drive); end

  def assign_size_to_lv(vg, lv, lv_section); end

  def assign_size_to_partition(disk, partition, part_section); end

  def chunk_size_from_string(string); end

  def default_filesystem_for(section); end

  def device_config(device, partition_section, drive_section); end

  def devicegraph(); end

  def filesystem_for(section); end

  def find_lv_parent(vg_name, part_section); end

  def find_lv_to_reuse(vg_name, part_section); end

  def find_partition_to_reuse(part_section); end

  def find_thin_pool_lv(vg, part_section); end

  def find_vg_to_reuse(vg, drive); end

  def initialize(devicegraph, issues_list); end

  def issues_list(); end

  def lv_type_for(section); end

  def parse_size(section, min, max); end

  def planned_devices(drives_map); end

  def planned_for_disk(disk, drive); end

  def planned_for_lv(drive, vg, section); end

  def planned_for_md(drive); end

  def planned_for_vg(drive); end

  def proposal_settings(); end

  def read_only?(mount_point); end

  def remove_shadowed_subvols(planned_devices); end

  def subvolume_attrs_for(mount); end
  PARTITION_MIN_SIZE = ::T.let(nil, ::T.untyped)
end

class Y2Storage::Proposal::AutoinstDevicesPlanner
  extend ::Yast::Logger
end

class Y2Storage::Proposal::AutoinstDrivesMap
  def add_disks(disks, devicegraph); end

  def add_mds(mds); end

  def add_vgs(vgs); end

  def disk_names(); end

  def each(*args, &block); end

  def each_pair(*args, &block); end

  def find_disk(devicegraph, device_name); end

  def first_usable_disk(drive, devicegraph); end

  def initialize(devicegraph, partitioning, issues_list); end

  def issues_list(); end

  def partitions?(); end

  def use_snapshots?(); end
end

class Y2Storage::Proposal::AutoinstDrivesMap
  extend ::Forwardable
end

class Y2Storage::Proposal::AutoinstSize
  def initialize(value, min: T.unsafe(nil), max: T.unsafe(nil), weight: T.unsafe(nil), percentage: T.unsafe(nil)); end

  def max(); end

  def min(); end

  def percentage(); end

  def unlimited?(); end

  def value(); end

  def weight(); end
end

class Y2Storage::Proposal::AutoinstSize
end

class Y2Storage::Proposal::AutoinstSizeParser
  def initialize(proposal_settings); end

  def parse(size_spec, mount_point, min, max); end

  def proposal_settings(); end
  INTEGER_SIZE_REGEXP = ::T.let(nil, ::T.untyped)
  INTEGER_SIZE_REGEXP_WITH_UNIT = ::T.let(nil, ::T.untyped)
end

class Y2Storage::Proposal::AutoinstSizeParser
end

class Y2Storage::Proposal::AutoinstSpaceMaker
  include ::Yast::Logger
  def adjust_reuse_values(devicegraph, planned_devices, sid_map); end

  def cleaned_devicegraph(original_devicegraph, drives_map, planned_devices); end

  def delete_by_use(devicegraph, disk, drive_spec, reused_parts); end

  def delete_linux_partitions(devicegraph, disk, reused_parts); end

  def delete_partitions(devicegraph, parts, reused_parts); end

  def delete_partitions_by_number(devicegraph, disk, partition_nrs, reused_partitions); end

  def delete_stuff(devicegraph, disk, drive_spec, reused_parts); end

  def disk_analyzer(); end

  def find_reused_partitions(devicegraph, planned_devices); end

  def initialize(disk_analyzer, issues_list=T.unsafe(nil)); end

  def issues_list(); end

  def partition_by_sid(devicegraph, sid); end

  def partitions_sid_map(devicegraph); end

  def register_invalid_use_value(drive_spec); end

  def reused_partitions_by_disk(devicegraph, planned_devices); end
end

class Y2Storage::Proposal::AutoinstSpaceMaker
  extend ::Yast::Logger
end

class Y2Storage::Proposal::Base
  include ::Yast::Logger
  def auto_settings_adjustment(); end

  def auto_settings_adjustment=(auto_settings_adjustment); end

  def calculate_proposal(*args); end

  def devices(); end

  def failed?(); end

  def initialize(devicegraph: T.unsafe(nil), disk_analyzer: T.unsafe(nil)); end

  def planned_devices(); end

  def propose(); end

  def proposed?(); end
end

class Y2Storage::Proposal::Base
  extend ::Yast::Logger
end

class Y2Storage::Proposal::CreatorResult
  def created_names(); end

  def devicegraph(); end

  def devices_map(); end

  def initialize(devicegraph, devices_map); end

  def merge(other); end

  def merge!(other); end
end

class Y2Storage::Proposal::CreatorResult
end

class Y2Storage::Proposal::DeviceShrinkage
  def diff(); end

  def planned(); end

  def planned=(_); end

  def real(); end

  def real=(_); end
end

class Y2Storage::Proposal::DeviceShrinkage
  def self.[](*_); end

  def self.members(); end
end

class Y2Storage::Proposal::DevicegraphGenerator
  include ::Yast::Logger
  def create_partitions(distribution, initial_graph); end

  def devicegraph(planned_devices, initial_graph, space_maker); end

  def initialize(settings); end

  def new_physical_volumes(old_devicegraph, new_devicegraph); end

  def provide_space(planned_partitions, devicegraph, lvm_helper, space_maker); end

  def provide_space_lvm(planned_partitions, devicegraph, lvm_helper, space_maker); end

  def provide_space_no_lvm(planned_partitions, devicegraph, lvm_helper, space_maker); end

  def refine_planned_partitions!(planned_partitions, deleted_partitions); end

  def reuse_partitions!(planned_partitions, graph); end

  def settings(); end

  def settings=(settings); end
end

class Y2Storage::Proposal::DevicegraphGenerator
  extend ::Yast::Logger
end

class Y2Storage::Proposal::DevicesPlanner
  include ::Yast::Logger
  def initialize(settings, devicegraph); end

  def planned_devices(target); end

  def settings(); end

  def settings=(settings); end
  STRATEGIES = ::T.let(nil, ::T.untyped)
end

class Y2Storage::Proposal::DevicesPlanner
  extend ::Yast::Logger
end

module Y2Storage::Proposal::DevicesPlannerStrategies
end

class Y2Storage::Proposal::DevicesPlannerStrategies::Base
  include ::Yast
  include ::Yast::Logger
  def devicegraph(); end

  def initialize(settings, devicegraph); end

  def planned_boot_devices(planned_devices); end

  def planned_devices(*args); end

  def ram_size(); end

  def remove_shadowed_subvolumes(planned_devices); end

  def reusable_swap(required_size); end

  def settings(); end

  def settings=(settings); end

  def target(); end
end

class Y2Storage::Proposal::DevicesPlannerStrategies::Base
  extend ::Yast::Logger
end

class Y2Storage::Proposal::DevicesPlannerStrategies::Legacy
  def additional_devices(); end

  def adjust_btrfs_sizes(planned_device); end

  def base_devices(); end

  def home_device(); end

  def init_btrfs_subvolumes(planned_device); end

  def planned_devices(target); end

  def root_device(); end

  def setup_btrfs(planned_vol); end

  def swap_device(); end

  def swap_lv(min_size, max_size); end

  def swap_partition(min_size, max_size); end
  MAX_SWAP_SIZE = ::T.let(nil, ::T.untyped)
  MIN_SWAP_SIZE = ::T.let(nil, ::T.untyped)
  SWAP_WEIGHT = ::T.let(nil, ::T.untyped)
end

class Y2Storage::Proposal::DevicesPlannerStrategies::Legacy
end

class Y2Storage::Proposal::DevicesPlannerStrategies::Ng
  def adjust_btrfs(planned_device, volume); end

  def adjust_btrfs_sizes(planned_device, volume); end

  def adjust_encryption(planned_device, _volume); end

  def adjust_root(planned_device, _volume); end

  def adjust_sizes(planned_device, volume); end

  def adjust_swap(planned_device, _volume); end

  def adjust_to_settings(planned_device, volume); end

  def adjust_weight(planned_device, volume); end

  def not_proposed_volumes(); end

  def planned_device(volume); end

  def planned_devices(target); end

  def value_with_fallbacks(volume, attr); end

  def volumes_with_fallback(mount_point, attr); end
end

class Y2Storage::Proposal::DevicesPlannerStrategies::Ng
end

module Y2Storage::Proposal::DevicesPlannerStrategies
  extend ::T::Sig
end

module Y2Storage::Proposal::InitialStrategies
end

class Y2Storage::Proposal::InitialStrategies::Base
  include ::Yast::Logger
  def initial_proposal(*args); end
end

class Y2Storage::Proposal::InitialStrategies::Base
  extend ::Yast::Logger
end

class Y2Storage::Proposal::InitialStrategies::Legacy
  def initial_proposal(settings: T.unsafe(nil), devicegraph: T.unsafe(nil), disk_analyzer: T.unsafe(nil)); end
end

class Y2Storage::Proposal::InitialStrategies::Legacy
end

class Y2Storage::Proposal::InitialStrategies::Ng
  def initial_proposal(settings: T.unsafe(nil), devicegraph: T.unsafe(nil), disk_analyzer: T.unsafe(nil)); end
end

class Y2Storage::Proposal::InitialStrategies::Ng
end

module Y2Storage::Proposal::InitialStrategies
  extend ::T::Sig
end

class Y2Storage::Proposal::LvmCreator
  include ::Yast::Logger
  def create_volumes(planned_vg, pv_partitions=T.unsafe(nil)); end

  def initialize(original_devicegraph); end

  def original_devicegraph(); end
end

class Y2Storage::Proposal::LvmCreator
  extend ::Yast::Logger
end

class Y2Storage::Proposal::LvmHelper
  include ::Yast::Logger
  include ::Y2Storage::SecretAttributes
  def create_volumes(original_graph, pv_partitions=T.unsafe(nil)); end

  def encrypt?(); end

  def encryption_password(); end

  def initialize(planned_lvs, settings); end

  def max_extra_space(); end

  def min_pv_size(); end

  def missing_space(); end

  def partitions_in_vg(); end

  def planned_lvs(); end

  def real_pv_size(useful_size); end

  def reusable_volume_groups(devicegraph); end

  def reused_volume_group=(vg); end

  def settings(); end

  def substract_reused_vg_size(size); end

  def useful_pv_space(size); end

  def useless_pv_space(); end

  def vg_strategy(); end

  def vg_to_reuse?(device); end

  def volume_group(); end
end

class Y2Storage::Proposal::LvmHelper
  extend ::Yast::Logger
  extend ::Y2Storage::SecretAttributes::ClassMethods
end

class Y2Storage::Proposal::MdCreator
  include ::Yast::Logger
  def create_md(planned_md, device_names); end

  def initialize(original_devicegraph); end

  def original_devicegraph(); end
end

class Y2Storage::Proposal::MdCreator
  extend ::Yast::Logger
end

class Y2Storage::Proposal::PartitionCreator
  include ::Yast::Logger
  def create_partitions(distribution); end

  def initialize(original_graph); end
end

class Y2Storage::Proposal::PartitionCreator
  extend ::Yast::Logger
end

class Y2Storage::Proposal::PartitionKiller
  include ::Yast::Logger
  def delete_by_sid(device_sid); end

  def delete_extended(partition_table); end

  def delete_lvm_partitions(partition); end

  def delete_partition(partition); end

  def devicegraph(); end

  def disks(); end

  def find_partition(sid); end

  def initialize(devicegraph, disks=T.unsafe(nil)); end

  def last_logical?(partition); end

  def lvm_vg?(partition); end

  def wipe_implicit_partition(partition); end
end

class Y2Storage::Proposal::PartitionKiller
  extend ::Yast::Logger
end

class Y2Storage::Proposal::PartitionsDistributionCalculator
  include ::Yast::Logger
  def add_unused_spaces(dist_hashes, spaces); end

  def available_space(free_spaces); end

  def best_candidate(candidates); end

  def best_distribution(partitions, spaces); end

  def candidate_disk_spaces(planned_partitions, free_spaces); end

  def distribution_hashes(disk_spaces_by_partition); end

  def distributions_from_hashes(dist_hashes); end

  def hash_product(hash); end

  def impossible?(planned_partitions, free_spaces); end

  def initialize(lvm_helper=T.unsafe(nil)); end

  def inverse_hash(hash); end

  def lvm?(); end

  def lvm_helper(); end

  def lvm_space_to_make(new_pvs); end

  def max_logical(disk, planned_partitions); end

  def resizing_size(partition, planned_partitions, free_spaces); end

  def suitable_disk_space?(space, partition); end
end

class Y2Storage::Proposal::PartitionsDistributionCalculator
  extend ::Yast::Logger
end

class Y2Storage::Proposal::PhysVolCalculator
  include ::Yast::Logger
  def add_physical_volumes(distribution); end

  def initialize(all_spaces, lvm_helper); end
  STRATEGIES = ::T.let(nil, ::T.untyped)
end

class Y2Storage::Proposal::PhysVolCalculator
  extend ::Yast::Logger
end

module Y2Storage::Proposal::PhysVolStrategies
end

class Y2Storage::Proposal::PhysVolStrategies::Base
  include ::Yast::Logger
  def add_physical_volumes(); end

  def adjust_weights(distribution); end

  def all_spaces(); end

  def estimated_available_size(space); end

  def initial_distribution(); end

  def initialize(distribution, all_spaces, lvm_helper); end

  def lvm_helper(); end

  def new_planned_partition(); end

  def new_pv_at(space); end

  def potential_lvm_size(distribution); end

  def potential_partition_size(partition, space); end

  def useful_size(space); end

  def useful_spaces(); end
end

class Y2Storage::Proposal::PhysVolStrategies::Base
  extend ::Yast::Logger
end

class Y2Storage::Proposal::PhysVolStrategies::UseAvailable
  def adjust_sizes(distribution); end

  def needed_in_single_pv(); end

  def processed_distribution(spaces); end

  def redundant?(new_list, checked); end

  def remember_combination(spaces); end

  def space_combinations(); end

  def worth_checking?(spaces); end
end

class Y2Storage::Proposal::PhysVolStrategies::UseAvailable
end

class Y2Storage::Proposal::PhysVolStrategies::UseNeeded
  def adjust_sizes(distribution, last_disk_space); end

  def processed_distribution(sorted_spaces); end

  def redundant?(new_list, checked); end

  def remember_combination(sorted_spaces, final_space); end

  def same_first_spaces?(list1, list2, n); end

  def space_combinations(); end

  def worth_checking?(spaces); end
end

class Y2Storage::Proposal::PhysVolStrategies::UseNeeded
end

module Y2Storage::Proposal::PhysVolStrategies
  extend ::T::Sig
end

class Y2Storage::Proposal::SettingsAdjustment
  include ::Yast::I18n
  include ::Yast::Logger
  def add_volume_attr(volume, attribute, value); end

  def descriptions(); end

  def empty?(); end

  def regular_vol_description(mount_point, attrs); end

  def swap_description(attrs); end

  def volume_description(mount_point, attrs); end

  def volumes(); end

  def volumes=(volumes); end
end

class Y2Storage::Proposal::SettingsAdjustment
  extend ::Yast::Logger
end

class Y2Storage::Proposal::SpaceMaker
  include ::Yast::Logger
  def candidate_disk_names(); end

  def delete_candidates!(devicegraph, type, keep=T.unsafe(nil), disk=T.unsafe(nil)); end

  def delete_disk_content(planned_partitions, disk, lvm_helper); end

  def delete_partitions!(planned_partitions, disk, type, keep); end

  def delete_unwanted_partitions(original_graph); end

  def deleted_partitions(); end

  def deletion_candidate_partitions(devicegraph, type, disk=T.unsafe(nil)); end

  def disk_analyzer(); end

  def disks_for(devicegraph, device_name=T.unsafe(nil)); end

  def dist_calculator(); end

  def filter_partitions_by_type!(partitions, type, disk); end

  def free_spaces(graph, disk=T.unsafe(nil)); end

  def initialize(disk_analyzer, settings); end

  def linux_in_disk?(disk_name); end

  def linux_part_names(disk=T.unsafe(nil)); end

  def new_graph(); end

  def original_graph(); end

  def partitions_by_disk(part_names); end

  def planned_partitions_by_disk(planned_partitions); end

  def provide_space(original_graph, planned_partitions, lvm_helper); end

  def remove_content(disk, lvm_helper); end

  def remove_linux_disks!(parts_by_disk); end

  def resize_and_delete!(planned_partitions, keep, lvm_helper, disk: T.unsafe(nil)); end

  def resize_windows!(planned_partitions, disk, force: T.unsafe(nil)); end

  def resizing_size(partition, planned_partitions, disk); end

  def settings(); end

  def settings=(settings); end

  def shrink_partition(partition, shrink_size); end

  def sorted_resizables(partitions); end

  def success?(planned_partitions); end

  def windows_part_names(disk=T.unsafe(nil)); end
end

class Y2Storage::Proposal::SpaceMaker
  extend ::Yast::Logger
end

module Y2Storage::Proposal
  extend ::T::Sig
end

class Y2Storage::ProposalSettings
  include ::Y2Storage::SecretAttributes
  include ::Y2Storage::PartitioningFeatures
  def btrfs_default_subvolume(); end

  def btrfs_default_subvolume=(btrfs_default_subvolume); end

  def btrfs_increase_percentage(); end

  def btrfs_increase_percentage=(btrfs_increase_percentage); end

  def candidate_devices(); end

  def candidate_devices=(candidate_devices); end

  def delete_forbidden(type); end

  def delete_forbidden?(type); end

  def delete_forced(type); end

  def delete_forced?(type); end

  def encryption_password(); end

  def encryption_password=(value); end

  def enlarge_swap_for_suspend(); end

  def enlarge_swap_for_suspend=(enlarge_swap_for_suspend); end

  def for_current_product(); end

  def format(); end

  def home_filesystem_type(); end

  def home_filesystem_type=(home_filesystem_type); end

  def home_max_size(); end

  def home_max_size=(home_max_size); end

  def home_min_size(); end

  def home_min_size=(home_min_size); end

  def legacy_btrfs_default_subvolume(); end

  def linux_delete_mode(); end

  def linux_delete_mode=(mode); end

  def lvm(); end

  def lvm=(lvm); end

  def lvm_vg_size(); end

  def lvm_vg_size=(lvm_vg_size); end

  def lvm_vg_strategy(); end

  def lvm_vg_strategy=(strategy); end

  def min_size_to_use_separate_home(); end

  def min_size_to_use_separate_home=(min_size_to_use_separate_home); end

  def ng_format?(); end

  def other_delete_mode(); end

  def other_delete_mode=(mode); end

  def resize_windows(); end

  def resize_windows=(resize_windows); end

  def root_base_size(); end

  def root_base_size=(root_base_size); end

  def root_device(); end

  def root_device=(root_device); end

  def root_filesystem_type(); end

  def root_filesystem_type=(root_filesystem_type); end

  def root_max_size(); end

  def root_max_size=(root_max_size); end

  def root_space_percent(); end

  def root_space_percent=(root_space_percent); end

  def snapshots_active?(); end

  def subvolumes(); end

  def subvolumes=(subvolumes); end

  def use_encryption(); end

  def use_lvm(); end

  def use_lvm=(use_lvm); end

  def use_separate_home(); end

  def use_separate_home=(use_separate_home); end

  def use_snapshots(); end

  def use_snapshots=(use_snapshots); end

  def volumes(); end

  def volumes=(volumes); end

  def windows_delete_mode(); end

  def windows_delete_mode=(mode); end
  LEGACY_FORMAT = ::T.let(nil, ::T.untyped)
  NG_FORMAT = ::T.let(nil, ::T.untyped)
end

class Y2Storage::ProposalSettings
  extend ::Y2Storage::SecretAttributes::ClassMethods
  def self.new_for_current_product(); end
end

module Y2Storage::Refinements
end

module Y2Storage::Refinements::SizeCasts
  ADDED_METHODS = ::T.let(nil, ::T.untyped)
  REFINED_CLASSES = ::T.let(nil, ::T.untyped)
end

module Y2Storage::Refinements::SizeCasts
  extend ::T::Sig
end

module Y2Storage::Refinements
  extend ::T::Sig
end

class Y2Storage::Region
  include ::Y2Storage::StorageClassWrapper
  def !=(*args); end

  def <(*args); end

  def ==(*args); end

  def >(*args); end

  def adjust_length(*args); end

  def adjust_start(*args); end

  def block_size(*args); end

  def block_size=(*args); end

  def cover?(sector); end

  def empty?(*args); end

  def end(*args); end

  def end_aligned?(grain); end

  def end_overhead(grain); end

  def inside?(*args); end

  def length(*args); end

  def length=(*args); end

  def show_range(); end

  def size(); end

  def start(*args); end

  def start=(*args); end

  def start_aligned?(grain); end
end

class Y2Storage::Region
  extend ::Y2Storage::StorageClassWrapper::ClassMethods
  def self.create(start, length, block_size); end
end

class Y2Storage::ResizeInfo
  include ::Y2Storage::StorageClassWrapper
  include ::Yast::I18n
  def bitmask(blocker_reason); end

  def libstorage_resize_blockers(); end

  def max_size(*args); end

  def min_size(*args); end

  def reason?(blocker_reason); end

  def reason_bits(*args); end

  def reason_text(blocker_reason); end

  def reason_texts(); end

  def reasons(); end

  def resize_ok?(*args); end
  REASON_TEXTS = ::T.let(nil, ::T.untyped)
end

class Y2Storage::ResizeInfo
  extend ::Y2Storage::StorageClassWrapper::ClassMethods
  extend ::Yast::I18n
end

module Y2Storage::SecretAttributes
end

class Y2Storage::SecretAttributes::Attribute
  def initialize(value); end

  def value(); end
end

class Y2Storage::SecretAttributes::Attribute
end

module Y2Storage::SecretAttributes::ClassMethods
  def secret_attr(name); end
end

module Y2Storage::SecretAttributes::ClassMethods
  extend ::T::Sig
end

module Y2Storage::SecretAttributes
  extend ::T::Sig
  def self.included(base); end
end

class Y2Storage::SetupChecker
  def boot_warnings(); end

  def devicegraph(); end

  def errors(); end

  def initialize(devicegraph); end

  def product_warnings(); end

  def valid?(); end

  def warnings(); end
end

class Y2Storage::SetupChecker
end

class Y2Storage::SetupError
  include ::Yast::I18n
  def initialize(message: T.unsafe(nil), missing_volume: T.unsafe(nil)); end

  def message(); end

  def missing_volume(); end
end

class Y2Storage::SetupError
end

class Y2Storage::SimpleEtcCrypttabEntry
  include ::Y2Storage::StorageClassWrapper
  def crypt_options(*args); end

  def device(*args); end

  def find_device(devicegraph); end

  def name(*args); end

  def password(*args); end
end

class Y2Storage::SimpleEtcCrypttabEntry
  extend ::Y2Storage::StorageClassWrapper::ClassMethods
end

class Y2Storage::SimpleEtcFstabEntry
  include ::Y2Storage::StorageClassWrapper
  def device(devicegraph); end

  def filesystem(devicegraph); end

  def fs_freq(*args); end

  def fs_passno(*args); end

  def fs_type(*args); end

  def fstab_device(*args); end

  def mount_options(*args); end

  def mount_point(*args); end

  def subvolume?(); end
end

class Y2Storage::SimpleEtcFstabEntry
  extend ::Y2Storage::StorageClassWrapper::ClassMethods
end

class Y2Storage::SpaceInfo
  include ::Y2Storage::StorageClassWrapper
  def free(); end

  def size(*args); end

  def used(*args); end
end

class Y2Storage::SpaceInfo
  extend ::Y2Storage::StorageClassWrapper::ClassMethods
end

module Y2Storage::StorageClassWrapper
  def initialize(object); end

  def to_storage_value(); end
end

module Y2Storage::StorageClassWrapper::ClassMethods
  def downcasted_new(object); end

  def storage_class(); end

  def storage_class_forward(method, to: T.unsafe(nil), as: T.unsafe(nil), check_with: T.unsafe(nil), raise_errors: T.unsafe(nil)); end

  def storage_class_name(); end

  def storage_class_underscored_name(); end

  def storage_forward(method, to: T.unsafe(nil), as: T.unsafe(nil), check_with: T.unsafe(nil), raise_errors: T.unsafe(nil)); end

  def wrap_class(storage_class, downcast_to: T.unsafe(nil)); end
end

module Y2Storage::StorageClassWrapper::ClassMethods
  extend ::T::Sig
end

module Y2Storage::StorageClassWrapper
  extend ::T::Sig
  def self.class_for(class_name); end

  def self.forward(storage_object, method, modifiers, *args); end

  def self.included(base); end

  def self.pass_check?(storage_object, check_method=T.unsafe(nil)); end

  def self.underscore(camel_case_name); end
end

module Y2Storage::StorageEnumWrapper
  def ==(other); end

  def ===(other); end

  def eql?(other); end

  def initialize(value); end

  def inspect(); end

  def is?(*names); end

  def to_i(); end

  def to_s(); end

  def to_storage_value(); end

  def to_sym(); end
end

module Y2Storage::StorageEnumWrapper::ClassMethods
  def all(); end

  def find(name_or_value); end

  def storage_enum(); end

  def value_to_sym(value); end

  def wrap_enum(storage_enum); end
end

module Y2Storage::StorageEnumWrapper::ClassMethods
  extend ::T::Sig
end

module Y2Storage::StorageEnumWrapper
  extend ::T::Sig
  def self.included(base); end
end

class Y2Storage::StorageEnv
  include ::Singleton
  include ::Yast::Logger
  def forced_bios_raid?(); end

  def forced_multipath?(); end
end

class Y2Storage::StorageEnv
  extend ::Singleton::SingletonClassMethods
  extend ::Yast::Logger
  def self.instance(); end
end

class Y2Storage::StorageManager
  include ::Yast::Logger
  def activate(callbacks=T.unsafe(nil)); end

  def arch(*args, &block); end

  def commit(force_rw: T.unsafe(nil)); end

  def committed?(); end

  def deactivate(); end

  def default_mount_by(); end

  def default_mount_by=(mount_by); end

  def devices_for_installation?(); end

  def environment(*args, &block); end

  def increase_staging_revision(); end

  def initialize(storage_environment); end

  def mode(); end

  def prepend_rootprefix(*args, &block); end

  def probe(probe_callbacks: T.unsafe(nil), sanitize_callbacks: T.unsafe(nil)); end

  def probe_from_xml(xml_file); end

  def probe_from_yaml(yaml_file=T.unsafe(nil)); end

  def probed(); end

  def probed?(); end

  def probed_disk_analyzer(); end

  def proposal(); end

  def proposal=(proposal); end

  def raw_probed(); end

  def rootprefix(*args, &block); end

  def rootprefix=(*args, &block); end

  def staging(); end

  def staging=(devicegraph); end

  def staging_changed?(); end

  def staging_revision(); end

  def storage(); end

  def update_sysconfig(); end
end

class Y2Storage::StorageManager::StorageLogger
  def write(level, component, filename, line, function, content); end
end

class Y2Storage::StorageManager::StorageLogger
end

class Y2Storage::StorageManager
  extend ::Yast::Logger
  extend ::Forwardable
  def self.create_instance(environment=T.unsafe(nil), callbacks=T.unsafe(nil)); end

  def self.create_test_instance(); end

  def self.instance(mode: T.unsafe(nil), callbacks: T.unsafe(nil)); end

  def self.setup(mode: T.unsafe(nil), callbacks: T.unsafe(nil)); end
end

class Y2Storage::SubvolSpecification
  include ::Yast::Logger
  def arch_specific?(); end

  def archs(); end

  def archs=(archs); end

  def copy_on_write(); end

  def copy_on_write=(copy_on_write); end

  def create_btrfs_subvolume(filesystem); end

  def current_arch?(); end

  def initialize(path, copy_on_write: T.unsafe(nil), archs: T.unsafe(nil)); end

  def matches_arch?(target_arch=T.unsafe(nil), &block); end

  def path(); end

  def path=(path); end

  def shadowed?(fs_mount_point, other_mount_points); end
  COW_SUBVOL_PATHS = ::T.let(nil, ::T.untyped)
  NO_COW_SUBVOL_PATHS = ::T.let(nil, ::T.untyped)
  SUBVOL_ARCHS = ::T.let(nil, ::T.untyped)
end

class Y2Storage::SubvolSpecification
  extend ::Yast::Logger
  def self.create_from_btrfs_subvolume(subvolume); end

  def self.create_from_xml(xml); end

  def self.fallback_list(); end

  def self.for_current_arch(specs); end

  def self.from_control_file(); end

  def self.list_from_control_xml(subvolumes_xml); end
end

class Y2Storage::SysconfigStorage
  include ::Singleton
  include ::Yast
  include ::Yast::Logger
  def default_mount_by(); end

  def default_mount_by=(mount_by); end

  def device_names(); end

  def device_names=(value); end
  DEVICE_NAMES = ::T.let(nil, ::T.untyped)
  MOUNT_BY_FALLBACK = ::T.let(nil, ::T.untyped)
  SYSCONFIG_PATH = ::T.let(nil, ::T.untyped)
end

class Y2Storage::SysconfigStorage
  extend ::Singleton::SingletonClassMethods
  extend ::Yast::Logger
  def self.instance(); end
end

class Y2Storage::UnexpectedCallError
end

class Y2Storage::UnexpectedCallError
end

class Y2Storage::UsedStorageFeatures
  include ::Yast::Logger
  def bitmask(feature); end

  def collect_features(); end

  def feature_packages(); end

  def initialize(devicegraph); end

  def libstorage_features(); end
  FEATURE_PACKAGES = ::T.let(nil, ::T.untyped)
  OPTIONAL_PACKAGES = ::T.let(nil, ::T.untyped)
end

class Y2Storage::UsedStorageFeatures
  extend ::Yast::Logger
  def self.optional_package?(package); end

  def self.packages_for(features); end
end

class Y2Storage::VolumeSpecification
  include ::Y2Storage::PartitioningFeatures
  def adjust_by_ram(); end

  def adjust_by_ram=(adjust_by_ram); end

  def adjust_by_ram?(); end

  def adjust_by_ram_configurable(); end

  def adjust_by_ram_configurable=(adjust_by_ram_configurable); end

  def adjust_by_ram_configurable?(); end

  def btrfs_default_subvolume(); end

  def btrfs_default_subvolume=(btrfs_default_subvolume); end

  def btrfs_read_only(); end

  def btrfs_read_only=(btrfs_read_only); end

  def btrfs_read_only?(); end

  def configurable?(); end

  def desired_size(); end

  def desired_size=(desired_size); end

  def disable_order(); end

  def disable_order=(disable_order); end

  def fallback_for_desired_size(); end

  def fallback_for_desired_size=(fallback_for_desired_size); end

  def fallback_for_max_size(); end

  def fallback_for_max_size=(fallback_for_max_size); end

  def fallback_for_max_size_lvm(); end

  def fallback_for_max_size_lvm=(fallback_for_max_size_lvm); end

  def fallback_for_min_size(); end

  def fallback_for_min_size=(fallback_for_min_size); end

  def fallback_for_weight(); end

  def fallback_for_weight=(fallback_for_weight); end

  def fs_type(); end

  def fs_type=(type); end

  def fs_type_configurable?(); end

  def fs_types(); end

  def fs_types=(types); end

  def initialize(volume_features); end

  def max_size(); end

  def max_size=(max_size); end

  def max_size_limit(); end

  def max_size_limit=(max_size_limit); end

  def max_size_lvm(); end

  def max_size_lvm=(max_size_lvm); end

  def min_size(); end

  def min_size=(min_size); end

  def min_size_with_snapshots(); end

  def mount_point(); end

  def mount_point=(mount_point); end

  def partition_id(); end

  def partition_id=(partition_id); end

  def proposed(); end

  def proposed=(proposed); end

  def proposed?(); end

  def proposed_configurable(); end

  def proposed_configurable=(proposed_configurable); end

  def proposed_configurable?(); end

  def root?(); end

  def snapper_for_device?(device); end

  def snapshots(); end

  def snapshots=(snapshots); end

  def snapshots?(); end

  def snapshots_configurable(); end

  def snapshots_configurable=(snapshots_configurable); end

  def snapshots_configurable?(); end

  def snapshots_percentage(); end

  def snapshots_percentage=(snapshots_percentage); end

  def snapshots_size(); end

  def snapshots_size=(snapshots_size); end

  def subvolumes(); end

  def subvolumes=(subvolumes); end

  def swap?(); end

  def weight(); end

  def weight=(weight); end
  FEATURES = ::T.let(nil, ::T.untyped)
end

class Y2Storage::VolumeSpecification
  def self.clear_cache(); end

  def self.for(mount_point, proposal_settings: T.unsafe(nil)); end
end

class Y2Storage::VolumeSpecificationBuilder
  def for(mount_point); end

  def initialize(proposal_settings=T.unsafe(nil)); end

  def proposal_settings(); end
end

class Y2Storage::VolumeSpecificationBuilder
end

class Y2Storage::YamlWriter
  include ::Yast::Logger
  def record_passwords(); end

  def record_passwords=(record_passwords); end

  def write(devicegraph, yaml_file); end

  def yaml_device_tree(devicegraph); end
end

class Y2Storage::YamlWriter
  extend ::Yast::Logger
  def self.write(devicegraph, yaml_file, record_passwords: T.unsafe(nil)); end
end

module Y2Storage
  extend ::T::Sig
end

YAML = Psych

module Yast
  def copy_arg(object); end

  def deep_copy(object); end

  def y2_logger(*_); end
  Address = ::T.let(nil, ::T.untyped)
  AutoInstallRules = ::T.let(nil, ::T.untyped)
  AutoinstConfig = ::T.let(nil, ::T.untyped)
  AutoinstFunctions = ::T.let(nil, ::T.untyped)
  BACKTRACE_REGEXP = ::T.let(nil, ::T.untyped)
  CWMTab = ::T.let(nil, ::T.untyped)
  CommandLine = ::T.let(nil, ::T.untyped)
  DebugHooks = ::T.let(nil, ::T.untyped)
  Desktop = ::T.let(nil, ::T.untyped)
  DontShowAgain = ::T.let(nil, ::T.untyped)
  Encoding = ::T.let(nil, ::T.untyped)
  GetInstArgs = ::T.let(nil, ::T.untyped)
  Hooks = ::T.let(nil, ::T.untyped)
  Hostname = ::T.let(nil, ::T.untyped)
  IP = ::T.let(nil, ::T.untyped)
  Icon = ::T.let(nil, ::T.untyped)
  InstExtensionImage = ::T.let(nil, ::T.untyped)
  Integer = ::T.let(nil, ::T.untyped)
  Map = ::T.let(nil, ::T.untyped)
  Message = ::T.let(nil, ::T.untyped)
  Netmask = ::T.let(nil, ::T.untyped)
  OSRelease = ::T.let(nil, ::T.untyped)
  Package = ::T.let(nil, ::T.untyped)
  PackageAI = ::T.let(nil, ::T.untyped)
  PackageCallbacks = ::T.let(nil, ::T.untyped)
  PackageKit = ::T.let(nil, ::T.untyped)
  PackageLock = ::T.let(nil, ::T.untyped)
  Product = ::T.let(nil, ::T.untyped)
  ProductControl = ::T.let(nil, ::T.untyped)
  Profile = ::T.let(nil, ::T.untyped)
  RichText = ::T.let(nil, ::T.untyped)
  SLP = ::T.let(nil, ::T.untyped)
  ServicesManagerTarget = ::T.let(nil, ::T.untyped)
  SignatureCheckCallbacks = ::T.let(nil, ::T.untyped)
  SignatureCheckDialogs = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Summary = ::T.let(nil, ::T.untyped)
  SystemdTarget = ::T.let(nil, ::T.untyped)
  TFTP = ::T.let(nil, ::T.untyped)
  TypeRepository = ::T.let(nil, ::T.untyped)
  URL = ::T.let(nil, ::T.untyped)
  URLRecode = ::T.let(nil, ::T.untyped)
  XML = ::T.let(nil, ::T.untyped)
end

class Yast::AbortException
end

class Yast::AbortException
end

class Yast::AddressClass
  def Check(address); end

  def Check4(address); end

  def Check6(address); end

  def CheckMAC(address); end

  def Valid4(); end

  def ValidChars(); end

  def ValidChars4(); end

  def ValidChars4=(_); end

  def ValidChars6(); end

  def ValidChars6=(_); end

  def ValidChars=(_); end

  def ValidCharsMAC(); end

  def ValidCharsMAC=(_); end

  def ValidMAC(); end

  def main(); end
end

class Yast::AddressClass
end

class Yast::ArchClass
  def aarch64(); end

  def alpha(); end

  def arch_short(); end

  def architecture(); end

  def arm(); end

  def board_chrp(); end

  def board_compatible(); end

  def board_iseries(); end

  def board_mac(); end

  def board_mac_new(); end

  def board_mac_old(); end

  def board_pegasos(); end

  def board_powernv(); end

  def board_prep(); end

  def board_wintel(); end

  def has_pcmcia(); end

  def has_smp(); end

  def i386(); end

  def ia64(); end

  def is_kvm(); end

  def is_laptop(); end

  def is_uml(); end

  def is_xen(); end

  def is_xen0(); end

  def is_xenU(); end

  def is_zkvm(); end

  def main(); end

  def ppc(); end

  def ppc32(); end

  def ppc64(); end

  def s390(); end

  def s390_32(); end

  def s390_64(); end

  def setSMP(is_smp); end

  def sparc(); end

  def sparc32(); end

  def sparc64(); end

  def x11_setup_needed(); end

  def x86_64(); end
end

class Yast::ArchClass
end

class Yast::ArgRef
  def initialize(initial=T.unsafe(nil)); end

  def value(); end

  def value=(value); end
end

class Yast::ArgRef
end

class Yast::AutoInstallClass
  include ::Yast::Logger
  def AutoInstall(); end

  def Continue(); end

  def Finish(destdir); end

  def PXELocalBoot(); end

  def Save(); end

  def autoconf(); end

  def autoconf=(autoconf); end

  def callbackFalse_boolean_map(dummy_map); end

  def callbackFalse_boolean_map_integer(dummy_map, dummy); end

  def callbackFalse_boolean_string(dummy); end

  def callbackFalse_boolean_string_integer(dummy, dummy2); end

  def callbackFalse_boolean_string_map_integer(dummy, dummy_map, dummy_int); end

  def callbackFalse_boolean_string_string(dummy1, dummy2); end

  def callbackFalse_boolean_string_string_integer(dummy1, dummy2, dummy3); end

  def callbackFalse_boolean_string_string_string(dummy1, dummy2, dummy3); end

  def callbackTrue_boolean_map(dummy_map); end

  def callbackTrue_boolean_map_integer(dummy_map, dummy); end

  def callbackTrue_boolean_string(dummy); end

  def callbackTrue_boolean_string_integer(dummy, dummy2); end

  def callbackTrue_boolean_string_map_integer(dummy, dummy_map, dummy_int); end

  def callbackTrue_boolean_string_string(dummy1, dummy2); end

  def callbackTrue_boolean_string_string_integer(dummy1, dummy2, dummy3); end

  def callbackTrue_boolean_string_string_string(dummy1, dummy2, dummy3); end

  def callback_void_map(dummy_map); end

  def issues_list(); end

  def issues_list=(issues_list); end

  def main(); end

  def pkg_gpg_check(data); end

  def valid_imported_values(); end
end

class Yast::AutoInstallClass
  extend ::Yast::Logger
end

class Yast::AutoInstallRulesClass
  include ::Yast::AutoinstallIoInclude
  include ::Yast::Transfer::FileFromUrl
  include ::Yast::Logger
  def AutoInstallRules(); end

  def Behaviour(); end

  def Behaviour=(_); end

  def CreateDefault(); end

  def CreateFile(filename); end

  def Files(); end

  def GetRules(); end

  def LinuxPartitions(); end

  def LinuxPartitions=(_); end

  def Merge(result_profile); end

  def NonLinuxPartitions(); end

  def NonLinuxPartitions=(_); end

  def ProbeRules(); end

  def Process(result_profile); end

  def Read(); end

  def StdErrLog(stderr); end

  def SubVars(file); end

  def UserRules(); end

  def UserRules=(_); end

  def XML_cleanup(_in, out); end

  def arch(); end

  def arch=(arch); end

  def board(); end

  def board=(board); end

  def board_vendor(); end

  def board_vendor=(board_vendor); end

  def disksize(); end

  def disksize=(disksize); end

  def domain(); end

  def domain=(domain); end

  def dontmergeBackup(); end

  def dontmergeBackup=(dontmergeBackup); end

  def dontmergeIsDefault(); end

  def dontmergeIsDefault=(dontmergeIsDefault); end

  def getHostid(); end

  def getHostname(); end

  def getMAC(); end

  def getNetwork(); end

  def hostaddress(); end

  def hostid(); end

  def hostid=(hostid); end

  def hostname(); end

  def hostname=(hostname); end

  def installed_product(); end

  def installed_product=(installed_product); end

  def installed_product_version(); end

  def installed_product_version=(installed_product_version); end

  def karch(); end

  def karch=(karch); end

  def linux(); end

  def linux=(linux); end

  def mac(); end

  def mac=(mac); end

  def main(); end

  def memsize(); end

  def memsize=(memsize); end

  def network(); end

  def network=(network); end

  def others(); end

  def others=(others); end

  def product(); end

  def product=(product); end

  def product_vendor(); end

  def product_vendor=(product_vendor); end

  def reset(); end

  def shellseg(match, var, val, op, matchtype); end

  def tomerge(); end

  def tomerge=(tomerge); end

  def totaldisk(); end

  def totaldisk=(totaldisk); end

  def userrules(); end

  def userrules=(userrules); end

  def verifyrules(); end

  def xserver(); end

  def xserver=(xserver); end
  HOSTADDRESS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Yast::AutoInstallRulesClass
  extend ::Yast::Logger
end

class Yast::AutoinstConfigClass
  include ::Yast::AutoinstallXmlInclude
  include ::Yast::AutoinstallIoInclude
  include ::Yast::Transfer::FileFromUrl
  include ::Yast::Logger
  def AutoinstConfig(); end

  def Confirm(); end

  def Confirm=(_); end

  def ForceBoot(); end

  def ForceBoot=(_); end

  def Halt(); end

  def Halt=(_); end

  def MainHelp(); end

  def OriginalURI(); end

  def OriginalURI=(_); end

  def PackageRepository(); end

  def PackageRepository=(_); end

  def ParseCmdLine(profile_location); end

  def ProfileEncrypted(); end

  def ProfileEncrypted=(_); end

  def ProfileInRootPart(); end

  def ProfileInRootPart=(_); end

  def ProfilePassword(); end

  def ProfilePassword=(_); end

  def Proposals(); end

  def Proposals=(_); end

  def RebootMsg(); end

  def RebootMsg=(_); end

  def Repository(); end

  def Repository=(_); end

  def Save(); end

  def SetProtocolMessage(); end

  def ShellEscape(s); end

  def autoconf_file(); end

  def autoconf_file=(autoconf_file); end

  def cache(); end

  def cache=(cache); end

  def cio_ignore(); end

  def cio_ignore=(cio_ignore); end

  def classDir(); end

  def classDir=(classDir); end

  def currentFile(); end

  def currentFile=(currentFile); end

  def default_target(); end

  def default_target=(default_target); end

  def destdir(); end

  def destdir=(destdir); end

  def directory(); end

  def directory=(directory); end

  def dont_edit(); end

  def dontmerge(); end

  def dontmerge=(dontmerge); end

  def filepath(); end

  def filepath=(filepath); end

  def files_dir(); end

  def files_dir=(files_dir); end

  def find_slp_autoyast(); end

  def getProposalList(); end

  def host(); end

  def host=(host); end

  def initscripts_dir(); end

  def initscripts_dir=(initscripts_dir); end

  def local_rules_file(); end

  def local_rules_file=(local_rules_file); end

  def local_rules_location(); end

  def local_rules_location=(local_rules_location); end

  def logs_dir(); end

  def logs_dir=(logs_dir); end

  def main(); end

  def message(); end

  def message=(message); end

  def modified_profile(); end

  def modified_profile=(modified_profile); end

  def network_before_proposal(); end

  def network_before_proposal=(network_before_proposal); end

  def noWriteNow(); end

  def noWriteNow=(noWriteNow); end

  def parsedControlFile(); end

  def parsedControlFile=(parsedControlFile); end

  def pass(); end

  def pass=(pass); end

  def port(); end

  def port=(port); end

  def profile_backup_path(); end

  def profile_dir(); end

  def profile_dir=(profile_dir); end

  def profile_path(); end

  def remoteProfile(); end

  def remoteProfile=(remoteProfile); end

  def remote_rules_location(); end

  def remote_rules_location=(remote_rules_location); end

  def runModule(); end

  def runModule=(runModule); end

  def runtime_dir(); end

  def runtime_dir=(runtime_dir); end

  def scheme(); end

  def scheme=(scheme); end

  def scripts_dir(); end

  def scripts_dir=(scripts_dir); end

  def second_stage(); end

  def second_stage=(second_stage); end

  def setProposalList(l); end

  def tmpDir(); end

  def tmpDir=(tmpDir); end

  def update_profile_location(profile_location); end

  def urltok(); end

  def urltok=(urltok); end

  def user(); end

  def user=(user); end

  def var_dir(); end

  def var_dir=(var_dir); end

  def xml_file(); end

  def xml_file=(xml_file); end

  def xml_tmpfile(); end

  def xml_tmpfile=(xml_tmpfile); end
  DEFAULT_PROFILE_NAME = ::T.let(nil, ::T.untyped)
end

module Yast::AutoinstConfigClass::Target
  include ::Yast::ServicesManagerTargetClass::BaseTargets
end

module Yast::AutoinstConfigClass::Target
  extend ::T::Sig
end

class Yast::AutoinstConfigClass
  extend ::Yast::Logger
end

class Yast::AutoinstFunctionsClass
  include ::Yast::Logger
  def check_second_stage_environment(); end

  def main(); end

  def second_stage_required?(); end

  def selected_product(); end
end

class Yast::AutoinstFunctionsClass
  extend ::Yast::Logger
end

module Yast::AutoinstallIoInclude
  include ::Yast::Transfer::FileFromUrl
  include ::Yast
  include ::Yast::Logger
  def Get(scheme, host, urlpath, localfile); end

  def GetURL(url, target); end

  def initialize_autoinstall_io(_include_target); end
end

module Yast::AutoinstallIoInclude
  extend ::T::Sig
end

module Yast::AutoinstallXmlInclude
  def classSetup(); end

  def initialize_autoinstall_xml(include_target); end

  def profileSetup(); end
end

module Yast::AutoinstallXmlInclude
  extend ::T::Sig
end

class Yast::BootArchClass
  extend ::Yast::Logger
end

class Yast::BootStorageClass
  extend ::Yast::Logger
end

class Yast::BootSupportCheckClass
  extend ::Yast::Logger
end

class Yast::BootloaderClass
  def proposed_cfg_changed(); end

  def proposed_cfg_changed=(proposed_cfg_changed); end

  def test_abort(); end

  def test_abort=(test_abort); end
end

class Yast::BootloaderClass
  extend ::Yast::Logger
end

class Yast::Break
  def initialize(msg=T.unsafe(nil)); end
end

class Yast::Break
end

module Yast::Builtins
  DEF_LENGHT = ::T.let(nil, ::T.untyped)
end

module Yast::Builtins::Float
end

module Yast::Builtins::Float
  extend ::T::Sig
  def self.abs(value); end

  def self.ceil(value); end

  def self.floor(value); end

  def self.pow(base, power); end

  def self.tolstring(_, _1); end

  def self.trunc(value); end
end

module Yast::Builtins::List
end

module Yast::Builtins::List
  extend ::T::Sig
  def self.reduce(*params, &block); end

  def self.swap(list, offset1, offset2); end
end

module Yast::Builtins::Multiset
end

module Yast::Builtins::Multiset
  extend ::T::Sig
  def self.difference(set1, set2); end

  def self.includes(set1, set2); end

  def self.intersection(set1, set2); end

  def self.merge(set1, set2); end

  def self.symmetric_difference(set1, set2); end

  def self.union(set1, set2); end
end

module Yast::Builtins
  extend ::Yast::I18n
  extend ::T::Sig
  def self.add(object, *params); end

  def self.argsof(term); end

  def self.change(object, *params); end

  def self.contains(list, value); end

  def self.crypt(_); end

  def self.cryptblowfish(_); end

  def self.cryptmd5(_); end

  def self.cryptsha256(_); end

  def self.cryptsha512(_); end

  def self.deletechars(string, chars); end

  def self.dgettext(domain, text); end

  def self.dngettext(domain, singular, plural, num); end

  def self.dpgettext(domain, dirname, text); end

  def self.eval(object); end

  def self.filter(object, &block); end

  def self.filterchars(string, chars); end

  def self.find(object, what=T.unsafe(nil), &block); end

  def self.findfirstnotof(string, chars); end

  def self.findfirstof(string, chars); end

  def self.findlastnotof(string, chars); end

  def self.findlastof(string, chars); end

  def self.flatten(value); end

  def self.foreach(object, &block); end

  def self.getenv(value); end

  def self.haskey(map, key); end

  def self.inside_tostring(val); end

  def self.isempty(object); end

  def self.issubstring(string, substring); end

  def self.listmap(list, &block); end

  def self.lookup(map, key, default); end

  def self.lsort(list); end

  def self.lsubstring(string, offset, length=T.unsafe(nil)); end

  def self.maplist(object, &block); end

  def self.mapmap(map, &block); end

  def self.merge(a1, a2); end

  def self.mergestring(string, sep); end

  def self.prepend(list, element); end

  def self.random(max); end

  def self.regexpmatch(_, _1); end

  def self.regexppos(_, _1); end

  def self.regexpsub(_, _1, _2); end

  def self.regexptokenize(_, _1); end

  def self.remove(object, element); end

  def self.search(string, substring); end

  def self.select(object, element, default); end

  def self.setcontains(list, value); end

  def self.setenv(env, value, overwrite=T.unsafe(nil)); end

  def self.sformat(format, *args); end

  def self.shift_frame_number(args); end

  def self.size(object); end

  def self.sleep(milisecs); end

  def self.sort(array, &block); end

  def self.splitstring(string, sep); end

  def self.srandom(param=T.unsafe(nil)); end

  def self.strftime(time, format); end

  def self.strftime_wrapper(_, _1); end

  def self.sublist(list, offset, length=T.unsafe(nil)); end

  def self.substring(string, offset, length=T.unsafe(nil)); end

  def self.symbolof(term); end

  def self.time(); end

  def self.timestring(format, time, utc); end

  def self.toascii(string); end

  def self.tobyteblock(); end

  def self.tofloat(value); end

  def self.tohexstring(int, width=T.unsafe(nil)); end

  def self.tointeger(object); end

  def self.tolist(object); end

  def self.tolower(string); end

  def self.tomap(object); end

  def self.topath(object); end

  def self.toset(array); end

  def self.tostring(val, width=T.unsafe(nil)); end

  def self.tosymbol(value); end

  def self.toterm(symbol, list=T.unsafe(nil)); end

  def self.toupper(string); end

  def self.union(first, second); end

  def self.y2debug(*args); end

  def self.y2error(*args); end

  def self.y2internal(*args); end

  def self.y2milestone(*args); end

  def self.y2security(*args); end

  def self.y2useritem(*_args); end

  def self.y2usernote(*_args); end

  def self.y2warning(*args); end
end

class Yast::Byteblock
end

class Yast::Byteblock
end

class Yast::CWMClass
  def AdjustButtons(next_, back, abort, _help); end

  def CreateWidgets(names, source); end

  def DisableButtons(buttons); end

  def GetLowestTimeout(widgets); end

  def GetProcessedWidget(); end

  def InitNull(_key); end

  def MergeHelps(widgets); end

  def OkCancelBox(); end

  def PopSettings(); end

  def PrepareDialog(dialog, widgets); end

  def ProcessTerm(t, widgets); end

  def PushSettings(); end

  def ReplaceWidgetHelp(widget=T.unsafe(nil), help=T.unsafe(nil)); end

  def Run(widgets, functions, skip_store_for: T.unsafe(nil)); end

  def SetValidationFailedHandler(handler); end

  def ShowAndRun(settings); end

  def ShowAndRunOrig(widget_names, widget_descr, contents, caption, back_button, next_button, fallback); end

  def StoreNull(_key, _event); end

  def StringsOfTerm(t); end

  def ValidateBasicType(value, type); end

  def ValidateMaps(widgets); end

  def ValidateValueContents(key, value, widget); end

  def ValidateValueType(key, value, widget); end

  def cleanupWidgets(widgets); end

  def handleDebug(); end

  def handleWidgets(widgets, event_descr); end

  def initWidgets(widgets); end

  def main(); end

  def mergeFunctions(widgets, functions); end

  def prepareWidget(widget_descr); end

  def saveWidgets(widgets, event); end

  def save_current_widgets(event); end

  def show(contents, caption: T.unsafe(nil), back_button: T.unsafe(nil), next_button: T.unsafe(nil), abort_button: T.unsafe(nil), skip_store_for: T.unsafe(nil), disable_buttons: T.unsafe(nil), back_handler: T.unsafe(nil), abort_handler: T.unsafe(nil)); end

  def validateWidget(widget, event, key); end

  def validateWidgets(widgets, event); end

  def validate_current_widgets(event); end

  def widgets_contents(contents); end

  def widgets_in_contents(contents); end
end

class Yast::CWMClass
end

class Yast::CWMTabClass
  def CleanUp(_key); end

  def CreateWidget(settings); end

  def CurrentTab(); end

  def Handle(widget, _key, event); end

  def HandleWrapper(key, event); end

  def Init(widget, _key); end

  def InitNewTab(new_tab_id, widget); end

  def InitWrapper(key); end

  def LastTab(); end

  def MarkCurrentTab(); end

  def Pop(); end

  def Push(); end

  def RedrawHelp(widget, tab); end

  def RedrawTab(tab); end

  def Store(_key, event); end

  def TabCleanup(tab); end

  def TabHandle(tab, event); end

  def TabInit(tab); end

  def TabStore(tab, event); end

  def TabValidate(tab, event); end

  def Validate(_key, event); end

  def handleDebug(); end

  def main(); end
end

class Yast::CWMTabClass
end

class Yast::Client
  include ::Yast::I18n
  include ::Yast
  include ::Yast::UIShortcuts
end

class Yast::CommandLineClass
  def Abort(); end

  def Aborted(); end

  def Command(); end

  def Done(); end

  def Error(message); end

  def GetInput(prompt, type); end

  def Init(cmdlineinfo, args); end

  def Interactive(); end

  def Parse(arguments); end

  def PasswordInput(prompt); end

  def Print(s); end

  def PrintActionHelp(action); end

  def PrintGeneralHelp(); end

  def PrintHead(); end

  def PrintInternal(s, newline); end

  def PrintNoCR(s); end

  def PrintTable(header, content); end

  def PrintVerbose(s); end

  def PrintVerboseNoCR(s); end

  def ProcessSystemCommands(command); end

  def Run(commandline); end

  def Scan(); end

  def StartGUI(); end

  def UniqueOption(options, unique_options); end

  def UserInput(prompt); end

  def Verbose(); end

  def YesNo(); end

  def main(); end
end

class Yast::CommandLineClass
end

module Yast::Convert
end

module Yast::Convert
  extend ::T::Sig
  def self.allowed_type(object, to); end

  def self.convert(object, options); end

  def self.to_boolean(object); end

  def self.to_float(object); end

  def self.to_integer(object); end

  def self.to_list(object); end

  def self.to_locale(object); end

  def self.to_map(object); end

  def self.to_path(object); end

  def self.to_string(object); end

  def self.to_symbol(object); end

  def self.to_term(object); end
end

class Yast::DebugHooksClass
  def Checkpoint(filename, at_entry); end

  def ExecuteScript(script, type); end

  def Run(filename, at_entry); end

  def main(); end
end

class Yast::DebugHooksClass
end

class Yast::Debugger
end

class Yast::Debugger
  extend ::Yast::Logger
  extend ::Yast::UIShortcuts
  def self.installed?(); end

  def self.start(remote: T.unsafe(nil), port: T.unsafe(nil), start_client: T.unsafe(nil)); end

  def self.start_from_env(); end
end

class Yast::DesktopClass
  def AgentPath(); end

  def AgentPath=(_); end

  def CreateList(m); end

  def GroupList(); end

  def Groups(); end

  def Groups=(_); end

  def MakeAutostartMap(exec, args); end

  def ModuleList(group); end

  def Modules(); end

  def Modules=(_); end

  def ParseSingleDesktopFile(file); end

  def Read(values_to_parse); end

  def ReadLanguage(); end

  def ReadLocalizedKey(fname, keypath, key); end

  def RunViaDesktop(exec, args); end

  def Translate(key); end

  def main(); end
end

class Yast::DesktopClass
end

class Yast::DirectoryClass
  def Directory(); end

  def ResetTmpDir(); end

  def agentdir(); end

  def agentdir=(agentdir); end

  def bindir(); end

  def bindir=(bindir); end

  def clientdir(); end

  def clientdir=(clientdir); end

  def custom_workflow_dir(); end

  def custom_workflow_dir=(custom_workflow_dir); end

  def datadir(); end

  def datadir=(datadir); end

  def desktopdir(); end

  def desktopdir=(desktopdir); end

  def etcdir(); end

  def etcdir=(etcdir); end

  def find_data_file(relative_path); end

  def icondir(); end

  def icondir=(icondir); end

  def imagedir(); end

  def imagedir=(imagedir); end

  def includedir(); end

  def includedir=(includedir); end

  def localedir(); end

  def localedir=(localedir); end

  def logdir(); end

  def logdir=(logdir); end

  def main(); end

  def moduledir(); end

  def moduledir=(moduledir); end

  def schemadir(); end

  def schemadir=(schemadir); end

  def scrconfdir(); end

  def scrconfdir=(scrconfdir); end

  def themedir(); end

  def themedir=(themedir); end

  def tmpdir(); end

  def tmpdir=(tmpdir); end

  def vardir(); end

  def vardir=(vardir); end

  def ybindir(); end

  def ybindir=(ybindir); end

  def ydatadir(); end

  def ydatadir=(ydatadir); end

  def yncludedir(); end

  def yncludedir=(yncludedir); end
end

class Yast::DirectoryClass
end

class Yast::DontShowAgainClass
  def GetCurrentConfigurationMap(); end

  def GetDefaultReturn(params); end

  def GetShowQuestionAgain(params); end

  def LazyLoadCurrentConf(); end

  def RemoveShowQuestionAgain(params); end

  def SaveCurrentConfiguration(); end

  def SetDefaultReturn(params, default_return); end

  def SetShowQuestionAgain(params, new_value); end

  def already_read(); end

  def already_read=(already_read); end

  def main(); end
end

class Yast::DontShowAgainClass
end

class Yast::EncodingClass
  def Encoding(); end

  def GetCodePage(enc); end

  def GetEncLang(); end

  def GetUtf8Lang(); end

  def Restore(); end

  def SetEncLang(new_lang); end

  def SetUtf8Lang(new_utf8); end

  def console(); end

  def console=(console); end

  def lang(); end

  def lang=(lang); end

  def main(); end

  def utf8(); end

  def utf8=(utf8); end
end

class Yast::EncodingClass
end

class Yast::Execute
  extend ::Yast::I18n
  def self.locally(*args); end

  def self.locally!(*args); end

  def self.on_target(*args); end

  def self.on_target!(*args); end
end

module Yast::Exportable
  def publish(options); end

  def published_functions(); end

  def published_variables(); end
end

module Yast::Exportable::ExceptionReporter
  def last_exception(); end
end

module Yast::Exportable::ExceptionReporter
  extend ::T::Sig
end

class Yast::Exportable::ExportData
  def private?(); end
end

class Yast::Exportable::ExportData
end

module Yast::Exportable
  extend ::T::Sig
  def self.extended(mod); end
end

class Yast::External
  def initialize(magic); end

  def magic(); end
end

class Yast::External
end

class Yast::FileUtilsClass
  def CheckAndCreatePath(pathvalue); end

  def Chmod(modes, file, recursive); end

  def Chown(usergroup, file, recursive); end

  def CleanupTemp(); end

  def Exists(target); end

  def GetFileRealType(target); end

  def GetFileType(target); end

  def GetOwnerGroupID(target); end

  def GetOwnerUserID(target); end

  def GetSize(target); end

  def IsBlock(target); end

  def IsCharacterDevice(target); end

  def IsDirectory(target); end

  def IsFifo(target); end

  def IsFile(target); end

  def IsLink(target); end

  def IsSocket(target); end

  def MD5sum(target); end

  def MkTempDirectory(template, usergroup, modes); end

  def MkTempFile(template, usergroup, modes); end

  def MkTempInternal(template, usergroup, modes, directory); end

  def main(); end
end

class Yast::FileUtilsClass
end

class Yast::FunRef
  def call(*args); end

  def initialize(met, signature); end

  def remote_method(); end

  def signature(); end
end

class Yast::FunRef
end

class Yast::GetInstArgsClass
  def Buttons(back, next_); end

  def ButtonsProposal(back, next_, proposal_name); end

  def Init(); end

  def argmap(); end

  def enable_back(); end

  def enable_next(); end

  def going_back(); end

  def main(); end

  def proposal(); end
end

class Yast::GetInstArgsClass
end

class Yast::HTMLClass
  def Bold(text); end

  def ColoredList(items, color); end

  def Colorize(text, color); end

  def Heading(text); end

  def Link(text, link_id); end

  def List(items); end

  def ListEnd(); end

  def ListItem(text); end

  def ListStart(); end

  def Newline(); end

  def Newlines(count); end

  def Para(text); end

  def main(); end
end

class Yast::HTMLClass
end

class Yast::HooksClass
  include ::Yast::Logger
  def all(); end

  def exists?(hook_name); end

  def find(hook_name); end

  def last(); end

  def run(hook_name); end

  def search_path(); end
end

class Yast::HooksClass::Hook
  include ::Yast::Logger
  def caller_path(); end

  def execute(); end

  def failed?(); end

  def files(); end

  def initialize(name, caller_path, search_path); end

  def name(); end

  def results(); end

  def search_path(); end

  def succeeded?(); end

  def used?(); end
end

class Yast::HooksClass::Hook
  extend ::Yast::Logger
end

class Yast::HooksClass::HookFile
  include ::Yast::Logger
  def content(); end

  def execute(); end

  def failed?(); end

  def initialize(path); end

  def output(); end

  def path(); end

  def result(); end

  def succeeded?(); end
end

class Yast::HooksClass::HookFile
  extend ::Yast::Logger
end

class Yast::HooksClass::SearchPath
  def children(); end

  def join!(new_path); end

  def path(); end

  def reset(); end

  def set(new_path); end

  def verify!(); end
  DEFAULT_DIR = ::T.let(nil, ::T.untyped)
end

class Yast::HooksClass::SearchPath
end

class Yast::HooksClass
  extend ::Yast::Logger
end

class Yast::HostnameClass
  def Check(host); end

  def CheckDomain(domain); end

  def CheckFQ(host); end

  def CurrentDomain(); end

  def CurrentFQ(); end

  def CurrentHostname(); end

  def DefaultDomain(); end

  def DefaultDomain=(_); end

  def MergeFQ(hostname, domain); end

  def SplitFQ(fqhostname); end

  def ValidChars(); end

  def ValidChars=(_); end

  def ValidCharsDomain(); end

  def ValidCharsDomain=(_); end

  def ValidCharsFQ(); end

  def ValidCharsFQ=(_); end

  def ValidDomain(); end

  def ValidFQ(); end

  def ValidHost(); end

  def main(); end
end

class Yast::HostnameClass
end

module Yast::I18n
  def N_(str); end

  def Nn_(*keys); end

  def _(str); end

  def n_(singular, plural, num); end

  def textdomain(domain); end
  DEFAULT_LOCALE = ::T.let(nil, ::T.untyped)
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
end

module Yast::I18n
  extend ::T::Sig
end

class Yast::IPClass
  include ::Yast::Logger
  def BitsToIPv4(bits); end

  def Check(ip); end

  def Check4(ip); end

  def Check6(ip); end

  def CheckNetwork(network); end

  def CheckNetwork4(network); end

  def CheckNetwork6(network); end

  def CheckNetworkShared(network); end

  def ComputeBroadcast(ip, mask); end

  def ComputeNetwork(ip, mask); end

  def IPv4ToBits(ipv4); end

  def ToHex(ip); end

  def ToInteger(ip); end

  def ToString(ip); end

  def UndecorateIPv6(ip); end

  def Valid4(); end

  def Valid6(); end

  def ValidChars(); end

  def ValidChars4(); end

  def ValidChars4=(_); end

  def ValidChars6(); end

  def ValidChars6=(_); end

  def ValidChars=(_); end

  def ValidNetwork(); end

  def main(); end

  def reserved4(ip); end
end

class Yast::IPClass
  extend ::Yast::Logger
end

class Yast::IconClass
  def Error(); end

  def IconPath(icon_type); end

  def Image(icon_type, options); end

  def Info(); end

  def LazyInit(); end

  def Simple(icon_type); end

  def Warning(); end

  def main(); end
end

class Yast::IconClass
end

class Yast::InitrdClass
  include ::Yast::Logger
  def AddModule(modname, modargs); end

  def AdditionalParameters(); end

  def Export(); end

  def Import(settings); end

  def ListModules(); end

  def Read(); end

  def RemoveModule(modname); end

  def Reset(); end

  def SetAdditionalParameters(params); end

  def Update(); end

  def VgaModes(); end

  def Write(); end

  def changed(); end

  def changed=(changed); end

  def errorWithLogPopup(header, log); end

  def getModulesToSkip(); end

  def main(); end

  def setSplash(vga); end
end

class Yast::InitrdClass
  extend ::Yast::Logger
end

class Yast::InstBootloaderClient
  extend ::Yast::Logger
end

class Yast::InstExtensionImageClass
  def CutLastDirOrFile(url); end

  def DesintegrateExtension(_extension); end

  def DisintegrateAllExtensions(); end

  def DownloadAndIntegrateExtension(extension); end

  def IsURLRelative(url); end

  def LazyInit(); end

  def LoadExtension(package, message); end

  def MergeURLs(url_base, url_with_modifs); end

  def MergeURLsParams(base_url, url_with_modifs); end

  def UnLoadExtension(package, message); end

  def main(); end

  def with_extension(package, &block); end
end

class Yast::InstExtensionImageClass
end

class Yast::InstallationClass
  def Initialize(); end

  def Installation(); end

  def add_on_selected(); end

  def add_on_selected=(add_on_selected); end

  def boot(); end

  def current_step(); end

  def current_step=(current_step); end

  def destdir(); end

  def destdir=(destdir); end

  def dirinstall_installing_into_dir(); end

  def dirinstall_installing_into_dir=(dirinstall_installing_into_dir); end

  def dirinstall_target(); end

  def dirinstall_target=(dirinstall_target); end

  def dirinstall_target_time(); end

  def dirinstall_target_time=(dirinstall_target_time); end

  def encoding(); end

  def encoding=(encoding); end

  def file_inst_aborted(); end

  def file_inst_aborted=(file_inst_aborted); end

  def file_inst_failed(); end

  def file_inst_failed=(file_inst_failed); end

  def file_live_install_mode(); end

  def file_live_install_mode=(file_live_install_mode); end

  def file_update_mode(); end

  def file_update_mode=(file_update_mode); end

  def finish_restarting!(); end

  def image_installation(); end

  def image_installation=(image_installation); end

  def image_only(); end

  def image_only=(image_only); end

  def installedVersion(); end

  def installedVersion=(installedVersion); end

  def license_accepted(); end

  def license_accepted=(license_accepted); end

  def main(); end

  def mountlog(); end

  def mountlog=(mountlog); end

  def no_x11(); end

  def probing_done(); end

  def probing_done=(probing_done); end

  def productsources_selected(); end

  def productsources_selected=(productsources_selected); end

  def reboot_file(); end

  def reboot_file=(reboot_file); end

  def reboot_net_settings(); end

  def reboot_net_settings=(reboot_net_settings); end

  def restart!(); end

  def restart_data_file(); end

  def restart_data_file=(restart_data_file); end

  def restart_file(); end

  def restart_file=(restart_file); end

  def restarting?(); end

  def run_update_file(); end

  def run_update_file=(run_update_file); end

  def run_yast_at_boot(); end

  def run_yast_at_boot=(run_yast_at_boot); end

  def scr_destdir(); end

  def scr_destdir=(scr_destdir); end

  def scr_handle(); end

  def scr_handle=(scr_handle); end

  def shown_text_mode_warning(); end

  def shown_text_mode_warning=(shown_text_mode_warning); end

  def sourcedir(); end

  def sourcedir=(sourcedir); end

  def text_fallback(); end

  def updateVersion(); end

  def updateVersion=(updateVersion); end

  def update_backup_modified(); end

  def update_backup_modified=(update_backup_modified); end

  def update_backup_path(); end

  def update_backup_path=(update_backup_path); end

  def update_backup_sysconfig(); end

  def update_backup_sysconfig=(update_backup_sysconfig); end

  def update_remove_old_backups(); end

  def update_remove_old_backups=(update_remove_old_backups); end

  def x11_setup_needed(); end

  def yast2dir(); end

  def yast2dir=(yast2dir); end
end

class Yast::InstallationClass
end

class Yast::IntegerClass
  def Clamp(i, min, max); end

  def IsPowerOfTwo(i); end

  def Max(values); end

  def Min(values); end

  def Range(stop); end

  def RangeFrom(start, stop); end

  def Sum(values); end

  def main(); end
end

class Yast::IntegerClass
end

class Yast::KernelClass
  include ::Yast::Logger
  def AddCmdLine(name, arg); end

  def AddModuleToLoad(name); end

  def ComputePackage(); end

  def ComputePackages(); end

  def ComputePackagesForBase(base, _check_avail); end

  def GetBinary(); end

  def GetCmdLine(); end

  def GetFinalKernel(); end

  def GetInformAboutKernelChange(); end

  def GetPackages(); end

  def GetVgaType(); end

  def HidePasswords(in_); end

  def InformAboutKernelChange(); end

  def IsGraphicalDesktop(); end

  def ParseInstallationKernelCmdline(); end

  def ProbeKernel(); end

  def RemoveModuleToLoad(name); end

  def SaveModulesToLoad(); end

  def SetInformAboutKernelChange(b); end

  def SetPackages(custom_kernels); end

  def main(); end

  def module_to_be_loaded?(kernel_module); end

  def modules_to_load(); end

  def reset_modules_to_load(); end
  MODULES_CONF_FILE = ::T.let(nil, ::T.untyped)
  MODULES_DIR = ::T.let(nil, ::T.untyped)
  MODULES_SCR = ::T.let(nil, ::T.untyped)
  PAE_LIMIT = ::T.let(nil, ::T.untyped)
  S390_ZIPL_ARGS = ::T.let(nil, ::T.untyped)
end

class Yast::KernelClass
  extend ::Yast::Logger
end

class Yast::LabelClass
  def AbortButton(); end

  def AbortInstallationButton(); end

  def AcceptButton(); end

  def AddButton(); end

  def BackButton(); end

  def BrowseButton(); end

  def CancelButton(); end

  def CloseButton(); end

  def ConfirmPassword(); end

  def ContinueButton(); end

  def CreateButton(); end

  def DefaultFunctionKeyMap(); end

  def DeleteButton(); end

  def DoNotAcceptButton(); end

  def DontInstallButton(); end

  def DownButton(); end

  def DownloadButton(); end

  def EditButton(); end

  def ErrorMsg(); end

  def FileName(); end

  def FinishButton(); end

  def HelpButton(); end

  def HostName(); end

  def IgnoreButton(); end

  def InstallButton(); end

  def NewButton(); end

  def NextButton(); end

  def NoButton(); end

  def OKButton(); end

  def Options(); end

  def Password(); end

  def PleaseWaitMsg(); end

  def Port(); end

  def QuitButton(); end

  def RefreshButton(); end

  def RemoveButton(); end

  def ReplaceButton(); end

  def RetryButton(); end

  def SaveButton(); end

  def SelectButton(); end

  def SkipButton(); end

  def StopButton(); end

  def UpButton(); end

  def WarningMsg(); end

  def YesButton(); end

  def main(); end
end

class Yast::LabelClass
end

class Yast::LinuxrcClass
  include ::Yast::Logger
  def InstallInf(key); end

  def ReadInstallInf(); end

  def ResetInstallInf(); end

  def SaveInstallInf(root); end

  def WriteYaSTInf(linuxrc); end

  def braille(); end

  def disable_remote(services); end

  def display_ip(); end

  def keys(); end

  def main(); end

  def manual(); end

  def serial_console(); end

  def text(); end

  def useiscsi(); end

  def usessh(); end

  def value_for(feature_key); end

  def vnc(); end
  DISABLE_SNAPSHOTS = ::T.let(nil, ::T.untyped)
end

class Yast::LinuxrcClass
  extend ::Yast::Logger
end

module Yast::Logger
  def log(); end
end

module Yast::Logger
  extend ::T::Sig
  def self.included(base); end
end

class Yast::MapClass
  def CheckKeys(m, keys); end

  def FromString(s); end

  def Keys(m); end

  def KeysToLower(m); end

  def KeysToUpper(m); end

  def ToString(m); end

  def Values(m); end

  def main(); end
end

class Yast::MapClass
end

class Yast::MessageClass
  def CannotAdjustService(service_name); end

  def CannotContinueWithoutPackagesInstalled(); end

  def CannotOpenFile(file); end

  def CannotOpenFileBecause(file, reason); end

  def CannotReadCurrentSettings(); end

  def CannotRestartService(service_name); end

  def CannotStartService(service_name); end

  def CannotStopService(service_name); end

  def CannotWriteSettingsTo(destination); end

  def CannotWriteSettingsToBecause(destination, reason); end

  def CheckEnvironment(); end

  def DirectoryDoesNotExistCreate(directory); end

  def DoNotShowMessageAgain(); end

  def DomainHasChangedMustReboot(); end

  def ErrorWritingFile(file); end

  def ErrorWritingFileBecause(file, reason); end

  def FailedToInstallPackages(); end

  def Finished(); end

  def MissingParameter(parameter); end

  def RequiredItem(); end

  def SuSEConfigFailed(); end

  def UnableToCreateDirectory(directory); end

  def UnknownError(reason); end

  def main(); end

  def takes_a_while(); end

  def updating_configuration(); end
end

class Yast::MessageClass
end

class Yast::MiscClass
  def CustomSysconfigRead(key, defval, location); end

  def ReadAlternateFile(first, second); end

  def RunCommandWithTimeout(run_command, log_command, script_time_out); end

  def RunDumbTimeout(command, log_command, seconds); end

  def SplitOptions(options, optmap); end

  def SysconfigRead(sysconfig_path, defaultv); end

  def SysconfigWrite(level, values); end

  def boot_msg(); end

  def boot_msg=(boot_msg); end

  def hardware_name(hardware_entry); end

  def main(); end

  def translate(lmap, lang); end
end

class Yast::MiscClass
end

class Yast::ModeClass
  def Depeche(); end

  def Initialize(); end

  def SetMode(new_mode); end

  def SetTest(new_test_mode); end

  def SetUI(new_ui); end

  def auto(); end

  def autoinst(); end

  def autoupgrade(); end

  def commandline(); end

  def config(); end

  def installation(); end

  def live_installation(); end

  def main(); end

  def mode(); end

  def normal(); end

  def repair(); end

  def screen_shot(); end

  def test(); end

  def testMode(); end

  def testsuite(); end

  def ui(); end

  def update(); end
end

class Yast::ModeClass
end

class Yast::Module
  include ::Yast::I18n
  include ::Yast::Exportable::ExceptionReporter
  include ::Yast
  include ::Yast::UIShortcuts
end

class Yast::Module
  extend ::Yast::Exportable
end

class Yast::NetmaskClass
  def Check(netmask); end

  def Check4(netmask); end

  def Check6(netmask); end

  def CheckPrefix4(prefix); end

  def FromBits(bits); end

  def ToBits(netmask); end

  def ValidChars(); end

  def ValidChars4(); end

  def ValidChars4=(_); end

  def ValidChars6(); end

  def ValidChars6=(_); end

  def ValidChars=(_); end

  def main(); end
end

class Yast::NetmaskClass
end

class Yast::OSReleaseClass
  include ::Yast::Logger
  def ReleaseInformation(directory=T.unsafe(nil)); end

  def ReleaseName(directory=T.unsafe(nil)); end

  def ReleaseVersion(directory=T.unsafe(nil)); end

  def id(directory=T.unsafe(nil)); end

  def os_release_exists?(directory=T.unsafe(nil)); end
  OS_RELEASE_PATH = ::T.let(nil, ::T.untyped)
end

class Yast::OSReleaseClass
  extend ::Yast::Logger
end

class Yast::OSReleaseFileMissingError
  def initialize(message); end
end

class Yast::OSReleaseFileMissingError
end

module Yast::Ops
  OUTER_LOOP_FRAME = ::T.let(nil, ::T.untyped)
  SHORTCUT_TYPES = ::T.let(nil, ::T.untyped)
  TYPES_MAP = ::T.let(nil, ::T.untyped)
end

class Yast::Ops::GenericComparable
  include ::Comparable
  def initialize(value, localized=T.unsafe(nil)); end
  CLASS_ORDER = ::T.let(nil, ::T.untyped)
end

class Yast::Ops::GenericComparable
end

class Yast::Ops::HashComparator
  include ::Comparable
  def initialize(value, localized=T.unsafe(nil)); end
end

class Yast::Ops::HashComparator
end

class Yast::Ops::ListComparator
  include ::Comparable
  def initialize(value, localized=T.unsafe(nil)); end
end

class Yast::Ops::ListComparator
end

module Yast::Ops
  extend ::T::Sig
  def self.add(first, second); end

  def self.bitwise_and(first, second); end

  def self.bitwise_not(value); end

  def self.bitwise_or(first, second); end

  def self.bitwise_xor(first, second); end

  def self.comparable_object(object, localized=T.unsafe(nil)); end

  def self.divide(first, second); end

  def self.equal(first, second); end

  def self.get(object, indexes, default=T.unsafe(nil), skip_frames=T.unsafe(nil)); end

  def self.get_boolean(object, indexes, default=T.unsafe(nil), &block); end

  def self.get_float(object, indexes, default=T.unsafe(nil), &block); end

  def self.get_integer(object, indexes, default=T.unsafe(nil), &block); end

  def self.get_list(object, indexes, default=T.unsafe(nil), &block); end

  def self.get_locale(object, indexes, default=T.unsafe(nil), &block); end

  def self.get_map(object, indexes, default=T.unsafe(nil), &block); end

  def self.get_path(object, indexes, default=T.unsafe(nil), &block); end

  def self.get_string(object, indexes, default=T.unsafe(nil), &block); end

  def self.get_symbol(object, indexes, default=T.unsafe(nil), &block); end

  def self.get_term(object, indexes, default=T.unsafe(nil), &block); end

  def self.greater_or_equal(first, second); end

  def self.greater_than(first, second); end

  def self.is(object, type); end

  def self.is_any?(object); end

  def self.is_boolean?(object); end

  def self.is_byteblock?(object); end

  def self.is_float?(object); end

  def self.is_function?(object); end

  def self.is_integer?(object); end

  def self.is_list?(object); end

  def self.is_locale?(object); end

  def self.is_map?(object); end

  def self.is_nil?(object); end

  def self.is_path?(object); end

  def self.is_string?(object); end

  def self.is_symbol?(object); end

  def self.is_term?(object); end

  def self.is_void?(object); end

  def self.less_or_equal(first, second); end

  def self.less_than(first, second); end

  def self.logical_and(first, second); end

  def self.logical_not(value); end

  def self.logical_or(first, second); end

  def self.modulo(first, second); end

  def self.multiply(first, second); end

  def self.not_equal(first, second); end

  def self.set(object, indexes, value); end

  def self.shift_left(first, second); end

  def self.shift_right(first, second); end

  def self.subtract(first, second); end

  def self.unary_minus(value); end
end

class Yast::PackageAIClass
  include ::Yast::PackagesCommonInclude
  def Available(_package); end

  def DoInstall(packages); end

  def DoInstallAndRemove(toinst, torem); end

  def DoRemove(packages); end

  def GetModified(); end

  def InstallKernel(_kernel_modules); end

  def Installed(package); end

  def PackageAvailable(package); end

  def PackageInstalled(package); end

  def SetModified(); end

  def main(); end

  def modified(); end

  def modified=(modified); end

  def toinstall(); end

  def toinstall=(toinstall); end

  def toremove(); end

  def toremove=(toremove); end
end

class Yast::PackageAIClass
end

class Yast::PackageCallbacksClass
  include ::Yast::Logger
  def AskAbortRefresh(); end

  def Authentication(url, msg, username, password); end

  def ClearDownloadCallbacks(); end

  def ClearScriptCallbacks(); end

  def CloseDownloadProgressPopup(); end

  def CloseSourcePopup(); end

  def DestDownload(); end

  def DoneDownload(error_value, error_text); end

  def DonePackage(error, reason); end

  def DoneProvide(error, reason, name); end

  def DoneScanDb(error, description); end

  def EnableAsterixPackage(f); end

  def ErrorScanDb(error, description); end

  def FinishDeltaProvide(); end

  def FormatPatchName(patch_name, patch_version, patch_arch); end

  def InitDownload(task); end

  def InitPackageCallbacks(); end

  def IsDownloadProgressPopup(); end

  def IsProgressPopup(); end

  def IsSourcePopup(); end

  def MediaChange(error_code, error, url, product, current, current_label, wanted, wanted_label, double_sided, devices, current_device); end

  def Message(patch_name, patch_version, patch_arch, message); end

  def NextTick(); end

  def NotifyConvertDB(); end

  def NotifyRebuildDB(); end

  def OpenSourcePopup(); end

  def ProblemDeltaApply(descr); end

  def ProblemDeltaDownload(descr); end

  def ProcessDone(); end

  def ProcessNextStage(); end

  def ProcessProgress(percent); end

  def ProcessStart(task, stages, help); end

  def ProgressConvertDB(percent, _file); end

  def ProgressDeltaApply(percent); end

  def ProgressDownload(percent, bps_avg, bps_current); end

  def ProgressEnd(id); end

  def ProgressPackage(percent); end

  def ProgressProgress(id, val_raw, val_percent); end

  def ProgressProvide(percent); end

  def ProgressRebuildDB(percent); end

  def ProgressScanDb(value); end

  def ProgressStart(id, task, in_percent, is_alive, _min, _max, _val_raw, val_percent); end

  def RefreshDone(); end

  def RefreshStarted(); end

  def RegisterEmptyProgressCallbacks(); end

  def ResetDownloadCallbacks(); end

  def ResetScanDBCallbacks(); end

  def RestorePatchCallbacks(); end

  def RestorePreviousProgressCallbacks(); end

  def RestoreProcessCallbacks(); end

  def RestoreProgressReportCallbacks(); end

  def RestoreProvideCallbacks(); end

  def RestoreSourceCreateCallbacks(); end

  def RestoreSourceReportCallbacks(); end

  def ScriptFinish(); end

  def ScriptProblem(description); end

  def ScriptProgress(ping, output); end

  def ScriptStart(patch_name, patch_version, patch_arch, script_path); end

  def SetConvertDBCallbacks(); end

  def SetDownloadCallbacks(); end

  def SetFileConflictCallbacks(); end

  def SetHeaderSourcePopup(text); end

  def SetLabelSourcePopup(text); end

  def SetMediaCallbacks(); end

  def SetPatchCallbacks(); end

  def SetProcessCallbacks(); end

  def SetProgressReportCallbacks(); end

  def SetProvideCallbacks(); end

  def SetRebuildDBCallbacks(); end

  def SetScanDBCallbacks(); end

  def SetScriptCallbacks(); end

  def SetSourceCreateCallbacks(); end

  def SetSourceProbeCallbacks(); end

  def SetSourceReportCallbacks(); end

  def SourceChange(source, medianr); end

  def SourceCreateDestroy(); end

  def SourceCreateEnd(url, error, description); end

  def SourceCreateError(url, error, description); end

  def SourceCreateInit(); end

  def SourceCreateProgress(percent); end

  def SourceCreateStart(url); end

  def SourcePopupSetProgress(value); end

  def SourceProbeEnd(url, error, description); end

  def SourceProbeError(url, error, description); end

  def SourceProbeFailed(url, type); end

  def SourceProbeProgress(_url, value); end

  def SourceProbeStart(url); end

  def SourceProbeSucceeded(url, type); end

  def SourceReportDestroy(); end

  def SourceReportEnd(src_id, url, task, error, description); end

  def SourceReportError(source_id, url, error, description); end

  def SourceReportInit(); end

  def SourceReportProgress(value); end

  def SourceReportStart(source_id, url, task); end

  def StartConvertDB(_unused1); end

  def StartDeltaApply(name); end

  def StartDeltaProvide(name, archivesize); end

  def StartDownload(url, localfile); end

  def StartPackage(name, _location, _summary, installsize, is_delete); end

  def StartProvide(name, archivesize, remote); end

  def StartRebuildDB(); end

  def StartScanDb(); end

  def StopConvertDB(error_value, error_text); end

  def StopRebuildDB(error_value, error_text); end

  def _current_source(); end

  def _current_source=(_current_source); end

  def _deleting_package(); end

  def _deleting_package=(_deleting_package); end

  def _package_name(); end

  def _package_name=(_package_name); end

  def _package_size(); end

  def _package_size=(_package_size); end

  def main(); end

  def pkg_gpg_check(data); end
  CLEAR_PROGRESS_TEXT = ::T.let(nil, ::T.untyped)
  MAX_POPUP_TEXT_SIZE = ::T.let(nil, ::T.untyped)
  RETRY_ATTEMPTS = ::T.let(nil, ::T.untyped)
  RETRY_MAX_TIMEOUT = ::T.let(nil, ::T.untyped)
  RETRY_TIMEOUT = ::T.let(nil, ::T.untyped)
  TICK_LABELS = ::T.let(nil, ::T.untyped)
end

class Yast::PackageCallbacksClass
  extend ::Yast::Logger
end

class Yast::PackageClass
  include ::Yast::PackagesCommonInclude
  def Available(package); end

  def DoInstall(packages); end

  def DoInstallAndRemove(toinstall, toremove); end

  def DoRemove(packages); end

  def InstallKernel(kernel_modules); end

  def Installed(package); end

  def PackageAvailable(package); end

  def PackageInstalled(package); end

  def functions(); end

  def main(); end
end

class Yast::PackageClass
end

class Yast::PackageKitClass
  def IsRunning(); end

  def SuggestQuit(); end

  def main(); end
end

class Yast::PackageKitClass
end

class Yast::PackageLockClass
  def AskPackageKit(); end

  def Check(); end

  def Connect(show_continue_button); end

  def main(); end
end

class Yast::PackageLockClass
end

class Yast::PackageSystemClass
  include ::Yast::PackagesCommonInclude
  def Available(package); end

  def CheckAndInstallPackages(packages); end

  def CheckAndInstallPackagesInteractive(packages); end

  def DoInstall(packages); end

  def DoInstallAndRemove(toinstall, toremove); end

  def DoInstallAndRemoveInt(toinstall, toremove); end

  def DoRemove(packages); end

  def EnsureSourceInit(); end

  def EnsureTargetInit(); end

  def InitRPMQueryBinary(); end

  def InstallKernel(kernel_modules); end

  def Installed(package); end

  def PackageAvailable(package); end

  def PackageInstalled(package); end

  def SelectPackages(toinstall, toremove); end

  def main(); end
end

class Yast::PackageSystemClass
end

module Yast::PackagesCommonInclude
  def AskPackages(packs, install); end

  def AvailableAll(packages); end

  def AvailableAny(packages); end

  def Install(package); end

  def InstallAll(packages); end

  def InstallAllMsg(packages, message); end

  def InstallMsg(package, message); end

  def InstalledAll(packages); end

  def InstalledAny(packages); end

  def LastOperationCanceled(); end

  def PackageDialog(packages, install, message); end

  def Remove(package); end

  def RemoveAll(packages); end

  def RemoveAllMsg(packages, message); end

  def RemoveMsg(package, message); end

  def initialize_packages_common(_include_target); end
end

module Yast::PackagesCommonInclude
  extend ::T::Sig
end

class Yast::PackagesProposalClass
  include ::Yast::Logger
  def AddResolvables(unique_ID, type, resolvables, optional: T.unsafe(nil)); end

  def CheckParams(unique_ID, type); end

  def GetAllResolvables(type, optional: T.unsafe(nil)); end

  def GetAllResolvablesForAllTypes(optional: T.unsafe(nil)); end

  def GetResolvables(unique_ID, type, optional: T.unsafe(nil)); end

  def GetSupportedResolvables(); end

  def IsSupportedResolvableType(type); end

  def IsUniqueID(unique_ID); end

  def RemoveResolvables(unique_ID, type, resolvables, optional: T.unsafe(nil)); end

  def ResetAll(); end

  def SetResolvables(unique_ID, type, resolvables, optional: T.unsafe(nil)); end

  def main(); end
end

class Yast::PackagesProposalClass
  extend ::Yast::Logger
end

class Yast::Path
  include ::Comparable
  def +(other); end

  def clone(); end

  def empty?(); end

  def initialize(value); end

  def size(); end
  COMPLEX_CHAR_REGEX = ::T.let(nil, ::T.untyped)
  SIMPLE_CHAR_REGEX = ::T.let(nil, ::T.untyped)
end

class Yast::Path
  def self.from_string(string); end
end

module Yast::Pkg
end

module Yast::Pkg
  extend ::T::Sig
  def self.AddLock(*args); end

  def self.AddUpgradeRepo(*args); end

  def self.CallbackAcceptFileWithoutChecksum(*args); end

  def self.CallbackAcceptUnknownDigest(*args); end

  def self.CallbackAcceptUnknownGpgKey(*args); end

  def self.CallbackAcceptUnsignedFile(*args); end

  def self.CallbackAcceptVerificationFailed(*args); end

  def self.CallbackAcceptWrongDigest(*args); end

  def self.CallbackAuthentication(*args); end

  def self.CallbackDestDownload(*args); end

  def self.CallbackDoneDownload(*args); end

  def self.CallbackDonePackage(*args); end

  def self.CallbackDoneProvide(*args); end

  def self.CallbackDoneRefresh(*args); end

  def self.CallbackDoneScanDb(*args); end

  def self.CallbackErrorScanDb(*args); end

  def self.CallbackFileConflictFinish(*args); end

  def self.CallbackFileConflictProgress(*args); end

  def self.CallbackFileConflictReport(*args); end

  def self.CallbackFileConflictStart(*args); end

  def self.CallbackFinishDeltaApply(*args); end

  def self.CallbackFinishDeltaDownload(*args); end

  def self.CallbackImportGpgKey(*args); end

  def self.CallbackInitDownload(*args); end

  def self.CallbackMediaChange(*args); end

  def self.CallbackMessage(*args); end

  def self.CallbackNotifyConvertDb(*args); end

  def self.CallbackNotifyRebuildDb(*args); end

  def self.CallbackPkgGpgCheck(*args); end

  def self.CallbackProblemDeltaApply(*args); end

  def self.CallbackProblemDeltaDownload(*args); end

  def self.CallbackProcessDone(*args); end

  def self.CallbackProcessNextStage(*args); end

  def self.CallbackProcessProgress(*args); end

  def self.CallbackProcessStart(*args); end

  def self.CallbackProgressConvertDb(*args); end

  def self.CallbackProgressDeltaApply(*args); end

  def self.CallbackProgressDeltaDownload(*args); end

  def self.CallbackProgressDownload(*args); end

  def self.CallbackProgressPackage(*args); end

  def self.CallbackProgressProvide(*args); end

  def self.CallbackProgressRebuildDb(*args); end

  def self.CallbackProgressReportEnd(*args); end

  def self.CallbackProgressReportProgress(*args); end

  def self.CallbackProgressReportStart(*args); end

  def self.CallbackProgressScanDb(*args); end

  def self.CallbackResolvableReport(*args); end

  def self.CallbackScriptFinish(*args); end

  def self.CallbackScriptProblem(*args); end

  def self.CallbackScriptProgress(*args); end

  def self.CallbackScriptStart(*args); end

  def self.CallbackSourceChange(*args); end

  def self.CallbackSourceCreateDestroy(*args); end

  def self.CallbackSourceCreateEnd(*args); end

  def self.CallbackSourceCreateError(*args); end

  def self.CallbackSourceCreateInit(*args); end

  def self.CallbackSourceCreateProgress(*args); end

  def self.CallbackSourceCreateStart(*args); end

  def self.CallbackSourceProbeEnd(*args); end

  def self.CallbackSourceProbeError(*args); end

  def self.CallbackSourceProbeFailed(*args); end

  def self.CallbackSourceProbeProgress(*args); end

  def self.CallbackSourceProbeStart(*args); end

  def self.CallbackSourceProbeSucceeded(*args); end

  def self.CallbackSourceReportDestroy(*args); end

  def self.CallbackSourceReportEnd(*args); end

  def self.CallbackSourceReportError(*args); end

  def self.CallbackSourceReportInit(*args); end

  def self.CallbackSourceReportProgress(*args); end

  def self.CallbackSourceReportStart(*args); end

  def self.CallbackStartConvertDb(*args); end

  def self.CallbackStartDeltaApply(*args); end

  def self.CallbackStartDeltaDownload(*args); end

  def self.CallbackStartDownload(*args); end

  def self.CallbackStartPackage(*args); end

  def self.CallbackStartProvide(*args); end

  def self.CallbackStartRebuildDb(*args); end

  def self.CallbackStartRefresh(*args); end

  def self.CallbackStartScanDb(*args); end

  def self.CallbackStopConvertDb(*args); end

  def self.CallbackStopRebuildDb(*args); end

  def self.CallbackTrustedKeyAdded(*args); end

  def self.CallbackTrustedKeyRemoved(*args); end

  def self.CheckGPGKeyFile(*args); end

  def self.ClearSaveState(*args); end

  def self.Commit(*args); end

  def self.CommitPolicy(*args); end

  def self.CompareVersions(*args); end

  def self.Connect(*args); end

  def self.CreateBackups(*args); end

  def self.CreateSolverTestCase(*args); end

  def self.DeleteGPGKey(*args); end

  def self.DoProvide(*args); end

  def self.DoRemove(*args); end

  def self.ExpandedUrl(*args); end

  def self.FilterPackages(*args); end

  def self.GPGKeys(*args); end

  def self.GetAdditionalLocales(*args); end

  def self.GetArchitecture(*args); end

  def self.GetBackupPath(*args); end

  def self.GetLocks(*args); end

  def self.GetPackageLocale(*args); end

  def self.GetPackages(*args); end

  def self.GetSolverFlags(*args); end

  def self.GetTextLocale(*args); end

  def self.GetUpgradeRepos(*args); end

  def self.ImportGPGKey(*args); end

  def self.IsAnyResolvable(*args); end

  def self.IsAvailable(*args); end

  def self.IsManualSelection(*args); end

  def self.IsProvided(*args); end

  def self.IsSelected(*args); end

  def self.LastError(*args); end

  def self.LastErrorDetails(*args); end

  def self.PkgApplReset(*args); end

  def self.PkgAvailable(*args); end

  def self.PkgCommit(*args); end

  def self.PkgDU(*args); end

  def self.PkgDelete(*args); end

  def self.PkgGetFilelist(*args); end

  def self.PkgGetLicenseToConfirm(*args); end

  def self.PkgGetLicensesToConfirm(*args); end

  def self.PkgGroup(*args); end

  def self.PkgInstall(*args); end

  def self.PkgInstalled(*args); end

  def self.PkgLocation(*args); end

  def self.PkgMarkLicenseConfirmed(*args); end

  def self.PkgMediaCount(*args); end

  def self.PkgMediaNames(*args); end

  def self.PkgMediaPackageSizes(*args); end

  def self.PkgMediaSizes(*args); end

  def self.PkgNeutral(*args); end

  def self.PkgPath(*args); end

  def self.PkgProperties(*args); end

  def self.PkgPropertiesAll(*args); end

  def self.PkgQueryProvides(*args); end

  def self.PkgReset(*args); end

  def self.PkgSize(*args); end

  def self.PkgSolve(*args); end

  def self.PkgSolveCheckTargetOnly(*args); end

  def self.PkgSolveErrors(*args); end

  def self.PkgSrcInstall(*args); end

  def self.PkgSummary(*args); end

  def self.PkgTaboo(*args); end

  def self.PkgUpdateAll(*args); end

  def self.PkgVersion(*args); end

  def self.PrdGetLicenseToConfirm(*args); end

  def self.PrdHasLicenseConfirmed(*args); end

  def self.PrdLicenseLocales(*args); end

  def self.PrdMarkLicenseConfirmed(*args); end

  def self.PrdMarkLicenseNotConfirmed(*args); end

  def self.PrdNeedToAcceptLicense(*args); end

  def self.ProvidePackage(*args); end

  def self.RemoveLock(*args); end

  def self.RemoveUpgradeRepo(*args); end

  def self.RepositoryAdd(*args); end

  def self.RepositoryProbe(*args); end

  def self.RepositoryScan(*args); end

  def self.ResolvableCountPatches(*args); end

  def self.ResolvableDependencies(*args); end

  def self.ResolvableInstall(*args); end

  def self.ResolvableInstallArchVersion(*args); end

  def self.ResolvableInstallRepo(*args); end

  def self.ResolvableNeutral(*args); end

  def self.ResolvablePreselectPatches(*args); end

  def self.ResolvableProperties(*args); end

  def self.ResolvableRemove(*args); end

  def self.ResolvableSetSoftLock(*args); end

  def self.ResolvableUpdate(*args); end

  def self.RestoreState(*args); end

  def self.RpmChecksig(*args); end

  def self.SaveState(*args); end

  def self.ServiceAdd(*args); end

  def self.ServiceAliases(*args); end

  def self.ServiceDelete(*args); end

  def self.ServiceForceRefresh(*args); end

  def self.ServiceGet(*args); end

  def self.ServiceProbe(*args); end

  def self.ServiceRefresh(*args); end

  def self.ServiceSave(*args); end

  def self.ServiceSet(*args); end

  def self.ServiceURL(*args); end

  def self.SetAdditionalLocales(*args); end

  def self.SetArchitecture(*args); end

  def self.SetBackupPath(*args); end

  def self.SetPackageLocale(*args); end

  def self.SetSolverFlags(*args); end

  def self.SetTextLocale(*args); end

  def self.SetZConfig(*args); end

  def self.SkipRefresh(*args); end

  def self.SourceCacheCopyTo(*args); end

  def self.SourceChangeUrl(*args); end

  def self.SourceCreate(*args); end

  def self.SourceCreateBase(*args); end

  def self.SourceCreateType(*args); end

  def self.SourceDelete(*args); end

  def self.SourceEditGet(*args); end

  def self.SourceEditSet(*args); end

  def self.SourceFinishAll(*args); end

  def self.SourceForceRefreshNow(*args); end

  def self.SourceGeneralData(*args); end

  def self.SourceGetCurrent(*args); end

  def self.SourceLoad(*args); end

  def self.SourceLowerPriority(*args); end

  def self.SourceMediaData(*args); end

  def self.SourceMoveDownloadArea(*args); end

  def self.SourceProductData(*args); end

  def self.SourceProvideDigestedFile(*args); end

  def self.SourceProvideDirectory(*args); end

  def self.SourceProvideFile(*args); end

  def self.SourceProvideOptionalFile(*args); end

  def self.SourceProvideSignedDirectory(*args); end

  def self.SourceProvideSignedFile(*args); end

  def self.SourceRaisePriority(*args); end

  def self.SourceRawURL(*args); end

  def self.SourceRefreshNow(*args); end

  def self.SourceReleaseAll(*args); end

  def self.SourceRestore(*args); end

  def self.SourceSaveAll(*args); end

  def self.SourceScan(*args); end

  def self.SourceSetAutorefresh(*args); end

  def self.SourceSetEnabled(*args); end

  def self.SourceSetPriority(*args); end

  def self.SourceStartCache(*args); end

  def self.SourceStartManager(*args); end

  def self.SourceURL(*args); end

  def self.SystemArchitecture(*args); end

  def self.TargetAvailable(*args); end

  def self.TargetBlockSize(*args); end

  def self.TargetCapacity(*args); end

  def self.TargetDisableSources(*args); end

  def self.TargetFileHasOwner(*args); end

  def self.TargetFinish(*args); end

  def self.TargetGetDU(*args); end

  def self.TargetInit(*args); end

  def self.TargetInitDU(*args); end

  def self.TargetInitialize(*args); end

  def self.TargetInitializeOptions(*args); end

  def self.TargetInstall(*args); end

  def self.TargetLoad(*args); end

  def self.TargetRebuildDB(*args); end

  def self.TargetRebuildInit(*args); end

  def self.TargetRemove(*args); end

  def self.TargetStoreRemove(*args); end

  def self.TargetUsed(*args); end

  def self.UrlKnownSchemes(*args); end

  def self.UrlSchemeIsDownloading(*args); end

  def self.UrlSchemeIsLocal(*args); end

  def self.UrlSchemeIsRemote(*args); end

  def self.UrlSchemeIsVolatile(*args); end

  def self.ZConfig(*args); end
end

class Yast::PkgGpgCheckHandler
  include ::Yast::Logger
  def accept?(); end

  def config(); end

  def initialize(data, profile); end

  def package(); end

  def path(); end

  def result(); end
  CHK_ERROR = ::T.let(nil, ::T.untyped)
  CHK_FAIL = ::T.let(nil, ::T.untyped)
  CHK_NOKEY = ::T.let(nil, ::T.untyped)
  CHK_NOSIG = ::T.let(nil, ::T.untyped)
  CHK_NOTFOUND = ::T.let(nil, ::T.untyped)
  CHK_NOTTRUSTED = ::T.let(nil, ::T.untyped)
  CHK_OK = ::T.let(nil, ::T.untyped)
  FIND_KEY_ID_CMD = ::T.let(nil, ::T.untyped)
end

class Yast::PkgGpgCheckHandler
  extend ::Yast::Logger
end

class Yast::PopupClass
  def AnyMessage(headline, message); end

  def AnyQuestion(headline, message, yes_button_message, no_button_message, focus); end

  def AnyQuestion3(headline, message, yes_button_message, no_button_message, retry_button_message, focus); end

  def AnyQuestionButtonBox(yes_button_message, no_button_message, focus); end

  def AnyQuestionRichText(headline, richtext, hdim, vdim, yes_button_message, no_button_message, focus); end

  def AnyTimedMessage(headline, message, timeout); end

  def AnyTimedRichMessage(headline, message, timeout); end

  def ClearFeedback(); end

  def ConfirmAbort(severity); end

  def ContinueCancel(message); end

  def ContinueCancelHeadline(headline, message); end

  def Error(message); end

  def ErrorAnyQuestion(headline, message, yes_button_message, no_button_message, focus); end

  def ErrorDetails(message, details); end

  def Feedback(headline, message, &block); end

  def LongError(message); end

  def LongErrorGeometry(message, width, height); end

  def LongMessage(message); end

  def LongMessageGeometry(message, width, height); end

  def LongNotify(message); end

  def LongNotifyGeometry(message, width, height); end

  def LongText(headline, richtext, hdim, vdim); end

  def LongWarning(message); end

  def LongWarningGeometry(message, width, height); end

  def Message(message); end

  def MessageDetails(message, details); end

  def ModuleError(text); end

  def NoHeadline(); end

  def Notify(message); end

  def NotifyDetails(message, details); end

  def ReallyAbort(have_changes); end

  def ShowFeedback(headline, message); end

  def ShowFile(headline, filename); end

  def ShowText(headline, text); end

  def ShowTextTimed(headline, text, timeout); end

  def TimedAnyQuestion(headline, message, yes_button_message, no_button_message, focus, timeout_seconds); end

  def TimedError(message, timeout_seconds); end

  def TimedErrorAnyQuestion(headline, message, yes_button_message, no_button_message, focus, timeout_seconds); end

  def TimedLongError(message, timeout_seconds); end

  def TimedLongErrorGeometry(message, timeout_seconds, width, height); end

  def TimedLongMessage(message, timeout_seconds); end

  def TimedLongMessageGeometry(message, timeout_seconds, width, height); end

  def TimedLongNotify(message, timeout_seconds); end

  def TimedLongNotifyGeometry(message, timeout_seconds, width, height); end

  def TimedLongWarning(message, timeout_seconds); end

  def TimedLongWarningGeometry(message, timeout_seconds, width, height); end

  def TimedMessage(message, timeout_seconds); end

  def TimedNotify(message, timeout_seconds); end

  def TimedOKCancel(message, timeout_seconds); end

  def TimedWarning(message, timeout_seconds); end

  def Warning(message); end

  def WarningDetails(message, details); end

  def YesNo(message); end

  def YesNoHeadline(headline, message); end

  def anyMessageDetailsInternal(headline, message, details); end

  def anyMessageDetailsInternalType(headline, message, details, richtext, width, height); end

  def anyMessageInternal(headline, message); end

  def anyMessageInternalRich(headline, message, width, height); end

  def anyMessageInternalType(headline, message, richtext, width, height); end

  def anyRichMessageInternal(headline, message, width, height); end

  def anyTimedMessageInternal(headline, message, timeout); end

  def anyTimedMessageTypeInternal(headline, message, timeout, richtext, width, height); end

  def anyTimedRichMessageInternal(headline, message, timeout, width, height); end

  def main(); end

  def popupLayoutInternal(headline, message, button_box); end

  def popupLayoutInternalRich(headline, message, button_box, width, height); end

  def popupLayoutInternalTypeWithLabel(headline, message, button_box, label, richtext, width, height); end

  def switch_to_richtext(); end

  def switch_to_richtext=(switch_to_richtext); end

  def too_many_lines(); end

  def too_many_lines=(too_many_lines); end
end

class Yast::PopupClass
end

class Yast::ProductClass
  include ::Yast::Logger
  def FindBaseProducts(); end

  def ReadProducts(); end

  def find_property(key=T.unsafe(nil)); end

  def flags(key=T.unsafe(nil)); end

  def main(); end

  def name(key=T.unsafe(nil)); end

  def product_of_relnotes(key=T.unsafe(nil)); end

  def relnotesurl(key=T.unsafe(nil)); end

  def relnotesurl_all(key=T.unsafe(nil)); end

  def run_you(key=T.unsafe(nil)); end

  def short_name(key=T.unsafe(nil)); end

  def version(key=T.unsafe(nil)); end
  DROPPED_METHODS = ::T.let(nil, ::T.untyped)
  OS_RELEASE_PROPERTIES = ::T.let(nil, ::T.untyped)
end

class Yast::ProductClass
  extend ::Yast::Logger
end

class Yast::ProductControlClass
  include ::Yast::Logger
  def AddWizardSteps(stagemode); end

  def Check(allowed, current); end

  def CheckAdditionalParams(check_workflow); end

  def CurrentStep(); end

  def CurrentWizardStep(); end

  def CurrentWizardStep=(_); end

  def DisableAllModulesAndProposals(mode, stage); end

  def DisableModule(modname); end

  def DisableProposal(disable_proposal); end

  def DisableSubProposal(unique_id, disable_subproposal); end

  def EnableModule(modname); end

  def EnableProposal(enable_proposal); end

  def EnableSubProposal(unique_id, enable_subproposal); end

  def FindMatchingWorkflow(stage, mode); end

  def GetDisabledModules(); end

  def GetDisabledProposals(); end

  def GetDisabledSubProposals(); end

  def GetTranslatedText(key); end

  def Init(); end

  def PrepareScripts(m); end

  def ProductControl(); end

  def ReadControlFile(controlfile); end

  def RequiredFiles(stage, mode); end

  def ResetAdditionalWorkflowParams(); end

  def RestartingStep(); end

  def RetranslateWizardSteps(); end

  def Run(); end

  def RunFrom(from, allow_back); end

  def RunRequired(stage, mode); end

  def SetAdditionalWorkflowParams(params); end

  def SkippedSteps(); end

  def UnDisableAllModulesAndProposals(mode, stage); end

  def UpdateWizardSteps(stagemode); end

  def addToStack(name); end

  def add_system_roles(new_roles); end

  def checkArch(mod, def_); end

  def checkDisabled(mod); end

  def checkHeading(mod); end

  def clone_modules(); end

  def clone_modules=(clone_modules); end

  def current_control_file(); end

  def current_control_file=(current_control_file); end

  def custom_control_file(); end

  def custom_control_file=(custom_control_file); end

  def default_control_file(); end

  def default_control_file=(default_control_file); end

  def first_step(); end

  def first_step=(first_step); end

  def getClientName(name, execute); end

  def getClientTerm(step, def_, former_result); end

  def getCompleteWorkflow(stage, mode); end

  def getMatchingProposal(stage, mode, proptype); end

  def getModeDefaults(stage, mode); end

  def getModules(stage, mode, which); end

  def getProposalProperties(stage, mode, proptype); end

  def getProposalTextDomain(); end

  def getProposals(stage, mode, proptype); end

  def getWorkflowLabel(stage, mode, wz_td); end

  def inst_finish(); end

  def inst_finish=(inst_finish); end

  def last_stage_mode(); end

  def last_stage_mode=(last_stage_mode); end

  def logfiles(); end

  def logfiles=(logfiles); end

  def main(); end

  def packaged_control_file(); end

  def packaged_control_file=(packaged_control_file); end

  def productControl(); end

  def productControl=(productControl); end

  def proposals(); end

  def proposals=(proposals); end

  def restarting_step(); end

  def restarting_step=(restarting_step); end

  def retranslateWizardDialog(); end

  def saved_control_file(); end

  def saved_control_file=(saved_control_file); end

  def setClientPrefix(prefix); end

  def system_roles(); end

  def system_roles=(system_roles); end

  def wasRun(name); end

  def workflows(); end

  def workflows=(workflows); end

  def y2update_control_file(); end

  def y2update_control_file=(y2update_control_file); end
  SYSTEM_ROLES_KEY = ::T.let(nil, ::T.untyped)
end

class Yast::ProductControlClass
  extend ::Yast::Logger
end

class Yast::ProductFeaturesClass
  def ClearOverlay(); end

  def Export(); end

  def GetBooleanFeature(section, feature); end

  def GetFeature(section, feature); end

  def GetIntegerFeature(section, feature); end

  def GetSection(section_name); end

  def GetStringFeature(section, feature); end

  def Import(import_settings); end

  def InitFeatures(force); end

  def InitIfNeeded(); end

  def Restore(); end

  def Save(); end

  def SetBooleanFeature(section, feature, value); end

  def SetFeature(section, feature, value); end

  def SetIntegerFeature(section, feature, value); end

  def SetOverlay(features); end

  def SetSection(section_name, section_map); end

  def SetStringFeature(section, feature, value); end

  def main(); end
end

class Yast::ProductFeaturesClass
end

class Yast::ProfileClass
  include ::Yast::AutoinstallXmlInclude
  def Compat(__current); end

  def Import(profile); end

  def ModuleMap(); end

  def ModuleMap=(_); end

  def Prepare(); end

  def Profile(); end

  def ReadProfileStructure(parsedControlFile); end

  def ReadXML(file); end

  def Reset(); end

  def Save(file); end

  def SaveProfileStructure(parsedControlFile); end

  def SaveSingleSections(dir); end

  def changed(); end

  def changed=(changed); end

  def checkProfile(); end

  def check_version(properties); end

  def current(); end

  def current=(current); end

  def generalCompat(); end

  def main(); end

  def merge_resource_aliases!(); end

  def needed_second_stage_packages(); end

  def prepare(); end

  def prepare=(prepare); end

  def remove_sections(sections); end

  def resource_aliases_map(); end

  def setElementByList(l, v, m); end

  def setLValue(l, v, m); end

  def setMValue(l, v, m); end

  def softwareCompat(); end

  def storageLibCompat(); end
  AUTOYAST_CLIENTS = ::T.let(nil, ::T.untyped)
  GENERIC_PROFILE_SECTIONS = ::T.let(nil, ::T.untyped)
  OBSOLETE_PROFILE_SECTIONS = ::T.let(nil, ::T.untyped)
end

class Yast::ProfileClass
end

class Yast::Profiler
end

class Yast::Profiler
  extend ::Yast::Logger
  def self.start(); end

  def self.start_from_env(); end

  def self.stop(output=T.unsafe(nil)); end
end

class Yast::ProgressClass
  def CloseSuperior(); end

  def CurrentSubprogressType(); end

  def Finish(); end

  def IsRunning(); end

  def Mark(kind); end

  def MarkId(i); end

  def New(window_title, progress_title, length, stg, tits, help_text); end

  def NewProgressIcons(window_title, progress_title, length, stg, tits, help_textmap, _icons_definition); end

  def NextStage(); end

  def NextStageStep(st); end

  def NextStep(); end

  def OpenSuperior(title, stages); end

  def PopState(); end

  def PushState(); end

  def SetProgressBarTitle(s); end

  def Simple(window_title, progress_title, length, help_text); end

  def StackSize(); end

  def Stage(st, title, step); end

  def Step(st); end

  def StepSuperior(); end

  def SubprogressTitle(title); end

  def SubprogressType(type, max_value); end

  def SubprogressValue(value); end

  def Title(t); end

  def TopState(); end

  def UpdateProgressBar(); end

  def main(); end

  def off(); end

  def on(); end

  def set(state); end

  def status(); end
end

class Yast::ProgressClass
end

module Yast::RSpec
end

module Yast::RSpec::Matchers
  def path_matching(match); end
end

class Yast::RSpec::Matchers::PathMatchingMatcher
  def ==(other); end

  def description(); end

  def initialize(expected); end
end

class Yast::RSpec::Matchers::PathMatchingMatcher
end

module Yast::RSpec::Matchers
  extend ::T::Sig
end

module Yast::RSpec::SCR
  def change_scr_root(directory); end

  def reset_scr_root(); end
end

module Yast::RSpec::SCR
  extend ::T::Sig
end

module Yast::RSpec::Shortcuts
  include ::Yast::UIShortcuts
  def path(route); end

  def term(*args); end
end

module Yast::RSpec::Shortcuts
  extend ::T::Sig
end

module Yast::RSpec
  extend ::T::Sig
end

class Yast::ReportClass
  include ::Yast::Logger
  def AnyQuestion(headline, message, yes_button_message, no_button_message, focus); end

  def ClearAll(); end

  def ClearErrors(); end

  def ClearMessages(); end

  def ClearWarnings(); end

  def ClearYesNoMessages(); end

  def DisplayErrors(display, timeout); end

  def DisplayMessages(display, timeout); end

  def DisplayWarnings(display, timeout); end

  def DisplayYesNoMessages(display, timeout); end

  def Error(error_string); end

  def ErrorAnyQuestion(headline, message, yes_button_message, no_button_message, focus); end

  def Export(); end

  def GetMessages(w, e, m, ynm); end

  def GetModified(); end

  def Import(settings); end

  def LogErrors(log); end

  def LogMessages(log); end

  def LogWarnings(log); end

  def LogYesNoMessages(log); end

  def LongError(error_string); end

  def LongMessage(message_string); end

  def LongWarning(warning_string); end

  def Message(message_string); end

  def NumErrors(); end

  def NumMessages(); end

  def NumWarnings(); end

  def NumYesNoMessages(); end

  def SetModified(); end

  def ShowText(headline_string, message_string); end

  def Summary(); end

  def Warning(warning_string); end

  def error_settings(); end

  def error_settings=(error_settings); end

  def main(); end

  def message_settings(); end

  def message_settings=(message_settings); end

  def modified(); end

  def modified=(modified); end

  def warning_settings(); end

  def warning_settings=(warning_settings); end

  def yesno_message_settings(); end

  def yesno_message_settings=(yesno_message_settings); end

  def yesno_popup(message, extra_args=T.unsafe(nil)); end
end

class Yast::ReportClass
  extend ::Yast::Logger
end

class Yast::RichTextClass
  def DetectRichText(file); end

  def DropWS(text); end

  def Rich2Plain(richtext); end

  def main(); end
end

class Yast::RichTextClass
end

module Yast::SCR
  extend ::T::Sig
  def self.Dir(path); end

  def self.Error(path); end

  def self.Execute(path, *args); end

  def self.Read(path, *args); end

  def self.RegisterAgent(path, description); end

  def self.RegisterNewAgents(); end

  def self.UnmountAgent(path); end

  def self.UnregisterAgent(path); end

  def self.UnregisterAllAgents(); end

  def self.Write(path, *args); end

  def self.call_builtin(*_); end
end

class Yast::SLPClass
  def DeReg(service); end

  def DeRegFile(regfile); end

  def FindAttrs(pcURLOrServiceType); end

  def FindSrvTypes(pcNamingAuthority, pcScopeList); end

  def FindSrvs(pcServiceType, pcScopeList); end

  def GetAttrMap(pcURLOrServiceType); end

  def GetUnicastAttrMap(pcURLOrServiceType, ip); end

  def MatchType(match); end

  def Reg(service); end

  def RegFile(service, attr, regfile); end

  def UnicastFindAttrs(pcURLOrServiceType, ip); end

  def main(); end
end

class Yast::SLPClass
end

class Yast::SequencerClass
  def Run(aliases, sequence); end

  def WS_alias(aliases, alias_); end

  def WS_check(aliases, sequence); end

  def WS_error(error); end

  def WS_next(sequence, current, ret); end

  def WS_pop(stack); end

  def WS_push(stack, item); end

  def WS_run(aliases, id); end

  def WS_special(aliases, alias_); end

  def WS_testall(aliases); end

  def main(); end
end

class Yast::SequencerClass
end

class Yast::ServicesManagerTargetClass
  include ::Yast::Logger
  def all(); end

  def default_target(); end

  def default_target=(new_default); end

  def export(); end

  def force(); end

  def force=(force); end

  def import(profile); end

  def modified(); end

  def modified=(modified); end

  def proposal_reason(); end

  def proposal_reason=(proposal_reason); end

  def read(); end

  def reset(); end

  def save(); end

  def targets(); end
  BLACKLISTED_TARGETS = ::T.let(nil, ::T.untyped)
end

module Yast::ServicesManagerTargetClass::BaseTargets
  GRAPHICAL = ::T.let(nil, ::T.untyped)
  MULTIUSER = ::T.let(nil, ::T.untyped)
  TRANSLATIONS = ::T.let(nil, ::T.untyped)
end

module Yast::ServicesManagerTargetClass::BaseTargets
  extend ::Yast::I18n
  extend ::T::Sig
  def self.localize(target_name); end
end

class Yast::ServicesManagerTargetClass
  extend ::Yast::Logger
end

class Yast::SignatureCheckCallbacksClass
  include ::Yast::Logger
  def AcceptFileWithoutChecksum(filename); end

  def AcceptUnknownDigest(filename, digest); end

  def AcceptUnknownGpgKey(filename, keyid, repoid); end

  def AcceptUnsignedFile(filename, repo_id); end

  def AcceptVerificationFailed(filename, key, repo_id); end

  def AcceptWrongDigest(filename, requested_digest, found_digest); end

  def ImportGpgKey(key, repo_id); end

  def TrustedKeyAdded(key); end

  def TrustedKeyRemoved(key); end

  def import_gpg_key_or_disable(key, repo_id); end

  def main(); end
end

class Yast::SignatureCheckCallbacksClass
  extend ::Yast::Logger
end

class Yast::SignatureCheckDialogsClass
  def CheckSignatures(); end

  def CheckSignaturesInYaST(); end

  def GetDefaultDialogReturn(popup_type, popup_url); end

  def GetShowThisPopup(popup_type, popup_url); end

  def ImportGPGKeyIntoTrustedDialog(key, repository); end

  def ItemSignedWithPublicSignature(item_type, item_name, key); end

  def ItemSignedWithUnknownSignature(item_type, item_name, key_id, dont_show_dialog_ident, repoid); end

  def SetDefaultDialogReturn(popup_type, default_return, popup_url); end

  def SetShowThisPopup(popup_type, show_it, popup_url); end

  def UseCorruptedItem(item_type, item_name, key, repository); end

  def UseFileWithUnknownDigest(filename, digest, dont_show_dialog_ident); end

  def UseFileWithWrongDigest(filename, requested_digest, found_digest, dont_show_dialog_ident); end

  def UseItemWithNoChecksum(item_type, item_name, dont_show_dialog_ident); end

  def UseUnsignedItem(item_type, item_name, dont_show_dialog_ident, repository); end

  def main(); end
end

class Yast::SignatureCheckDialogsClass
end

class Yast::SpellcheckTask
  CUSTOM_SPELL_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  GLOBAL_SPELL_CONFIG_FILE = ::T.let(nil, ::T.untyped)
end

class Yast::StageClass
  def Set(new_stage); end

  def cont(); end

  def firstboot(); end

  def initial(); end

  def main(); end

  def normal(); end

  def reprobe(); end

  def stage(); end
end

class Yast::StageClass
end

class Yast::StringClass
  include ::Yast::Logger
  def CAlnum(); end

  def CAlpha(); end

  def CDigit(); end

  def CGraph(); end

  def CLower(); end

  def CPrint(); end

  def CutBlanks(input); end

  def CutRegexMatch(input, regex, glob); end

  def CutZeros(input); end

  def EscapeTags(text); end

  def FindMountPoint(dir, dirs); end

  def FirstChunk(s, separators); end

  def FormatFilename(file_path, len); end

  def FormatRateMessage(text, avg_bps, curr_bps); end

  def FormatSize(bytes); end

  def FormatSizeWithPrecision(bytes, precision, omit_zeroes); end

  def FormatTime(seconds); end

  def FormatTwoDigits(x); end

  def NewlineItems(s); end

  def NonEmpty(l); end

  def OptParens(s); end

  def Pad(text, length); end

  def PadZeros(text, length); end

  def ParseOptions(options, parameters); end

  def Quote(var); end

  def Random(len); end

  def RemoveShortcut(label); end

  def Repeat(text, number); end

  def Replace(s, source, target); end

  def StartsWith(str, test); end

  def SuperPad(text, length, padding, alignment); end

  def TextTable(header, items, options); end

  def UnQuote(var); end

  def UnderlinedHeader(header_line, left_padding); end

  def ValidCharsFilename(); end

  def YesNo(value); end

  def main(); end
  ALPHA_CHARS = ::T.let(nil, ::T.untyped)
  ALPHA_NUM_CHARS = ::T.let(nil, ::T.untyped)
  DIGIT_CHARS = ::T.let(nil, ::T.untyped)
  GRAPHICAL_CHARS = ::T.let(nil, ::T.untyped)
  LOWER_CHARS = ::T.let(nil, ::T.untyped)
  PRINTABLE_CHARS = ::T.let(nil, ::T.untyped)
  PUNCT_CHARS = ::T.let(nil, ::T.untyped)
  SPACE_CHARS = ::T.let(nil, ::T.untyped)
  UPPER_CHARS = ::T.let(nil, ::T.untyped)
end

class Yast::StringClass
  extend ::Yast::Logger
end

class Yast::SummaryClass
  def AddHeader(summary, header); end

  def AddLine(summary, line); end

  def AddListItem(summary, item); end

  def AddNewLine(summary); end

  def AddSimpleSection(summary, header, item); end

  def CloseList(summary); end

  def Device(name, description); end

  def DevicesList(devices); end

  def NotConfigured(); end

  def OpenList(summary); end

  def main(); end
end

class Yast::SummaryClass
end

module Yast::Systemctl
  include ::Yast::Logger
  COMMAND_OPTIONS = ::T.let(nil, ::T.untyped)
  CONTROL = ::T.let(nil, ::T.untyped)
  ENV_VARS = ::T.let(nil, ::T.untyped)
  SYSTEMCTL = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

module Yast::Systemctl
  extend ::Yast::Logger
  extend ::T::Sig
  def self.execute(command); end

  def self.service_units(); end

  def self.socket_units(); end

  def self.target_units(); end
end

class Yast::SystemctlError
  def initialize(details); end
end

class Yast::SystemctlError
end

class Yast::SystemdTargetClass
  include ::Yast::Logger
  def all(propmap=T.unsafe(nil)); end

  def find(target_name, propmap=T.unsafe(nil)); end

  def find!(target_name, propmap=T.unsafe(nil)); end

  def get_default(); end

  def set_default(target); end
  DEFAULT_TARGET = ::T.let(nil, ::T.untyped)
  PROPMAP = ::T.let(nil, ::T.untyped)
  UNIT_SUFFIX = ::T.let(nil, ::T.untyped)
end

class Yast::SystemdTargetClass::Target
  def allow_isolate?(); end

  def set_default(); end
end

class Yast::SystemdTargetClass::Target
end

class Yast::SystemdTargetClass
  extend ::Yast::Logger
end

class Yast::SystemdTargetNotFound
  def initialize(target_name); end
end

class Yast::SystemdTargetNotFound
end

class Yast::SystemdUnit
  include ::Yast::Logger
  def active?(); end

  def command(command_name, options=T.unsafe(nil)); end

  def description(); end

  def disable(); end

  def enable(); end

  def enabled?(); end

  def error(); end

  def id(); end

  def initialize(full_unit_name, propmap=T.unsafe(nil), property_text=T.unsafe(nil)); end

  def loaded?(); end

  def name(); end

  def path(); end

  def properties(); end

  def propmap(); end

  def refresh!(); end

  def reload(); end

  def reload_or_restart(); end

  def reload_or_try_restart(); end

  def restart(); end

  def show(property_text=T.unsafe(nil)); end

  def start(); end

  def status(); end

  def stop(); end

  def try_restart(); end

  def unit_name(); end

  def unit_type(); end
  ACTIVE_STATES = ::T.let(nil, ::T.untyped)
  DEFAULT_PROPMAP = ::T.let(nil, ::T.untyped)
  SUPPORTED_STATES = ::T.let(nil, ::T.untyped)
  SUPPORTED_TYPES = ::T.let(nil, ::T.untyped)
end

class Yast::SystemdUnit::InstallationProperties
  include ::Yast::Logger
  def initialize(systemd_unit); end
end

class Yast::SystemdUnit::InstallationProperties
  extend ::Yast::Logger
end

class Yast::SystemdUnit::PropMap
end

class Yast::SystemdUnit::PropMap
end

class Yast::SystemdUnit::Properties
  include ::Yast::Logger
  def initialize(systemd_unit, property_text); end
end

class Yast::SystemdUnit::Properties
  extend ::Yast::Logger
end

class Yast::SystemdUnit
  extend ::Yast::Logger
end

class Yast::TFTPClass
  def Get(server, remote, local); end

  def Put(server, remote, local); end

  def main(); end
end

class Yast::TFTPClass
end

class Yast::TargetFile
end

class Yast::TargetFile
  def self.read(path); end

  def self.write(path, content); end
end

module Yast::Tasks
  TARGETS_FILE = ::T.let(nil, ::T.untyped)
end

module Yast::Tasks
  extend ::T::Sig
end

class Yast::Term
  include ::Comparable
  include ::Enumerable
  def <<(*args, &block); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def clone(); end

  def each(*args, &block); end

  def empty?(*args, &block); end

  def initialize(value, *params); end

  def nested_find(&block); end

  def params(); end

  def size(*args, &block); end

  def value(); end
end

class Yast::Term
  extend ::Forwardable
end

module Yast::Transfer
end

module Yast::Transfer::FileFromUrl
  include ::Yast
  include ::Yast::Logger
  def basename(filePath); end

  def dirname(filePath); end

  def get_file_from_url(scheme:, host:, urlpath:, localfile:, urltok:, destdir:); end

  def initialize_file_from_url(); end
end

module Yast::Transfer::FileFromUrl
  extend ::Yast::Logger
  extend ::T::Sig
end

module Yast::Transfer
  extend ::T::Sig
end

class Yast::TypeRepositoryClass
  def IsEmpty(value); end

  def TypeRepository(); end

  def enum_validator(values, value); end

  def is_a(value, type); end

  def is_string(s); end

  def main(); end

  def regex_validator(regex, value); end
end

class Yast::TypeRepositoryClass
end

module Yast::UI
  extend ::T::Sig
  def self.AskForExistingDirectory(*args); end

  def self.AskForExistingFile(*args); end

  def self.AskForSaveFileName(*args); end

  def self.Beep(*args); end

  def self.BusyCursor(*args); end

  def self.ChangeWidget(*args); end

  def self.CheckShortcuts(*args); end

  def self.CloseDialog(*args); end

  def self.CloseUI(*args); end

  def self.DumpWidgetTree(*args); end

  def self.FakeUserInput(*args); end

  def self.GetDisplayInfo(*args); end

  def self.GetLanguage(*args); end

  def self.GetProductName(*args); end

  def self.Glyph(*args); end

  def self.HasSpecialWidget(*args); end

  def self.MakeScreenShot(*args); end

  def self.NormalCursor(*args); end

  def self.OpenContextMenu(*args); end

  def self.OpenDialog(*args); end

  def self.OpenUI(*args); end

  def self.PlayMacro(*args); end

  def self.PollInput(*args); end

  def self.PostponeShortcutCheck(*args); end

  def self.QueryWidget(*args); end

  def self.RecalcLayout(*args); end

  def self.Recode(*args); end

  def self.RecordMacro(*args); end

  def self.RedrawScreen(*args); end

  def self.ReplaceWidget(*args); end

  def self.RunInTerminal(*args); end

  def self.RunPkgSelection(*args); end

  def self.SetApplicationIcon(*args); end

  def self.SetApplicationTitle(*args); end

  def self.SetConsoleFont(*args); end

  def self.SetFocus(*args); end

  def self.SetFunctionKeys(*args); end

  def self.SetKeyboard(*args); end

  def self.SetLanguage(*args); end

  def self.SetProductLogo(*args); end

  def self.SetProductName(*args); end

  def self.SetReleaseNotes(*args); end

  def self.StopRecordMacro(*args); end

  def self.TextMode(*args); end

  def self.TimeoutUserInput(*args); end

  def self.UserInput(*args); end

  def self.WaitForEvent(*args); end

  def self.WidgetExists(*args); end

  def self.WizardCommand(*args); end
end

module Yast::UIShortcuts
  def BarGraph(*args); end

  def Bottom(*args); end

  def BusyIndicator(*args); end

  def ButtonBox(*args); end

  def Cell(*args); end

  def Center(*args); end

  def CheckBox(*args); end

  def CheckBoxFrame(*args); end

  def ColoredLabel(*args); end

  def ComboBox(*args); end

  def DateField(*args); end

  def DownloadProgress(*args); end

  def DumbTab(*args); end

  def Dummy(*args); end

  def DummySpecialWidget(*args); end

  def Empty(*args); end

  def Frame(*args); end

  def HBox(*args); end

  def HCenter(*args); end

  def HMultiProgressMeter(*args); end

  def HSpacing(*args); end

  def HSquash(*args); end

  def HStretch(*args); end

  def HVCenter(*args); end

  def HVSquash(*args); end

  def HVStretch(*args); end

  def HWeight(*args); end

  def Header(*args); end

  def Heading(*args); end

  def IconButton(*args); end

  def Id(*args); end

  def Image(*args); end

  def InputField(*args); end

  def IntField(*args); end

  def Item(*args); end

  def Label(*args); end

  def Left(*args); end

  def LogView(*args); end

  def MarginBox(*args); end

  def MenuButton(*args); end

  def MinHeight(*args); end

  def MinSize(*args); end

  def MinWidth(*args); end

  def MultiLineEdit(*args); end

  def MultiSelectionBox(*args); end

  def Opt(*args); end

  def PackageSelector(*args); end

  def PartitionSplitter(*args); end

  def Password(*args); end

  def PatternSelector(*args); end

  def PkgSpecial(*args); end

  def ProgressBar(*args); end

  def PushButton(*args); end

  def RadioButton(*args); end

  def RadioButtonGroup(*args); end

  def ReplacePoint(*args); end

  def RichText(*args); end

  def Right(*args); end

  def SelectionBox(*args); end

  def Slider(*args); end

  def Table(*args); end

  def TextEntry(*args); end

  def TimeField(*args); end

  def TimezoneSelector(*args); end

  def Top(*args); end

  def Tree(*args); end

  def VBox(*args); end

  def VCenter(*args); end

  def VMultiProgressMeter(*args); end

  def VSpacing(*args); end

  def VSquash(*args); end

  def VStretch(*args); end

  def VWeight(*args); end

  def Wizard(*args); end
  UI_TERMS = ::T.let(nil, ::T.untyped)
end

module Yast::UIShortcuts
  extend ::T::Sig
end

class Yast::URLClass
  def Build(tokens); end

  def Check(url); end

  def EscapeString(in_, transform); end

  def FormatURL(tokens, len); end

  def HidePassword(url); end

  def HidePasswordToken(tokens); end

  def MakeMapFromParams(params); end

  def MakeParamsFromMap(params_map); end

  def Parse(url); end

  def UnEscapeString(in_, transform); end

  def ValidChars(); end

  def ValidChars=(_); end

  def main(); end

  def transform_map_filename(); end

  def transform_map_filename=(transform_map_filename); end

  def transform_map_passwd(); end

  def transform_map_passwd=(transform_map_passwd); end

  def transform_map_query(); end

  def transform_map_query=(transform_map_query); end
  SCHEMES_WO_HOST = ::T.let(nil, ::T.untyped)
end

class Yast::URLClass
end

class Yast::URLRecodeClass
  def EscapePassword(input); end

  def EscapePath(input); end

  def EscapeQuery(input); end

  def UnEscape(input); end
  PATH_SAFE_CHARS = ::T.let(nil, ::T.untyped)
  QUERY_SAFE_CHARS = ::T.let(nil, ::T.untyped)
  USERNAME_PASSWORD_FRAGMENT_SAFE_CHARS = ::T.let(nil, ::T.untyped)
end

class Yast::URLRecodeClass
end

module Yast::WFM
  extend ::Yast::Logger
  extend ::T::Sig
  def self.Args(*args); end

  def self.CallFunction(client, args=T.unsafe(nil)); end

  def self.ClientExists(client); end

  def self.Execute(path, *args); end

  def self.GetEncoding(); end

  def self.GetEnvironmentEncoding(); end

  def self.GetLanguage(); end

  def self.Read(path, *args); end

  def self.SCRClose(handle); end

  def self.SCRGetDefault(); end

  def self.SCRGetName(handle); end

  def self.SCROpen(name, check_version); end

  def self.SCRSetDefault(handle); end

  def self.SetLanguage(language, *args); end

  def self.Write(path, *args); end

  def self.call(client, args=T.unsafe(nil)); end

  def self.call_builtin(*_); end

  def self.call_builtin_wrapper(*args); end

  def self.run_client(client); end

  def self.scr_chrooted?(); end

  def self.scr_root(); end
end

class Yast::WizardClass
  def AbortAcceptButtonBox(); end

  def AbortApplyFinishButtonBox(); end

  def AbortInstallationAcceptButtonBox(); end

  def AcceptDialog(); end

  def AddMenu(menu, title, id); end

  def AddMenuEntry(menu, parent_id, title, id); end

  def AddSubMenu(menu, parent_id, title, id); end

  def AddTreeItem(tree, parent, title, id); end

  def BackAbortInstallationNextButtonBox(); end

  def BackAbortNextButtonBox(); end

  def BackNextButtonBox(); end

  def CancelAcceptButtonBox(); end

  def CancelOKButtonBox(); end

  def ClearContents(); end

  def ClearTitleIcon(); end

  def CloseDialog(); end

  def CreateDialog(); end

  def CreateMenu(menu); end

  def CreateMenuInternal(menu, parent); end

  def CreateTree(tree, title); end

  def CreateTreeDialog(); end

  def CreateTreeInternal(tree, parent); end

  def DeleteMenus(); end

  def DeleteTreeItems(); end

  def DisableAbortButton(); end

  def DisableBackButton(); end

  def DisableCancelButton(); end

  def DisableNextButton(); end

  def EnableAbortButton(); end

  def EnableBackButton(); end

  def EnableCancelButton(); end

  def EnableNextButton(); end

  def GenericDialog(button_box); end

  def GenericTreeDialog(button_box); end

  def HasWidgetWizard(); end

  def HideAbortButton(); end

  def HideBackButton(); end

  def HideNextButton(); end

  def HideReleaseNotesButton(); end

  def IsWizardDialog(); end

  def NextBackDialog(); end

  def OKDialog(); end

  def OpenAbortApplyFinishDialog(); end

  def OpenAcceptAbortStepsDialog(); end

  def OpenAcceptDialog(); end

  def OpenAcceptStepsDialog(); end

  def OpenCancelOKDialog(); end

  def OpenCustomDialog(help_space_contents, button_box); end

  def OpenDialog(dialog); end

  def OpenLeftTitleNextBackDialog(); end

  def OpenNextBackDialog(); end

  def OpenNextBackStepsDialog(); end

  def OpenOKDialog(); end

  def OpenTreeNextBackDialog(); end

  def QueryTreeItem(); end

  def ReplaceButtonBox(button_box); end

  def ReplaceCustomHelp(contents); end

  def ReplaceHelp(contents); end

  def RestoreAbortButton(); end

  def RestoreBackButton(); end

  def RestoreHelp(help_text); end

  def RestoreNextButton(); end

  def RestoreScreenShotName(); end

  def RetranslateButtons(); end

  def SelectTreeItem(tree_item); end

  def SetAbortButton(id, label); end

  def SetBackButton(id, label); end

  def SetContents(title, contents, help_text, has_back, has_next); end

  def SetContentsButtons(title, contents, help_text, back_label, next_label); end

  def SetContentsFocus(title, contents, help_text, has_back, has_next, set_focus); end

  def SetDesktopIcon(file); end

  def SetDesktopTitle(file); end

  def SetDesktopTitleAndIcon(file); end

  def SetDialogTitle(titleText); end

  def SetFocusToBackButton(); end

  def SetFocusToNextButton(); end

  def SetHelpText(help_text); end

  def SetNextButton(id, label); end

  def SetProductName(name); end

  def SetScreenShotName(name); end

  def SetTitleIcon(_icon_name); end

  def ShowHelp(help_text); end

  def ShowReleaseNotesButton(label, id); end

  def TimeoutUserInput(timeout_millisec); end

  def TimeoutWaitForEvent(timeout_millisec); end

  def UserInput(); end

  def WaitForEvent(); end

  def haveFancyUI(); end

  def main(); end

  def open_wizard_dialog(*args); end

  def paths_for(icon_name); end

  def set_icon(); end
  DEFAULT_ICON_NAME = ::T.let(nil, ::T.untyped)
  FALLBACK_ICON_DIR = ::T.let(nil, ::T.untyped)
end

class Yast::WizardClass
end

class Yast::XMLClass
  def XMLError(); end

  def XMLToYCPFile(xmlFile); end

  def XMLToYCPString(xmlString); end

  def YCPToXMLFile(docType, contents, outputPath); end

  def YCPToXMLString(docType, contents); end

  def cdataSections(); end

  def cdataSections=(cdataSections); end

  def docs(); end

  def docs=(docs); end

  def listEntries(); end

  def listEntries=(listEntries); end

  def main(); end

  def nameSpace(); end

  def nameSpace=(nameSpace); end

  def rootElement(); end

  def rootElement=(rootElement); end

  def systemID(); end

  def systemID=(systemID); end

  def typeNamespace(); end

  def typeNamespace=(typeNamespace); end

  def xmlCreateDoc(doc, docSettings); end
end

class Yast::XMLClass
end

class Yast::Y2Logger
  include ::Singleton
  def add(severity, _progname=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def initialize(*_args); end
  CALL_FRAME = ::T.let(nil, ::T.untyped)
end

class Yast::Y2Logger
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Yast::YCode
  def call(*_); end
end

class Yast::YCode
end

class Yast::YReference
  def call(*_); end
end

class Yast::YReference
end

module Yast
  extend ::T::Sig
  def self.arg_ref(*args); end

  def self.call_yast_function(*_); end

  def self.deep_copy(object, options=T.unsafe(nil)); end

  def self.find_include_file(_); end

  def self.fun_ref(*args); end

  def self.import(mname); end

  def self.import_pure(_); end

  def self.include(target, path); end

  def self.path(value); end

  def self.strcoll(_, _1); end

  def self.symbols(_); end

  def self.term(*args); end

  def self.ui_component(); end

  def self.ui_component=(ui_component); end

  def self.ui_create(_, _1); end

  def self.ui_finalizer(); end

  def self.y2_logger(*_); end

  def self.y2_logger_helper(level, args); end

  def self.y2debug(*args); end

  def self.y2error(*args); end

  def self.y2internal(*args); end

  def self.y2milestone(*args); end

  def self.y2paths(); end

  def self.y2security(*args); end

  def self.y2warning(*args); end
end

module Yast2
end

class Yast2::FsSnapshot
  include ::Yast::Logger
  def cleanup_algo(); end

  def description(); end

  def initialize(number, snapshot_type, previous_number, timestamp, user, cleanup_algo, description); end

  def number(); end

  def previous(); end

  def previous_number(); end

  def snapshot_type(); end

  def timestamp(); end

  def user(); end
  CLEANUP_STRATEGY = ::T.let(nil, ::T.untyped)
  CREATE_SNAPSHOT_CMD = ::T.let(nil, ::T.untyped)
  FIND_CONFIG_CMD = ::T.let(nil, ::T.untyped)
  LIST_SNAPSHOTS_CMD = ::T.let(nil, ::T.untyped)
  VALID_LINE_REGEX = ::T.let(nil, ::T.untyped)
end

class Yast2::FsSnapshot
  extend ::Yast::Logger
  def self.all(); end

  def self.configure_on_install=(configure_on_install); end

  def self.configure_on_install?(); end

  def self.configure_snapper(); end

  def self.configured?(); end

  def self.create_post(description, previous_number, cleanup: T.unsafe(nil), important: T.unsafe(nil)); end

  def self.create_pre(description, cleanup: T.unsafe(nil), important: T.unsafe(nil)); end

  def self.create_single(description, cleanup: T.unsafe(nil), important: T.unsafe(nil)); end

  def self.create_snapshot?(snapshot_type); end

  def self.find(number); end
end

class Yast2::Popup
end

class Yast2::Popup
  extend ::Yast::I18n
  extend ::Yast::UIShortcuts
  def self.show(message, details: T.unsafe(nil), headline: T.unsafe(nil), timeout: T.unsafe(nil), focus: T.unsafe(nil), buttons: T.unsafe(nil), richtext: T.unsafe(nil), style: T.unsafe(nil)); end
end

class Yast2::PreviousSnapshotNotFound
  def initialize(); end
end

class Yast2::PreviousSnapshotNotFound
end

class Yast2::SnapperNotConfigurable
  def initialize(); end
end

class Yast2::SnapperNotConfigurable
end

class Yast2::SnapperNotConfigured
  def initialize(); end
end

class Yast2::SnapperNotConfigured
end

class Yast2::SnapshotCreationFailed
  def initialize(); end
end

class Yast2::SnapshotCreationFailed
end

module Yast2
  extend ::T::Sig
end

class ZeroDivisionError
  extend ::T::Sig
end
